# 聚簇索引、联合索引、覆盖索引
首先，不同数据库引擎采用的索引可能不同。  
索引：MySQL的索引是B+树。  
B树和B+树的区别是什么？B树内部结点上可以存储真实的KV，而B+树内部节点上只存在Key用于索引，所有的KV都存储在叶子节点上。    
聚簇索引：B+树的Value中存放整个记录。  
非聚簇索引：B+树的Value中只存放指向记录的指针。  
对于InnoDB引擎来说，主键索引是聚簇索引，非主键索引是联合索引。  
在非主键索引的B+树上直接存储记录信息，就可以避免再次查询，这叫覆盖索引。覆盖索引是用空间换时间，避免二次查询。

InnoDB的主键索引是聚簇索引，MyIsam不论是否为主键所有的索引都是非聚簇索引。
**mysql中聚簇索引的设定（InnoDB）**
聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。

# B+树与hash的区别
B+ Tree索引和Hash索引区别
* 哈希索引适合等值查询，但是不无法进行范围查询
* 哈希索引没办法利用索引完成排序
* 哈希索引不支持多列联合索引的最左匹配规则
* 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题


# 聚簇索引的缺点
聚簇索引的缺点：
1. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。  
2. 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
3. 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。
4. 采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。

# 为什么主键通常建议使用自增id
聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停地寻道不停地旋转。聚簇索引则只需一次I/O。

如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。 

# 创建索引的注意事项
* 对于取值较少的字段不要建立索引
* 建立多字段索引的时候注意顺序，把区分度高的字段放在前面能够提高效率
