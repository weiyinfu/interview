# ACID

事务是由一组 SQL 语句组成的逻辑处理单元，事务具有 ACID 属性。

- 原子性（Atomicity）：事务是一个原子操作单元。在当时原子是不可分割的最小元素，其对数据的修改，要么全部成功，要么全部都不成功。如果事务执行中发生失败，会回滚到事务执行之前的状态。
- 一致性（Consistent）：事务开始到结束的时间段内，数据都必须保持一致状态。数据一致性，就是当多个用户试图同时访问一个数据库，它们的事务同时使用相同的数据，可能会发生以下四种情况：（写写）丢失更新、未确定的相关性、不一致的分析和幻想读。数据库一致性指的是事务执行之前和执行之后都要满足数据库的约束，例如外键约束、唯一键约束等。
- 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的"独立"环境执行。
- 持久性（Durable）：事务完成后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

# 事务常见问题

|     | 读   | 写       |
| --- | ---- | -------- |
| 读  | 正常 | 脏读     |
| 写  | 幻读 | 更新丢失 |

- 更新丢失（Lost Update）原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比 github 提交冲突。
- 脏读（Dirty Reads）原因：事务 A 读取了事务 B 已经修改但尚未提交的数据。若事务 B 回滚数据，事务 A 的数据存在不一致性的问题。脏读就是读未提交。
- 不可重复读（Non-Repeatable Reads）原因：事务 A 第一次读取最初数据，第二次读取事务 B 已经提交的修改或删除数据。导致两次读取数据不一致。不符合事务的隔离性。幻读就是读已提交。
- 幻读（Phantom Reads）原因：事务 A 根据相同条件第二次查询到事务 B 提交的新增数据，两次数据结果集不一致。不符合事务的隔离性。

脏读、幻读、不可重复读的区别：  
别人写数据，我读数据。别人未提交，则我脏读。别人已提交，若别人提交的是 update/delete，则我不可重复读；若别人提交的是 insert，则我幻读。

# OLTP 与 OLAP 的介绍

数据处理大致可以分成两大类：联机事务处理 OLTP（on-line transaction processing）、联机分析处理 OLAP（On-Line Analytical Processing）。OLTP 是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP 是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。

- OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量、并发操作；
- OLAP 系统则强调数据分析，强调 SQL 执行时长，强调磁盘 I/O、分区等。

LOTP：MySQL，传统后端。
OLAP：HBase，大数据，推荐、广告。

# 数据库查询时 join 的几种方式

- inner join：左右取交集
- left join：以左边为准
- right join: 以右边为准
- outter join:左右取并集

默认是 inner join

# 冷热分离

冷数据和热数据区分对待，热数据使用缓存。

# 数据库的 ACID 中的 I 表示 Isolation，隔离性有几种级别？

1. 读未提交（Read Uncommitted）：即便没有提交也会被其它事务读到
   最低级别的隔离级别，一个事务可以读取到另一个事务未提交的数据，可能会出现脏读、不可重复读和幻读等问题。
2. 读已提交（Read Committed）：只有已经提交的才会被其它事务读到
   一个事务只能读取到另一个事务已经提交的数据，避免了脏读问题，但仍可能出现不可重复读和幻读问题。
3. 可重复读（Repeatable Read）：读的时候，完全不考虑其它事务；事务一旦开始就创建一个时间戳
   一个事务在执行期间读取到的数据始终保持一致，不受其他事务的影响，避免了不可重复读问题，使用间隙锁、nextKeyLock 等锁的机制解决了幻读问题。
4. 串行化（Serializable）：最高级别的隔离级别，所有事务必须按顺序依次执行，避免了所有并发问题，但也牺牲了系统的并发性能。

隔离级别越高，数据的一致性和隔离性就越好，但也会带来更多的性能开销和系统负担。在实际应用中，需要根据具体的业务需求和系统性能要求，选择合适的隔离级别。

事务容易存在的问题：脏读、幻读、不可重复读、更新丢失。  
更新丢失是严重错误，任何数据库都无法容忍这种错误。  
事务的隔离性为读未提交的时候，存在脏读问题。  
事务隔离性为读已提交的时候，脏读问题不存在，但是幻读和不可重复读问题依旧存在。  
事务隔离性为可重复读的时候，脏读、不可重复读消失，唯独存在幻读问题。  
串行化可以解决一切问题。但是并发性最差。

SQL 语句查看隔离级别：

```
SQL8之前：
SELECT @@GLOBAL.tx_isolation, @@tx_isolation;
SQL8之后：
SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;

```

默认的隔离级别是可重复读。

修改隔离级别

```
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
```

# 幻读如何解决？数据库中有哪些锁？

mysql 默认的事务隔离级别为可重复读，解决了脏读、不可重复读问题，幻读问题是如何解决的呢？
MySQL 中提出了 Next-Key Lock 来解决幻读问题，当然这个方案也只在 REPEATABLE READ 这个隔离级别下生效。要把这个问题理解透，你得搞明白三把锁：Record Lock、Gap Lock 以及 Next-Key Lock。

- RecordLock：锁住一个记录，也就是行锁
- GapLock：间隙锁，可以用来解决幻读问题，只在可重复读隔离级别下有小。
- NextKeyLock：

# 事务的 ACID 是如何实现的？

事务的特性与 undo log 和 redo log 密切相关。undo log 用于事务回滚（原子性），redo log 用于实现宕机之后数据恢复（持久性）。

每次开启一个事务，则 mysql 的 innodb 引擎就会生成一张 undo log 文件，该文件主要记录这个事务 ID 所产生的一些更新、删除、插入操作。

当事务 1 执行 update 的时候，就会将 udpate 记录到 undo log 文件，当事务进行 commit 的时候，就会将 undo log 文件删除，如果回滚时，则会根据 undo log 文件的内容进行执行插入回滚 SQL 脚本。

redo log 文件是数据库的一个共享的文件，也是一份写缓存的文件，试想一下，每次操作读写都需要去访问磁盘的随机 IO，其实会很耗时，因此可以将一些频繁的页内容加载到内存的一个缓存 buffer 中，当进行读操作时去查看缓存 buffer 是否有对应的数据，如果没有，则去磁盘查询，查询后再将查询的结果写入到缓存 buffer。当执行写操作的时候，就先去更新缓存 buffer,等到一定时间，将缓存 buffer 的数据再一次写入到磁盘中。但是这样就会有一个数据一致性的问题了，假设 buffer 的数据没有 flush 到磁盘，mysql 服务器就宕机了，那内存的 buffer 的数据也会清空，redo log 就解决了数据一致性的问题。

写操作的时候，不会写入到缓存 buffer 中，而是写入到 redo log 中，当事务提交后，redo log 的内容就 flush 到磁盘中，redo log 是一个文件，当服务器宕机了，也不影响 redo log 已保存后的数据，当 mysql 进行宕机后，redo log 还是有内容的，如果想事务提交，则就执行 redo log 的数据到磁盘，一般而言是会将 redo log 的数据进行回滚，也就是删除数据。

下面具体说一下 ACID 是如何实现的？

- A：使用 undo log 进行回滚
- C：
- I：采用 mvcc 进行，通过版本链，read view 等实现。
- D：持久性，redo log 保证了持久性，每次 commit 都会把日志添加到 redolog 中。redo log 是持久化到磁盘的。

# 参考资料

https://blog.csdn.net/xinyuan_java/article/details/128493205
