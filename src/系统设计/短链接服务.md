短链接，通俗来说，就是将长的URL网址，通过程序计算等方式，转换为简短的网址字符串。 
如果创建一个短链系统，我们应该做什么呢？
* 将长链接变为短链
* 将短链变为长链，把用户请求重定向到长链

# 原理解析
当我们在浏览器里输入 http://t.cn/RlB2PdD 时， DNS首先解析获得 http://t.cn 的 IP 地址
当 DNS 获得 IP 地址以后（比如：74.125.225.72），会向这个地址发送 HTTP GET 请求，查询短码 RlB2PdD。  
http://t.cn 服务器会通过短码 RlB2PdD 获取对应的长 URL。
请求通过 HTTP 重定向状态码把请求重定向到对应的长URL上。  

# 301和302重定向的区别
* 301：旧地址资源永久移除。  
* 302：旧地址资源依旧可以访问，跳转为临时跳转。 

短网址服务使用301或者302都可以，各有利弊。
* 301是永久重定向，客户端请求一次之后会进行缓存，下次访问短网址的时候可以减少对短网址服务的一次请求，有利于减轻服务压力。但是缺点就是后端无法统计每个短链的访问次数。    
* 302是临时重定向，客户端每次访问短链都会执行获取长链的过程，这样后端拥有较大的控制权。基于此可以添加一些访问计数等功能。

# 短网址的字符
生成的短链中通常由比较易读的字符组成，一般使用大小写字母+数字共计62个字符表示。  
短网址的长度一般是6位，62^6=568亿，一般足够使用了。
# 短网址算法一：自增id
自增id的意思就是把数字映射成62进制的数字。

自增id如何避免顺序访问进行攻击？可以对62个字符的顺序打乱进行随机映射。

> 延伸问题：如何实现一个id服务？id服务如何解决并发问题。也就是实现一个发号器。并发问题的解决：每个实例每次多取几个号。
> 常用的id类型有哪些？自增id，uuid，snowflake，

# 短网址算法二：杂凑算法
基于md5或者sha等密码学中的随机散列算法，将最终结果模62^6即可，或者直接取前面若干位。  
长变短可以通过算法解决，短变长则只能依靠查询数据库解决。所以数据库里面还是要存储长短链映射。

这种算法有一定概率存在冲突。当发现冲突的时候（长链变短链时），需要解决冲突。这其实就类似哈希表发生冲突之后怎么办。对短链执行加一操作，直到没有冲突为止。或者使用二次哈希法，继续哈希。

> 哈希表冲突之后有几种解决方法？开链法，用一个链表存储重复元素；二次哈希法，继续执行哈希函数；顺序走，直到发现空白位置为止。


# 数据库设计
由短链查长链需要在短链上创建索引。  