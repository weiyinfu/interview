三种级别的锁
- 线程锁
- 进程锁
- 分布式锁

随着锁的粒度增大，获取锁的难度增大。
锁的粒度越大，并发越小。

如果觉得分布式锁足够高效，每个worker都使用分布式锁就可以，不用考虑进程锁、线程锁。
如果使用进程锁，可以弃用线程锁吗？
信号量semarphore
信号量是荷兰计算机科学家dijstra发明的，P、V两个字母是荷兰语字母缩写，分别表示acquire和release。
P、V操作
- P：请求分配一个单位资源
- V：释放一个资源

# 分布式锁的实现
## 基于mysql
- 需要考虑删除（释放锁的过程）
  基于redis：setnx+超时+（刷新锁）
```go
package main

import (
"fmt"
"sync"
"time"

    "github.com/go-redis/redis"
)

func incr() {
client := redis.NewClient(&redis.Options{
Addr:     "localhost:6379",
Password: "", // no password set
DB:       0,  // use default DB
})

    var lockKey = "counter_lock"
    var counterKey = "counter"
 
    // lock
    resp := client.SetNX(lockKey, 1, time.Second*5)
    lockSuccess, err := resp.Result()
 
    if err != nil || !lockSuccess {
        fmt.Println(err, "lock result: ", lockSuccess)
        return
    }
 
    // counter ++
    getResp := client.Get(counterKey)
    cntValue, err := getResp.Int64()
    if err == nil || err == redis.Nil {
        cntValue++
        resp := client.Set(counterKey, cntValue, 0)
        _, err := resp.Result()
        if err != nil {
            // log err
            println("set value error!")
        }
    }
    println("current counter is ", cntValue)
 
    delResp := client.Del(lockKey)
    unlockSuccess, err := delResp.Result()
    if err == nil && unlockSuccess > 0 {
        println("unlock success!")
    } else {
        println("unlock failed", err)
    }
}

func main() {
  var wg sync.WaitGroup
  for i := 0; i < 10; i++ {
    wg.Add(1)
    go func() {
      defer wg.Done()
      incr()
    }()
  }
  wg.Wait()
}
```

## 基于zookeeper
基于paxos算法，最正规，API最清晰，不需要实现轮询，只需要实现回调。
```
package main

import (
"time"

    "github.com/samuel/go-zookeeper/zk"
)

func main() {
c, _, err := zk.Connect([]string{"127.0.0.1"}, time.Second) //*10)
if err != nil {
panic(err)
}
l := zk.NewLock(c, "/lock", zk.WorldACL(zk.PermAll))
err = l.Lock()
if err != nil {
panic(err)
}
println("lock succ, do your business logic")

    time.Sleep(time.Second * 10)
 
    // do some thing
    l.Unlock()
    println("unlock succ, finish business logic")
```
## 基于ETCD
```go
package main

import (
"log"

    "github.com/zieckey/etcdsync"
)

func main() {
m, err := etcdsync.New("/lock", 10, []string{"http://127.0.0.1:2379"})
if m == nil || err != nil {
log.Printf("etcdsync.New failed")
return
}
err = m.Lock()
if err != nil {
log.Printf("etcdsync.Lock failed")
return
}

    log.Printf("etcdsync.Lock OK")
    log.Printf("Get the lock. Do something here.")
 
    err = m.Unlock()
    if err != nil {
        log.Printf("etcdsync.Unlock failed")
    } else {
        log.Printf("etcdsync.Unlock OK")
    }
}
```

# python操作zookeeper
kazoo
https://www.cnblogs.com/sanduzxcvbnm/p/11579380.html
