<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>面试</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">1.</strong> C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="C++/C++面试题.html"><strong aria-hidden="true">1.1.</strong> C++面试题.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">2.</strong> 系统设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="系统设计/短链接服务.html"><strong aria-hidden="true">2.1.</strong> 短链接服务.md</a></li><li class="chapter-item expanded "><a href="系统设计/系统设计基础.html"><strong aria-hidden="true">2.2.</strong> 系统设计基础.md</a></li><li class="chapter-item expanded "><a href="系统设计/工程设计.html"><strong aria-hidden="true">2.3.</strong> 工程设计.md</a></li><li class="chapter-item expanded "><a href="系统设计/两个文件URL去重.html"><strong aria-hidden="true">2.4.</strong> 两个文件URL去重.md</a></li><li class="chapter-item expanded "><a href="系统设计/关注关系设计.html"><strong aria-hidden="true">2.5.</strong> 关注关系设计.md</a></li><li class="chapter-item expanded "><a href="系统设计/秒杀系统.html"><strong aria-hidden="true">2.6.</strong> 秒杀系统.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">3.</strong> 操作系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="操作系统/计算机操作系统-死锁.html"><strong aria-hidden="true">3.1.</strong> 计算机操作系统-死锁.md</a></li><li class="chapter-item expanded "><a href="操作系统/计算机操作系统-概述.html"><strong aria-hidden="true">3.2.</strong> 计算机操作系统-概述.md</a></li><li class="chapter-item expanded "><a href="操作系统/计算机操作系统-内存管理.html"><strong aria-hidden="true">3.3.</strong> 计算机操作系统-内存管理.md</a></li><li class="chapter-item expanded "><a href="操作系统/Linux.html"><strong aria-hidden="true">3.4.</strong> Linux.md</a></li><li class="chapter-item expanded "><a href="操作系统/进程与线程通信方式.html"><strong aria-hidden="true">3.5.</strong> 进程与线程通信方式.md</a></li><li class="chapter-item expanded "><a href="操作系统/计算机操作系统-链接.html"><strong aria-hidden="true">3.6.</strong> 计算机操作系统-链接.md</a></li><li class="chapter-item expanded "><a href="操作系统/计算机操作系统-设备管理.html"><strong aria-hidden="true">3.7.</strong> 计算机操作系统-设备管理.md</a></li><li class="chapter-item expanded "><a href="操作系统/计算机操作系统-进程管理.html"><strong aria-hidden="true">3.8.</strong> 计算机操作系统-进程管理.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">4.</strong> 算法</a></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">5.</strong> redis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="redis/Redis.html"><strong aria-hidden="true">5.1.</strong> Redis.md</a></li><li class="chapter-item expanded "><a href="redis/Redis21问.html"><strong aria-hidden="true">5.2.</strong> Redis21问.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">6.</strong> 网络安全</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="网络安全/攻击技术.html"><strong aria-hidden="true">6.1.</strong> 攻击技术.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">7.</strong> 数据库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="数据库/分库分表.html"><strong aria-hidden="true">7.1.</strong> 分库分表.md</a></li><li class="chapter-item expanded "><a href="数据库/MySQL.html"><strong aria-hidden="true">7.2.</strong> MySQL.md</a></li><li class="chapter-item expanded "><a href="数据库/SQL.html"><strong aria-hidden="true">7.3.</strong> SQL.md</a></li><li class="chapter-item expanded "><a href="数据库/缓存.html"><strong aria-hidden="true">7.4.</strong> 缓存.md</a></li><li class="chapter-item expanded "><a href="数据库/数据库系统原理.html"><strong aria-hidden="true">7.5.</strong> 数据库系统原理.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">8.</strong> java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/JavaIO.html"><strong aria-hidden="true">8.1.</strong> JavaIO.md</a></li><li class="chapter-item expanded "><a href="java/Java并发.html"><strong aria-hidden="true">8.2.</strong> Java并发.md</a></li><li class="chapter-item expanded "><a href="java/Java面试题.html"><strong aria-hidden="true">8.3.</strong> Java面试题.md</a></li><li class="chapter-item expanded "><a href="java/Java基础.html"><strong aria-hidden="true">8.4.</strong> Java基础.md</a></li><li class="chapter-item expanded "><a href="java/Java容器.html"><strong aria-hidden="true">8.5.</strong> Java容器.md</a></li><li class="chapter-item expanded "><a href="java/Java虚拟机.html"><strong aria-hidden="true">8.6.</strong> Java虚拟机.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">9.</strong> 计算机网络</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="计算机网络/HTTP.html"><strong aria-hidden="true">9.1.</strong> HTTP.md</a></li><li class="chapter-item expanded "><a href="计算机网络/计算机网络-网络层.html"><strong aria-hidden="true">9.2.</strong> 计算机网络-网络层.md</a></li><li class="chapter-item expanded "><a href="计算机网络/计算机网络-应用层.html"><strong aria-hidden="true">9.3.</strong> 计算机网络-应用层.md</a></li><li class="chapter-item expanded "><a href="计算机网络/计算机网络-概述.html"><strong aria-hidden="true">9.4.</strong> 计算机网络-概述.md</a></li><li class="chapter-item expanded "><a href="计算机网络/Socket.html"><strong aria-hidden="true">9.5.</strong> Socket.md</a></li><li class="chapter-item expanded "><a href="计算机网络/TCP和UDP的区别.html"><strong aria-hidden="true">9.6.</strong> TCP和UDP的区别.md</a></li><li class="chapter-item expanded "><a href="计算机网络/计算机网络-物理层.html"><strong aria-hidden="true">9.7.</strong> 计算机网络-物理层.md</a></li><li class="chapter-item expanded "><a href="计算机网络/计算机网络-链路层.html"><strong aria-hidden="true">9.8.</strong> 计算机网络-链路层.md</a></li><li class="chapter-item expanded "><a href="计算机网络/计算机网络-传输层.html"><strong aria-hidden="true">9.9.</strong> 计算机网络-传输层.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">10.</strong> 常识</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="常识/微服务.html"><strong aria-hidden="true">10.1.</strong> 微服务.md</a></li><li class="chapter-item expanded "><a href="常识/Python.html"><strong aria-hidden="true">10.2.</strong> Python.md</a></li><li class="chapter-item expanded "><a href="常识/大数据.html"><strong aria-hidden="true">10.3.</strong> 大数据.md</a></li><li class="chapter-item expanded "><a href="常识/正则表达式.html"><strong aria-hidden="true">10.4.</strong> 正则表达式.md</a></li><li class="chapter-item expanded "><a href="常识/构建工具.html"><strong aria-hidden="true">10.5.</strong> 构建工具.md</a></li><li class="chapter-item expanded "><a href="常识/面向对象思想.html"><strong aria-hidden="true">10.6.</strong> 面向对象思想.md</a></li><li class="chapter-item expanded "><a href="常识/分布式.html"><strong aria-hidden="true">10.7.</strong> 分布式.md</a></li><li class="chapter-item expanded "><a href="常识/结集.html"><strong aria-hidden="true">10.8.</strong> 结集.md</a></li><li class="chapter-item expanded "><a href="常识/代码风格规范.html"><strong aria-hidden="true">10.9.</strong> 代码风格规范.md</a></li><li class="chapter-item expanded "><a href="常识/简历的重要性.html"><strong aria-hidden="true">10.10.</strong> 简历的重要性.md</a></li><li class="chapter-item expanded "><a href="常识/消息队列.html"><strong aria-hidden="true">10.11.</strong> 消息队列.md</a></li><li class="chapter-item expanded "><a href="常识/腾讯面试合集.html"><strong aria-hidden="true">10.12.</strong> 腾讯面试合集.md</a></li><li class="chapter-item expanded "><a href="常识/常用组件.html"><strong aria-hidden="true">10.13.</strong> 常用组件.md</a></li><li class="chapter-item expanded "><a href="常识/数据结构与算法.html"><strong aria-hidden="true">10.14.</strong> 数据结构与算法.md</a></li><li class="chapter-item expanded "><a href="常识/计算机基础.html"><strong aria-hidden="true">10.15.</strong> 计算机基础.md</a></li><li class="chapter-item expanded "><a href="常识/Git.html"><strong aria-hidden="true">10.16.</strong> Git.md</a></li><li class="chapter-item expanded "><a href="常识/代码可读性.html"><strong aria-hidden="true">10.17.</strong> 代码可读性.md</a></li><li class="chapter-item expanded "><a href="常识/Docker.html"><strong aria-hidden="true">10.18.</strong> Docker.md</a></li><li class="chapter-item expanded "><a href="常识/阿里面试题合集.html"><strong aria-hidden="true">10.19.</strong> 阿里面试题合集.md</a></li><li class="chapter-item expanded "><a href="常识/集群.html"><strong aria-hidden="true">10.20.</strong> 集群.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">11.</strong> 设计模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="设计模式/设计模式-简单工厂.html"><strong aria-hidden="true">11.1.</strong> 设计模式-简单工厂.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-代理.html"><strong aria-hidden="true">11.2.</strong> 设计模式-代理.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-外观.html"><strong aria-hidden="true">11.3.</strong> 设计模式-外观.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式.html"><strong aria-hidden="true">11.4.</strong> 设计模式.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-观察者.html"><strong aria-hidden="true">11.5.</strong> 设计模式-观察者.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-装饰.html"><strong aria-hidden="true">11.6.</strong> 设计模式-装饰.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-迭代器.html"><strong aria-hidden="true">11.7.</strong> 设计模式-迭代器.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-组合.html"><strong aria-hidden="true">11.8.</strong> 设计模式-组合.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-状态.html"><strong aria-hidden="true">11.9.</strong> 设计模式-状态.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-单例.html"><strong aria-hidden="true">11.10.</strong> 设计模式-单例.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-抽象工厂.html"><strong aria-hidden="true">11.11.</strong> 设计模式-抽象工厂.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-生成器.html"><strong aria-hidden="true">11.12.</strong> 设计模式-生成器.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-策略.html"><strong aria-hidden="true">11.13.</strong> 设计模式-策略.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-命令.html"><strong aria-hidden="true">11.14.</strong> 设计模式-命令.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-桥接.html"><strong aria-hidden="true">11.15.</strong> 设计模式-桥接.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-工厂方法.html"><strong aria-hidden="true">11.16.</strong> 设计模式-工厂方法.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-中介者.html"><strong aria-hidden="true">11.17.</strong> 设计模式-中介者.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-访问者.html"><strong aria-hidden="true">11.18.</strong> 设计模式-访问者.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-空对象.html"><strong aria-hidden="true">11.19.</strong> 设计模式-空对象.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-备忘录.html"><strong aria-hidden="true">11.20.</strong> 设计模式-备忘录.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-模板方法.html"><strong aria-hidden="true">11.21.</strong> 设计模式-模板方法.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-适配器.html"><strong aria-hidden="true">11.22.</strong> 设计模式-适配器.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-责任链.html"><strong aria-hidden="true">11.23.</strong> 设计模式-责任链.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-享元.html"><strong aria-hidden="true">11.24.</strong> 设计模式-享元.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-原型模式.html"><strong aria-hidden="true">11.25.</strong> 设计模式-原型模式.md</a></li><li class="chapter-item expanded "><a href="设计模式/设计模式-解释器.html"><strong aria-hidden="true">11.26.</strong> 设计模式-解释器.md</a></li></ol></li><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">12.</strong> 前端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="前端/前端.html"><strong aria-hidden="true">12.1.</strong> 前端.md</a></li><li class="chapter-item expanded "><a href="前端/前端工程师210问.html"><strong aria-hidden="true">12.2.</strong> 前端工程师210问.md</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">面试</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#目录" id="目录">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<ul>
<li>阐述如何设计一个C++类？实现String类。</li>
<li>谈谈对C++虚函数机制的理解。</li>
<li>STL的Vector原理及迭代器失效的理解。</li>
<li>设计一个C++HashMap类。</li>
<li>使用C++实现一个堆的模板类。</li>
<li>写一个宏定义比较函数并解释宏展开过程。</li>
<li>谈谈std::move的理解和使用。</li>
<li>malloc的内存可以用delete释放吗？原因？</li>
<li>简述C++11的新特性以及解决了什么问题。</li>
<li>STL的Map原理、插入和删除复杂度分析。</li>
<li>STL的Map基于红黑树实现的原因，为什么不选择哈希表？</li>
<li>为什么需要虚析构？虚析构和普通析构函数的区别是什么？</li>
<li>说明C++对象的内存布局模型。</li>
<li>聊聊C++临时对象和右值引用，写个例子。</li>
<li>使用C++写一个高效的多维矩阵乘法。</li>
<li>谈谈对智能指针的认识并实现一个智能指针类。</li>
<li>STL中Map的查找时[]和find区别是什么？哪个更快？</li>
<li>实现memcpy函数效率尽可能高。</li>
<li>尝试实现C/C++中常用字符串库函数。</li>
<li>谈谈C++中强制类型转换的原理和使用，写个例子。</li>
<li>谈谈C++的设计模式，重点介绍下单例模式、工程模式等。</li>
</ul>
<h1><a class="header" href="#常用组件" id="常用组件">常用组件</a></h1>
<ul>
<li>常用的MQ有哪些以及各自的对比和场景</li>
<li>Kafka的基本原理和实现要点</li>
<li>libevent/libuv的基本原理和使用</li>
<li>Boost.Asio的原理和使用</li>
<li>微信协程库libco原理和使用</li>
<li>DPDK的基本原理和用户态协议栈的概念</li>
<li>Redis和Memcached对比</li>
<li>RPC框架对比：brpc/grpc/thrift</li>
<li>STL源码的理解和阅读分析</li>
<li>Nginx的架构、原理、使用</li>
</ul>
<h1><a class="header" href="#目录-1" id="目录-1">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<p>短链接，通俗来说，就是将长的URL网址，通过程序计算等方式，转换为简短的网址字符串。 
如果创建一个短链系统，我们应该做什么呢？</p>
<ul>
<li>将长链接变为短链</li>
<li>将短链变为长链，把用户请求重定向到长链</li>
</ul>
<h1><a class="header" href="#原理解析" id="原理解析">原理解析</a></h1>
<p>当我们在浏览器里输入 http://t.cn/RlB2PdD 时， DNS首先解析获得 http://t.cn 的 IP 地址
当 DNS 获得 IP 地址以后（比如：74.125.225.72），会向这个地址发送 HTTP GET 请求，查询短码 RlB2PdD。<br />
http://t.cn 服务器会通过短码 RlB2PdD 获取对应的长 URL。
请求通过 HTTP 重定向状态码把请求重定向到对应的长URL上。</p>
<h1><a class="header" href="#301和302重定向的区别" id="301和302重定向的区别">301和302重定向的区别</a></h1>
<ul>
<li>301：旧地址资源永久移除。</li>
<li>302：旧地址资源依旧可以访问，跳转为临时跳转。 </li>
</ul>
<p>短网址服务使用301或者302都可以，各有利弊。</p>
<ul>
<li>301是永久重定向，客户端请求一次之后会进行缓存，下次访问短网址的时候可以减少对短网址服务的一次请求，有利于减轻服务压力。但是缺点就是后端无法统计每个短链的访问次数。</li>
<li>302是临时重定向，客户端每次访问短链都会执行获取长链的过程，这样后端拥有较大的控制权。基于此可以添加一些访问计数等功能。</li>
</ul>
<h1><a class="header" href="#短网址的字符" id="短网址的字符">短网址的字符</a></h1>
<p>生成的短链中通常由比较易读的字符组成，一般使用大小写字母+数字共计62个字符表示。<br />
短网址的长度一般是6位，62^6=568亿，一般足够使用了。</p>
<h1><a class="header" href="#短网址算法一自增id" id="短网址算法一自增id">短网址算法一：自增id</a></h1>
<p>自增id的意思就是把数字映射成62进制的数字。</p>
<p>自增id如何避免顺序访问进行攻击？可以对62个字符的顺序打乱进行随机映射。</p>
<blockquote>
<p>延伸问题：如何实现一个id服务？id服务如何解决并发问题。也就是实现一个发号器。并发问题的解决：每个实例每次多取几个号。
常用的id类型有哪些？自增id，uuid，snowflake，</p>
</blockquote>
<h1><a class="header" href="#短网址算法二杂凑算法" id="短网址算法二杂凑算法">短网址算法二：杂凑算法</a></h1>
<p>基于md5或者sha等密码学中的随机散列算法，将最终结果模62^6即可，或者直接取前面若干位。<br />
长变短可以通过算法解决，短变长则只能依靠查询数据库解决。所以数据库里面还是要存储长短链映射。</p>
<p>这种算法有一定概率存在冲突。当发现冲突的时候（长链变短链时），需要解决冲突。这其实就类似哈希表发生冲突之后怎么办。对短链执行加一操作，直到没有冲突为止。或者使用二次哈希法，继续哈希。</p>
<blockquote>
<p>哈希表冲突之后有几种解决方法？开链法，用一个链表存储重复元素；二次哈希法，继续执行哈希函数；顺序走，直到发现空白位置为止。</p>
</blockquote>
<h1><a class="header" href="#数据库设计" id="数据库设计">数据库设计</a></h1>
<p>由短链查长链需要在短链上创建索引。  </p>
<!-- GFM-TOC -->
<ul>
<li><a href="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html#%E4%B8%80%E6%80%A7%E8%83%BD">一、性能</a></li>
<li><a href="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E4%BC%B8%E7%BC%A9%E6%80%A7">二、伸缩性</a></li>
<li><a href="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html#%E4%B8%89%E6%89%A9%E5%B1%95%E6%80%A7">三、扩展性</a></li>
<li><a href="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html#%E5%9B%9B%E5%8F%AF%E7%94%A8%E6%80%A7">四、可用性</a></li>
<li><a href="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html#%E4%BA%94%E5%AE%89%E5%85%A8%E6%80%A7">五、安全性</a></li>
<li><a href="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一性能" id="一性能">一、性能</a></h1>
<h2><a class="header" href="#性能指标" id="性能指标">性能指标</a></h2>
<h3><a class="header" href="#1-响应时间" id="1-响应时间">1. 响应时间</a></h3>
<p>指某个请求从发出到接收到响应消耗的时间。</p>
<p>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p>
<h3><a class="header" href="#2-吞吐量" id="2-吞吐量">2. 吞吐量</a></h3>
<p>指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p>
<h3><a class="header" href="#3-并发用户数" id="3-并发用户数">3. 并发用户数</a></h3>
<p>指系统能同时处理的并发用户请求数量。</p>
<p>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。</p>
<p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p>
<ul>
<li>多 CPU</li>
<li>IO 等待时间</li>
</ul>
<p>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。</p>
<p>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。</p>
<h2><a class="header" href="#性能优化" id="性能优化">性能优化</a></h2>
<h3><a class="header" href="#1-集群" id="1-集群">1. 集群</a></h3>
<p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p>
<h3><a class="header" href="#2-缓存" id="2-缓存">2. 缓存</a></h3>
<p>缓存能够提高性能的原因如下：</p>
<ul>
<li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快；</li>
<li>缓存数据可以位于靠近用户的地理位置上；</li>
<li>可以将计算结果进行缓存，从而避免重复计算。</li>
</ul>
<h3><a class="header" href="#3-异步" id="3-异步">3. 异步</a></h3>
<p>某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p>
<h1><a class="header" href="#二伸缩性" id="二伸缩性">二、伸缩性</a></h1>
<p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p>
<h2><a class="header" href="#伸缩性与性能" id="伸缩性与性能">伸缩性与性能</a></h2>
<p>如果系统存在性能问题，那么单个用户的请求总是很慢的；</p>
<p>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p>
<h2><a class="header" href="#实现伸缩性" id="实现伸缩性">实现伸缩性</a></h2>
<p>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。</p>
<p>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。</p>
<p>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p>
<h1><a class="header" href="#三扩展性" id="三扩展性">三、扩展性</a></h1>
<p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</p>
<p>实现可扩展主要有两种方式：</p>
<ul>
<li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li>
<li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li>
</ul>
<h1><a class="header" href="#四可用性" id="四可用性">四、可用性</a></h1>
<h2><a class="header" href="#冗余" id="冗余">冗余</a></h2>
<p>保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p>
<p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p>
<p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p>
<h2><a class="header" href="#监控" id="监控">监控</a></h2>
<p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p>
<h2><a class="header" href="#服务降级" id="服务降级">服务降级</a></h2>
<p>服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p>
<h1><a class="header" href="#五安全性" id="五安全性">五、安全性</a></h1>
<p>要求系统在应对各种攻击手段时能够有可靠的应对措施。</p>
<h1><a class="header" href="#参考资料" id="参考资料">参考资料</a></h1>
<ul>
<li>大型网站技术架构：核心原理与案例分析</li>
</ul>
<h1><a class="header" href="#工程设计" id="工程设计">工程设计</a></h1>
<ul>
<li>信息流推荐中会生成大量点击率文章，设计一个程序实现即时排序，返回热门文章。</li>
<li>词库每个词都有根据点击率来计算的热度，实现一个系统，支持前缀匹配并且返回Top10的热词。</li>
<li>设计一个支持千万级文章相似度去重的程序，来实现抄袭、洗稿文章的识别，时间ms级，准确率不低于95%。</li>
<li>小内存机器有两个文件A和B，分别存放5亿条均长64字节的url，试着找到A和B中所有重复的url。</li>
<li>尝试实现一个简单的音乐推荐系统，可以不涉及具体算法，主要说明工程部分即可。</li>
<li>设计一个黑词服务实现黄反、指令词、敏感词等过滤功能，耗时ms级。</li>
<li>实现关系服务，用户之间的粉丝、关注等。</li>
</ul>
<p>秒杀是非常常见的面试题，很多面试官上来就让面试者设计一个秒杀系统，面试者当然也是“身经百战”，很快可以给出熟背的“标准答案”。
但是，秒杀还是相对简单的热点库存扣减问题，因为扣减的库存量不大。更加典型的热点库存扣减问题是春节红包雨，同一个资金池数亿人抢红包。2020年春节，阿里巴巴针对春节红包预估150万QPS的峰值压力，设计了一个技术方案并申请专利。</p>
<p>存在问题：</p>
<ul>
<li>不同分桶之间，库存消耗不均，可能导致部分用户无法扣减库存，但其他用户可扣减库存，从而引发客诉。</li>
</ul>
<p>小量多次地分派库存，从而缓解分桶库存消耗不均问题。</p>
<h1><a class="header" href="#目录-2" id="目录-2">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">必要条件</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">处理方法</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5">鸵鸟策略</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D">死锁检测与死锁恢复</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#1-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B">1. 每种类型一个资源的死锁检测</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#2-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B">2. 每种类型多个资源的死锁检测</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#3-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D">3. 死锁恢复</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2">死锁预防</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#1-%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6">1. 破坏互斥条件</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#2-%E7%A0%B4%E5%9D%8F%E5%8D%A0%E6%9C%89%E5%92%8C%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6">2. 破坏占有和等待条件</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#3-%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6">3. 破坏不可抢占条件</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#4-%E7%A0%B4%E5%9D%8F%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85">4. 破坏环路等待</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D">死锁避免</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#1-%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81">1. 安全状态</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#2-%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">2. 单个资源的银行家算法</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html#3-%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">3. 多个资源的银行家算法</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#必要条件" id="必要条件">必要条件</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h1><a class="header" href="#处理方法" id="处理方法">处理方法</a></h1>
<p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h1><a class="header" href="#鸵鸟策略" id="鸵鸟策略">鸵鸟策略</a></h1>
<p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h1><a class="header" href="#死锁检测与死锁恢复" id="死锁检测与死锁恢复">死锁检测与死锁恢复</a></h1>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h2><a class="header" href="#1-每种类型一个资源的死锁检测" id="1-每种类型一个资源的死锁检测">1. 每种类型一个资源的死锁检测</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h2><a class="header" href="#2-每种类型多个资源的死锁检测" id="2-每种类型多个资源的死锁检测">2. 每种类型多个资源的死锁检测</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h2><a class="header" href="#3-死锁恢复" id="3-死锁恢复">3. 死锁恢复</a></h2>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h1><a class="header" href="#死锁预防" id="死锁预防">死锁预防</a></h1>
<p>在程序运行之前预防发生死锁。</p>
<h2><a class="header" href="#1-破坏互斥条件" id="1-破坏互斥条件">1. 破坏互斥条件</a></h2>
<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h2><a class="header" href="#2-破坏占有和等待条件" id="2-破坏占有和等待条件">2. 破坏占有和等待条件</a></h2>
<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h2><a class="header" href="#3-破坏不可抢占条件" id="3-破坏不可抢占条件">3. 破坏不可抢占条件</a></h2>
<h2><a class="header" href="#4-破坏环路等待" id="4-破坏环路等待">4. 破坏环路等待</a></h2>
<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h1><a class="header" href="#死锁避免" id="死锁避免">死锁避免</a></h1>
<p>在程序运行时避免发生死锁。</p>
<h2><a class="header" href="#1-安全状态" id="1-安全状态">1. 安全状态</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<h2><a class="header" href="#2-单个资源的银行家算法" id="2-单个资源的银行家算法">2. 单个资源的银行家算法</a></h2>
<p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h2><a class="header" href="#3-多个资源的银行家算法" id="3-多个资源的银行家算法">3. 多个资源的银行家算法</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<!-- GFM-TOC -->
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">基本特征</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#1-%E5%B9%B6%E5%8F%91">1. 并发</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#2-%E5%85%B1%E4%BA%AB">2. 共享</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#3-%E8%99%9A%E6%8B%9F">3. 虚拟</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#4-%E5%BC%82%E6%AD%A5">4. 异步</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">基本功能</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">1. 进程管理</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">2. 内存管理</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">3. 文件管理</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">4. 设备管理</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#%E5%A4%A7%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8">大内核和微内核</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#1-%E5%A4%A7%E5%86%85%E6%A0%B8">1. 大内核</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#2-%E5%BE%AE%E5%86%85%E6%A0%B8">2. 微内核</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB">中断分类</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#1-%E5%A4%96%E4%B8%AD%E6%96%AD">1. 外中断</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#2-%E5%BC%82%E5%B8%B8">2. 异常</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html#3-%E9%99%B7%E5%85%A5">3. 陷入</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#基本特征" id="基本特征">基本特征</a></h1>
<h2><a class="header" href="#1-并发" id="1-并发">1. 并发</a></h2>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h2><a class="header" href="#2-共享" id="2-共享">2. 共享</a></h2>
<p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h2><a class="header" href="#3-虚拟" id="3-虚拟">3. 虚拟</a></h2>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h2><a class="header" href="#4-异步" id="4-异步">4. 异步</a></h2>
<p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h1><a class="header" href="#基本功能" id="基本功能">基本功能</a></h1>
<h2><a class="header" href="#1-进程管理" id="1-进程管理">1. 进程管理</a></h2>
<p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h2><a class="header" href="#2-内存管理" id="2-内存管理">2. 内存管理</a></h2>
<p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h2><a class="header" href="#3-文件管理" id="3-文件管理">3. 文件管理</a></h2>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h2><a class="header" href="#4-设备管理" id="4-设备管理">4. 设备管理</a></h2>
<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h1><a class="header" href="#系统调用" id="系统调用">系统调用</a></h1>
<p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div><br>
<p>Linux 的系统调用主要有以下这些：</p>
<table><thead><tr><th align="center">Task</th><th>Commands</th></tr></thead><tbody>
<tr><td align="center">进程控制</td><td>fork(); exit(); wait();</td></tr>
<tr><td align="center">进程通信</td><td>pipe(); shmget(); mmap();</td></tr>
<tr><td align="center">文件操作</td><td>open(); read(); write();</td></tr>
<tr><td align="center">设备操作</td><td>ioctl(); read(); write();</td></tr>
<tr><td align="center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr>
<tr><td align="center">安全</td><td>chmod(); umask(); chown();</td></tr>
</tbody></table>
<h1><a class="header" href="#大内核和微内核" id="大内核和微内核">大内核和微内核</a></h1>
<h2><a class="header" href="#1-大内核" id="1-大内核">1. 大内核</a></h2>
<p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h2><a class="header" href="#2-微内核" id="2-微内核">2. 微内核</a></h2>
<p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>
<h1><a class="header" href="#中断分类" id="中断分类">中断分类</a></h1>
<h2><a class="header" href="#1-外中断" id="1-外中断">1. 外中断</a></h2>
<p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<h2><a class="header" href="#2-异常" id="2-异常">2. 异常</a></h2>
<p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h2><a class="header" href="#3-陷入" id="3-陷入">3. 陷入</a></h2>
<p>在用户程序中使用系统调用。</p>
<!-- GFM-TOC -->
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84">分页系统地址映射</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#1-%E6%9C%80%E4%BD%B3">1. 最佳</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#2-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8">2. 最近最久未使用</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#3-%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8">3. 最近未使用</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#4-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA">4. 先进先出</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#5-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95">5. 第二次机会算法</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6-%E6%97%B6%E9%92%9F">6. 时钟</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#%E5%88%86%E6%AE%B5">分段</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#%E6%AE%B5%E9%A1%B5%E5%BC%8F">段页式</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83">分页与分段的比较</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#虚拟内存" id="虚拟内存">虚拟内存</a></h1>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>
<h1><a class="header" href="#分页系统地址映射" id="分页系统地址映射">分页系统地址映射</a></h1>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br>
<h1><a class="header" href="#页面置换算法" id="页面置换算法">页面置换算法</a></h1>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<h2><a class="header" href="#1-最佳" id="1-最佳">1. 最佳</a></h2>
<blockquote>
<p>OPT, Optimal replacement algorithm</p>
</blockquote>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<pre><code class="language-html">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
</code></pre>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h2><a class="header" href="#2-最近最久未使用" id="2-最近最久未使用">2. 最近最久未使用</a></h2>
<blockquote>
<p>LRU, Least Recently Used</p>
</blockquote>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<pre><code class="language-html">4，7，0，7，1，0，1，2，1，2，6
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>
## 3. 最近未使用
<blockquote>
<p>NRU, Not Recently Used</p>
</blockquote>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h2><a class="header" href="#4-先进先出" id="4-先进先出">4. 先进先出</a></h2>
<blockquote>
<p>FIFO, First In First Out</p>
</blockquote>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>
<h2><a class="header" href="#5-第二次机会算法" id="5-第二次机会算法">5. 第二次机会算法</a></h2>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>
<h2><a class="header" href="#6-时钟" id="6-时钟">6. 时钟</a></h2>
<blockquote>
<p>Clock</p>
</blockquote>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>
<h1><a class="header" href="#分段" id="分段">分段</a></h1>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>
<h1><a class="header" href="#段页式" id="段页式">段页式</a></h1>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h1><a class="header" href="#分页与分段的比较" id="分页与分段的比较">分页与分段的比较</a></h1>
<ul>
<li>
<p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p>
</li>
<li>
<p>地址空间的维度：分页是一维地址空间，分段是二维的。</p>
</li>
<li>
<p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p>
</li>
<li>
<p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E4%B8%80%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5">一、常用操作以及概念</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%B1%82%E5%8A%A9">求助</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%85%B3%E6%9C%BA">关机</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#path">PATH</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#sudo">sudo</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">包管理工具</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8F%91%E8%A1%8C%E7%89%88">发行版</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#vim-%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%BC%8F">VIM 三个模式</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#gnu">GNU</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE">开源协议</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E4%BA%8C%E7%A3%81%E7%9B%98">二、磁盘</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%A3%81%E7%9B%98%E6%8E%A5%E5%8F%A3">磁盘接口</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%A3%81%E7%9B%98%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D">磁盘的文件名</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E4%B8%89%E5%88%86%E5%8C%BA">三、分区</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%88%86%E5%8C%BA%E8%A1%A8">分区表</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%BC%80%E6%9C%BA%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F">开机检测程序</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%9B%9B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">四、文件系统</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%88%86%E5%8C%BA%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分区与文件系统</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%BB%84%E6%88%90">组成</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">文件读取</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87">磁盘碎片</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#block">block</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#inode">inode</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%97%A5%E5%BF%97">日志</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%8C%82%E8%BD%BD">挂载</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE">目录配置</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E4%BA%94%E6%96%87%E4%BB%B6">五、文件</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">文件属性</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">文件与目录的基本操作</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90">修改权限</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90">默认权限</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90">目录的权限</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E9%93%BE%E6%8E%A5">链接</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">获取文件内容</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2">指令与文件搜索</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%85%AD%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85">六、压缩与打包</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%90%8D">压缩文件名</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4">压缩指令</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%89%93%E5%8C%85">打包</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E4%B8%83bash">七、Bash</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E7%89%B9%E6%80%A7">特性</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C">变量操作</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%8C%87%E4%BB%A4%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F">指令搜索顺序</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91">数据流重定向</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%85%AB%E7%AE%A1%E9%81%93%E6%8C%87%E4%BB%A4">八、管道指令</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%8F%90%E5%8F%96%E6%8C%87%E4%BB%A4">提取指令</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%8E%92%E5%BA%8F%E6%8C%87%E4%BB%A4">排序指令</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8F%8C%E5%90%91%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91">双向输出重定向</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4">字符转换指令</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%88%86%E5%8C%BA%E6%8C%87%E4%BB%A4">分区指令</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E4%B9%9D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">九、正则表达式</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#grep">grep</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#printf">printf</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#awk">awk</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8D%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">十、进程管理</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">进程状态</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#sigchld">SIGCHLD</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#wait">wait()</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#waitpid">waitpid()</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B">孤儿进程</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B">僵尸进程</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#前言" id="前言">前言</a></h1>
<p>为了便于理解，本文从常用操作和概念开始讲起。虽然已经尽量做到简化，但是涉及到的内容还是有点多。在面试中，Linux 知识点相对于网络和操作系统等知识点而言不是那么重要，只需要重点掌握一些原理和命令即可。为了方便大家准备面试，在此先将一些比较重要的知识点列出来：</p>
<ul>
<li>能简单使用 cat，grep，cut 等命令进行一些操作；</li>
<li>文件系统相关的原理，inode 和 block 等概念，数据恢复；</li>
<li>硬链接与软链接；</li>
<li>进程管理相关，僵尸进程与孤儿进程，SIGCHLD 。</li>
</ul>
<h1><a class="header" href="#一常用操作以及概念" id="一常用操作以及概念">一、常用操作以及概念</a></h1>
<h2><a class="header" href="#快捷键" id="快捷键">快捷键</a></h2>
<ul>
<li>Tab：命令和文件名补全；</li>
<li>Ctrl+C：中断正在运行的程序；</li>
<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>
</ul>
<h2><a class="header" href="#求助" id="求助">求助</a></h2>
<h3><a class="header" href="#1---help" id="1---help">1. --help</a></h3>
<p>指令的基本用法与选项介绍。</p>
<h3><a class="header" href="#2-man" id="2-man">2. man</a></h3>
<p>man 是 manual 的缩写，将指令的具体信息显示出来。</p>
<p>当执行 <code>man date</code> 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p>
<table><thead><tr><th align="center">代号</th><th>类型</th></tr></thead><tbody>
<tr><td align="center">1</td><td>用户在 shell 环境中可以操作的指令或者可执行文件</td></tr>
<tr><td align="center">5</td><td>配置文件</td></tr>
<tr><td align="center">8</td><td>系统管理员可以使用的管理指令</td></tr>
</tbody></table>
<h3><a class="header" href="#3-info" id="3-info">3. info</a></h3>
<p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。</p>
<h3><a class="header" href="#4-doc" id="4-doc">4. doc</a></h3>
<p>/usr/share/doc 存放着软件的一整套说明文件。</p>
<h2><a class="header" href="#关机" id="关机">关机</a></h2>
<h3><a class="header" href="#1-who" id="1-who">1. who</a></h3>
<p>在关机前需要先使用 who 命令查看有没有其它用户在线。</p>
<h3><a class="header" href="#2-sync" id="2-sync">2. sync</a></h3>
<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。</p>
<h3><a class="header" href="#3-shutdown" id="3-shutdown">3. shutdown</a></h3>
<pre><code class="language-html"># shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown
</code></pre>
<h2><a class="header" href="#path" id="path">PATH</a></h2>
<p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</p>
<pre><code class="language-html">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</code></pre>
<h2><a class="header" href="#sudo" id="sudo">sudo</a></h2>
<p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p>
<h2><a class="header" href="#包管理工具" id="包管理工具">包管理工具</a></h2>
<p>RPM 和 DPKG 为最常见的两类软件包管理工具：</p>
<ul>
<li>RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。</li>
<li>与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。</li>
</ul>
<h2><a class="header" href="#发行版" id="发行版">发行版</a></h2>
<p>Linux 发行版是 Linux 内核及各种应用软件的集成版本。</p>
<table><thead><tr><th align="center">基于的包管理工具</th><th align="center">商业发行版</th><th align="center">社区发行版</th></tr></thead><tbody>
<tr><td align="center">RPM</td><td align="center">Red Hat</td><td align="center">Fedora / CentOS</td></tr>
<tr><td align="center">DPKG</td><td align="center">Ubuntu</td><td align="center">Debian</td></tr>
</tbody></table>
<h2><a class="header" href="#vim-三个模式" id="vim-三个模式">VIM 三个模式</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209002818626.png"/> </div><br>
<ul>
<li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li>
<li>编辑模式（Insert mode）：按下 &quot;i&quot; 等按键之后进入，可以对文本进行编辑；</li>
<li>指令列模式（Bottom-line mode）：按下 &quot;:&quot; 按键之后进入，用于保存退出等操作。</li>
</ul>
<p>在指令列模式下，有以下命令用于离开或者保存文件。</p>
<table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody>
<tr><td align="center">:w</td><td align="center">写入磁盘</td></tr>
<tr><td align="center">:w!</td><td align="center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr>
<tr><td align="center">:q</td><td align="center">离开</td></tr>
<tr><td align="center">:q!</td><td align="center">强制离开不保存</td></tr>
<tr><td align="center">:wq</td><td align="center">写入磁盘后离开</td></tr>
<tr><td align="center">:wq!</td><td align="center">强制写入磁盘后离开</td></tr>
</tbody></table>
<h2><a class="header" href="#gnu" id="gnu">GNU</a></h2>
<p>GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License），包含了以下内容：</p>
<ul>
<li>以任何目的运行此程序的自由；</li>
<li>再复制的自由；</li>
<li>改进此程序，并公开发布改进的自由。</li>
</ul>
<h2><a class="header" href="#开源协议" id="开源协议">开源协议</a></h2>
<ul>
<li><a href="https://choosealicense.com/">Choose an open source license</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？</a></li>
</ul>
<h1><a class="header" href="#二磁盘" id="二磁盘">二、磁盘</a></h1>
<h2><a class="header" href="#磁盘接口" id="磁盘接口">磁盘接口</a></h2>
<h3><a class="header" href="#1-ide" id="1-ide">1. IDE</a></h3>
<p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/924914c0-660c-4e4a-bbc0-1df1146e7516.jpg" width="400"/> </div><br>
<h3><a class="header" href="#2-sata" id="2-sata">2. SATA</a></h3>
<p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB/s，而 SATA-III 标准可达到 600MB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9f2a16b-4843-44d1-9759-c745772e9bcf.jpg" width=""/> </div><br>
<h3><a class="header" href="#3-scsi" id="3-scsi">3. SCSI</a></h3>
<p>SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f0574025-c514-49f5-a591-6d6a71f271f7.jpg" width=""/> </div><br>
<h3><a class="header" href="#4-sas" id="4-sas">4. SAS</a></h3>
<p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也通过缩小连接线改善系统内部空间等。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6729baa0-57d7-4817-b3aa-518cbccf824c.jpg" width=""/> </div><br>
<h2><a class="header" href="#磁盘的文件名" id="磁盘的文件名">磁盘的文件名</a></h2>
<p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p>
<ul>
<li>IDE 磁盘：/dev/hd[a-d]</li>
<li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li>
</ul>
<p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p>
<h1><a class="header" href="#三分区" id="三分区">三、分区</a></h1>
<h2><a class="header" href="#分区表" id="分区表">分区表</a></h2>
<p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p>
<h3><a class="header" href="#1-mbr" id="1-mbr">1. MBR</a></h3>
<p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p>
<p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p>
<p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p>
<h3><a class="header" href="#2-gpt" id="2-gpt">2. GPT</a></h3>
<p>扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p>
<p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p>
<p>GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p>
<p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup> TB = 8 ZB。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/GUID_Partition_Table_Scheme.svg.png" width="400"/> </div><br>
<h2><a class="header" href="#开机检测程序" id="开机检测程序">开机检测程序</a></h2>
<h3><a class="header" href="#1-bios" id="1-bios">1. BIOS</a></h3>
<p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50831a6f-2777-46ea-a571-29f23c85cc21.jpg"/> </div><br>
<p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p>
<p>主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p>
<p>下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f900f266-a323-42b2-bc43-218fdb8811a8.jpg" width="600"/> </div><br>
<p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。</p>
<h3><a class="header" href="#2-uefi" id="2-uefi">2. UEFI</a></h3>
<p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以。</p>
<h1><a class="header" href="#四文件系统" id="四文件系统">四、文件系统</a></h1>
<h2><a class="header" href="#分区与文件系统" id="分区与文件系统">分区与文件系统</a></h2>
<p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p>
<h2><a class="header" href="#组成" id="组成">组成</a></h2>
<p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/BSD_disk.png" width="800"/> </div><br>
<h2><a class="header" href="#文件读取" id="文件读取">文件读取</a></h2>
<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png" width="500px"> </div><br>
<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png" width="500px"> </div><br>
<h2><a class="header" href="#磁盘碎片" id="磁盘碎片">磁盘碎片</a></h2>
<p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p>
<h2><a class="header" href="#block" id="block">block</a></h2>
<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<table><thead><tr><th align="center">大小</th><th align="center">1KB</th><th align="center">2KB</th><th align="center">4KB</th></tr></thead><tbody>
<tr><td align="center">最大单一文件</td><td align="center">16GB</td><td align="center">256GB</td><td align="center">2TB</td></tr>
<tr><td align="center">最大文件系统</td><td align="center">2TB</td><td align="center">8TB</td><td align="center">16TB</td></tr>
</tbody></table>
<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>
<h2><a class="header" href="#inode" id="inode">inode</a></h2>
<p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近读取时间 (atime)；</li>
<li>最近修改时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID...；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/inode_with_signatures.jpg" width="600"/> </div><br>
<h2><a class="header" href="#目录-3" id="目录-3">目录</a></h2>
<p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>
<p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p>
<h2><a class="header" href="#日志" id="日志">日志</a></h2>
<p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p>
<p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。</p>
<h2><a class="header" href="#挂载" id="挂载">挂载</a></h2>
<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p>
<h2><a class="header" href="#目录配置" id="目录配置">目录配置</a></h2>
<p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p>
<ul>
<li>/ (root, 根目录)</li>
<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li>
<li>/var (variable)：存放系统或程序运行过程中的数据文件。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/linux-filesystem.png" width=""/> </div><br>
<h1><a class="header" href="#五文件" id="五文件">五、文件</a></h1>
<h2><a class="header" href="#文件属性" id="文件属性">文件属性</a></h2>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间有以下三种：</p>
<ul>
<li>modification time (mtime)：文件的内容更新就会更新；</li>
<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>
<li>access time (atime)：读取文件时就会更新。</li>
</ul>
<h2><a class="header" href="#文件与目录的基本操作" id="文件与目录的基本操作">文件与目录的基本操作</a></h2>
<h3><a class="header" href="#1-ls" id="1-ls">1. ls</a></h3>
<p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p>
<pre><code class="language-html"># ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据
</code></pre>
<h3><a class="header" href="#2-cd" id="2-cd">2. cd</a></h3>
<p>更换当前目录。</p>
<pre><code>cd [相对路径或绝对路径]
</code></pre>
<h3><a class="header" href="#3-mkdir" id="3-mkdir">3. mkdir</a></h3>
<p>创建目录。</p>
<pre><code># mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录
</code></pre>
<h3><a class="header" href="#4-rmdir" id="4-rmdir">4. rmdir</a></h3>
<p>删除目录，目录必须为空。</p>
<pre><code class="language-html">rmdir [-p] 目录名称
-p ：递归删除目录
</code></pre>
<h3><a class="header" href="#5-touch" id="5-touch">5. touch</a></h3>
<p>更新文件时间或者建立新文件。</p>
<pre><code class="language-html"># touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
</code></pre>
<h3><a class="header" href="#6-cp" id="6-cp">6. cp</a></h3>
<p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p>
<pre><code class="language-html">cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
</code></pre>
<h3><a class="header" href="#7-rm" id="7-rm">7. rm</a></h3>
<p>删除文件。</p>
<pre><code class="language-html"># rm [-fir] 文件或目录
-r ：递归删除
</code></pre>
<h3><a class="header" href="#8-mv" id="8-mv">8. mv</a></h3>
<p>移动文件。</p>
<pre><code class="language-html"># mv [-fiu] source destination
# mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
</code></pre>
<h2><a class="header" href="#修改权限" id="修改权限">修改权限</a></h2>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<pre><code class="language-html"># chmod [-R] xyz dirname/filename
</code></pre>
<p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。</p>
<pre><code class="language-html"># chmod 754 .bashrc
</code></pre>
<p>也可以使用符号来设定权限。</p>
<pre><code class="language-html"># chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
</code></pre>
<p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<pre><code class="language-html"># chmod a+w .bashrc
</code></pre>
<h2><a class="header" href="#默认权限" id="默认权限">默认权限</a></h2>
<ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>
</ul>
<p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r--。</p>
<h2><a class="header" href="#目录的权限" id="目录的权限">目录的权限</a></h2>
<p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>
<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>
<h2><a class="header" href="#链接" id="链接">链接</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" width="450px"> </div><br>
<pre><code class="language-html"># ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
</code></pre>
<h3><a class="header" href="#1-实体链接" id="1-实体链接">1. 实体链接</a></h3>
<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>
<p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>
<p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p>
<pre><code class="language-html"># ln /etc/crontab .
# ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
</code></pre>
<h3><a class="header" href="#2-符号链接" id="2-符号链接">2. 符号链接</a></h3>
<p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>因为记录的是路径，所以可以为目录建立符号链接。</p>
<pre><code class="language-html"># ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab
</code></pre>
<h2><a class="header" href="#获取文件内容" id="获取文件内容">获取文件内容</a></h2>
<h3><a class="header" href="#1-cat" id="1-cat">1. cat</a></h3>
<p>取得文件内容。</p>
<pre><code class="language-html"># cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会
</code></pre>
<h3><a class="header" href="#2-tac" id="2-tac">2. tac</a></h3>
<p>是 cat 的反向操作，从最后一行开始打印。</p>
<h3><a class="header" href="#3-more" id="3-more">3. more</a></h3>
<p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>
<h3><a class="header" href="#4-less" id="4-less">4. less</a></h3>
<p>和 more 类似，但是多了一个向前翻页的功能。</p>
<h3><a class="header" href="#5-head" id="5-head">5. head</a></h3>
<p>取得文件前几行。</p>
<pre><code class="language-html"># head [-n number] filename
-n ：后面接数字，代表显示几行的意思
</code></pre>
<h3><a class="header" href="#6-tail" id="6-tail">6. tail</a></h3>
<p>是 head 的反向操作，只是取得是后几行。</p>
<h3><a class="header" href="#7-od" id="7-od">7. od</a></h3>
<p>以字符或者十六进制的形式显示二进制文件。</p>
<h2><a class="header" href="#指令与文件搜索" id="指令与文件搜索">指令与文件搜索</a></h2>
<h3><a class="header" href="#1-which" id="1-which">1. which</a></h3>
<p>指令搜索。</p>
<pre><code class="language-html"># which [-a] command
-a ：将所有指令列出，而不是只列第一个
</code></pre>
<h3><a class="header" href="#2-whereis" id="2-whereis">2. whereis</a></h3>
<p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p>
<pre><code class="language-html"># whereis [-bmsu] dirname/filename
</code></pre>
<h3><a class="header" href="#3-locate" id="3-locate">3. locate</a></h3>
<p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>
<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p>
<pre><code class="language-html"># locate [-ir] keyword
-r：正则表达式
</code></pre>
<h3><a class="header" href="#4-find" id="4-find">4. find</a></h3>
<p>文件搜索。可以使用文件的属性和权限进行搜索。</p>
<pre><code class="language-html"># find [basedir] [option]
example: find . -name &quot;shadow*&quot;
</code></pre>
<p><strong>① 与时间有关的选项</strong></p>
<pre><code class="language-html">-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件
</code></pre>
<p>+4、4 和 -4 的指示的时间范围如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/658fc5e7-79c0-4247-9445-d69bf194c539.png" width=""/> </div><br>
<p><strong>② 与文件拥有者和所属群组有关的选项</strong></p>
<pre><code class="language-html">-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件
</code></pre>
<p><strong>③ 与文件权限和名称有关的选项</strong></p>
<pre><code class="language-html">-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件
</code></pre>
<h1><a class="header" href="#六压缩与打包" id="六压缩与打包">六、压缩与打包</a></h1>
<h2><a class="header" href="#压缩文件名" id="压缩文件名">压缩文件名</a></h2>
<p>Linux 底下有很多压缩文件名，常见的如下：</p>
<table><thead><tr><th>扩展名</th><th>压缩程序</th></tr></thead><tbody>
<tr><td>*.Z</td><td>compress</td></tr>
<tr><td>*.zip</td><td>zip</td></tr>
<tr><td>*.gz</td><td>gzip</td></tr>
<tr><td>*.bz2</td><td>bzip2</td></tr>
<tr><td>*.xz</td><td>xz</td></tr>
<tr><td>*.tar</td><td>tar 程序打包的数据，没有经过压缩</td></tr>
<tr><td>*.tar.gz</td><td>tar 程序打包的文件，经过 gzip 的压缩</td></tr>
<tr><td>*.tar.bz2</td><td>tar 程序打包的文件，经过 bzip2 的压缩</td></tr>
<tr><td>*.tar.xz</td><td>tar 程序打包的文件，经过 xz 的压缩</td></tr>
</tbody></table>
<h2><a class="header" href="#压缩指令" id="压缩指令">压缩指令</a></h2>
<h3><a class="header" href="#1-gzip" id="1-gzip">1. gzip</a></h3>
<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p>有 9 个不同的压缩等级可以使用。</p>
<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p>
<pre><code class="language-html">$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
</code></pre>
<h3><a class="header" href="#2-bzip2" id="2-bzip2">2. bzip2</a></h3>
<p>提供比 gzip 更高的压缩比。</p>
<p>查看命令：bzcat、bzmore、bzless、bzgrep。</p>
<pre><code class="language-html">$ bzip2 [-cdkzv#] filename
-k ：保留源文件
</code></pre>
<h3><a class="header" href="#3-xz" id="3-xz">3. xz</a></h3>
<p>提供比 bzip2 更佳的压缩比。</p>
<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<p>查看命令：xzcat、xzmore、xzless、xzgrep。</p>
<pre><code class="language-html">$ xz [-dtlkc#] filename
</code></pre>
<h2><a class="header" href="#打包" id="打包">打包</a></h2>
<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p>
<pre><code class="language-html">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。
</code></pre>
<table><thead><tr><th align="center">使用方式</th><th>命令</th></tr></thead><tbody>
<tr><td align="center">打包压缩</td><td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td></tr>
<tr><td align="center">查 看</td><td>tar -jtv -f filename.tar.bz2</td></tr>
<tr><td align="center">解压缩</td><td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td></tr>
</tbody></table>
<h1><a class="header" href="#七bash" id="七bash">七、Bash</a></h1>
<p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p>
<h2><a class="header" href="#特性" id="特性">特性</a></h2>
<ul>
<li>命令历史：记录使用过的命令</li>
<li>命令与文件补全：快捷键：tab</li>
<li>命名别名：例如 ll 是 ls -al 的别名</li>
<li>shell scripts</li>
<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>
</ul>
<h2><a class="header" href="#变量操作" id="变量操作">变量操作</a></h2>
<p>对一个变量赋值直接使用 =。</p>
<p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>
<p>输出变量使用 echo 命令。</p>
<pre><code class="language-bash">$ x=abc
$ echo $x
$ echo ${x}
</code></pre>
<p>变量内容如果有空格，必须使用双引号或者单引号。</p>
<ul>
<li>双引号内的特殊字符可以保留原本特性，例如 x=&quot;lang is $LANG&quot;，则 x 的值为 lang is zh_TW.UTF-8；</li>
<li>单引号内的特殊字符就是特殊字符本身，例如 x='lang is $LANG'，则 x 的值为 lang is $LANG。</li>
</ul>
<p>可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>
<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>
<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p>
<pre><code class="language-html">$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型
</code></pre>
<p>使用 [ ] 来对数组进行索引操作：</p>
<pre><code class="language-bash">$ array[1]=a
$ array[2]=b
$ echo ${array[1]}
</code></pre>
<h2><a class="header" href="#指令搜索顺序" id="指令搜索顺序">指令搜索顺序</a></h2>
<ul>
<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内置的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>
</ul>
<h2><a class="header" href="#数据流重定向" id="数据流重定向">数据流重定向</a></h2>
<p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p>
<table><thead><tr><th align="center">1</th><th align="center">代码</th><th align="center">运算符</th></tr></thead><tbody>
<tr><td align="center">标准输入 (stdin)</td><td align="center">0</td><td align="center">&lt; 或 &lt;&lt;</td></tr>
<tr><td align="center">标准输出 (stdout)</td><td align="center">1</td><td align="center">&gt; 或 &gt;&gt;</td></tr>
<tr><td align="center">标准错误输出 (stderr)</td><td align="center">2</td><td align="center">2&gt; 或 2&gt;&gt;</td></tr>
</tbody></table>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p>
<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p>
<p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p>
<pre><code class="language-bash">$ find /home -name .bashrc &gt; list 2&gt;&amp;1
</code></pre>
<h1><a class="header" href="#八管道指令" id="八管道指令">八、管道指令</a></h1>
<p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p>
<p>在命令之间使用 | 分隔各个管道命令。</p>
<pre><code class="language-bash">$ ls -al /etc | less
</code></pre>
<h2><a class="header" href="#提取指令" id="提取指令">提取指令</a></h2>
<p>cut 对数据进行切分，取出想要的部分。</p>
<p>切分过程一行一行地进行。</p>
<pre><code class="language-html">$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
</code></pre>
<p>示例 1：last 显示登入者的信息，取出用户名。</p>
<pre><code class="language-html">$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d ' ' -f 1
</code></pre>
<p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p>
<pre><code class="language-html">$ export
declare -x HISTCONTROL=&quot;ignoredups&quot;
declare -x HISTSIZE=&quot;1000&quot;
declare -x HOME=&quot;/home/dmtsai&quot;
declare -x HOSTNAME=&quot;study.centos.vbird&quot;
.....(其他省略).....

$ export | cut -c 12-
</code></pre>
<h2><a class="header" href="#排序指令" id="排序指令">排序指令</a></h2>
<p><strong>sort</strong>   用于排序。</p>
<pre><code class="language-html">$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间
</code></pre>
<p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p>
<pre><code class="language-html">$ cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash
</code></pre>
<p><strong>uniq</strong>   可以将重复的数据只取一个。</p>
<pre><code class="language-html">$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数
</code></pre>
<p>示例：取得每个人的登录总次数</p>
<pre><code class="language-html">$ last | cut -d ' ' -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp
</code></pre>
<h2><a class="header" href="#双向输出重定向" id="双向输出重定向">双向输出重定向</a></h2>
<p>输出重定向会将输出内容重定向到文件中，而   <strong>tee</strong>   不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p>
<pre><code class="language-html">$ tee [-a] file
</code></pre>
<h2><a class="header" href="#字符转换指令" id="字符转换指令">字符转换指令</a></h2>
<p><strong>tr</strong>   用来删除一行中的字符，或者对字符进行替换。</p>
<pre><code class="language-html">$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串
</code></pre>
<p>示例，将 last 输出的信息所有小写转换为大写。</p>
<pre><code class="language-html">$ last | tr '[a-z]' '[A-Z]'
</code></pre>
<p><strong>col</strong>   将 tab 字符转为空格字符。</p>
<pre><code class="language-html">$ col [-xb]
-x ： 将 tab 键转换成对等的空格键
</code></pre>
<p><strong>expand</strong>   将 tab 转换一定数量的空格，默认是 8 个。</p>
<pre><code class="language-html">$ expand [-t] file
-t ：tab 转为空格的数量
</code></pre>
<p><strong>join</strong>   将有相同数据的那一行合并在一起。</p>
<pre><code class="language-html">$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段
</code></pre>
<p><strong>paste</strong>   直接将两行粘贴在一起。</p>
<pre><code class="language-html">$ paste [-d] file1 file2
-d ：分隔符，默认为 tab
</code></pre>
<h2><a class="header" href="#分区指令" id="分区指令">分区指令</a></h2>
<p><strong>split</strong>   将一个文件划分成多个文件。</p>
<pre><code class="language-html">$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称
</code></pre>
<h1><a class="header" href="#九正则表达式" id="九正则表达式">九、正则表达式</a></h1>
<h2><a class="header" href="#grep" id="grep">grep</a></h2>
<p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>
<pre><code class="language-html">$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
</code></pre>
<p>示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p>
<pre><code class="language-html">$ grep -n 'the' regular_express.txt
8:I can't finish the test.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with &quot;glad&quot;.
18:google is the best tools for search keyword
</code></pre>
<p>示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。</p>
<pre><code class="language-html">$ grep -n 'a\{2,5\}' regular_express.txt
</code></pre>
<h2><a class="header" href="#printf" id="printf">printf</a></h2>
<p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>
<pre><code class="language-html">$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
</code></pre>
<h2><a class="header" href="#awk" id="awk">awk</a></h2>
<p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>
<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p>
<p>示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。</p>
<pre><code class="language-html">$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
</code></pre>
<pre><code class="language-html">$ last -n 5 | awk '{print $1 &quot;\t&quot; $3}'
</code></pre>
<p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p>
<pre><code class="language-html">$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename
</code></pre>
<p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p>
<pre><code class="language-text">$ cat /etc/passwd | awk 'BEGIN {FS=&quot;:&quot;} $3 &lt; 10 {print $1 &quot;\t &quot; $3}'
root 0
bin 1
daemon 2
</code></pre>
<p>awk 变量：</p>
<table><thead><tr><th align="center">变量名称</th><th>代表意义</th></tr></thead><tbody>
<tr><td align="center">NF</td><td>每一行拥有的字段总数</td></tr>
<tr><td align="center">NR</td><td>目前所处理的是第几行数据</td></tr>
<tr><td align="center">FS</td><td>目前的分隔字符，默认是空格键</td></tr>
</tbody></table>
<p>示例：显示正在处理的行号以及每一行有多少字段</p>
<pre><code class="language-html">$ last -n 5 | awk '{print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF}'
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
</code></pre>
<h1><a class="header" href="#十进程管理" id="十进程管理">十、进程管理</a></h1>
<h2><a class="header" href="#查看进程" id="查看进程">查看进程</a></h2>
<h3><a class="header" href="#1-ps" id="1-ps">1. ps</a></h3>
<p>查看某个时间点的进程信息。</p>
<p>示例：查看自己的进程</p>
<pre><code class="language-sh"># ps -l
</code></pre>
<p>示例：查看系统所有进程</p>
<pre><code class="language-sh"># ps aux
</code></pre>
<p>示例：查看特定的进程</p>
<pre><code class="language-sh"># ps aux | grep threadx
</code></pre>
<h3><a class="header" href="#2-pstree" id="2-pstree">2. pstree</a></h3>
<p>查看进程树。</p>
<p>示例：查看所有进程树</p>
<pre><code class="language-sh"># pstree -A
</code></pre>
<h3><a class="header" href="#3-top" id="3-top">3. top</a></h3>
<p>实时显示进程信息。</p>
<p>示例：两秒钟刷新一次</p>
<pre><code class="language-sh"># top -d 2
</code></pre>
<h3><a class="header" href="#4-netstat" id="4-netstat">4. netstat</a></h3>
<p>查看占用端口的进程</p>
<p>示例：查看特定端口的进程</p>
<pre><code class="language-sh"># netstat -anp | grep port
</code></pre>
<h2><a class="header" href="#进程状态" id="进程状态">进程状态</a></h2>
<table><thead><tr><th align="center">状态</th><th>说明</th></tr></thead><tbody>
<tr><td align="center">R</td><td>running or runnable (on run queue)<br>正在执行或者可执行，此时进程位于执行队列中。</td></tr>
<tr><td align="center">D</td><td>uninterruptible sleep (usually I/O)<br>不可中断阻塞，通常为 IO 阻塞。</td></tr>
<tr><td align="center">S</td><td>interruptible sleep (waiting for an event to complete) <br> 可中断阻塞，此时进程正在等待某个事件完成。</td></tr>
<tr><td align="center">Z</td><td>zombie (terminated but not reaped by its parent)<br>僵死，进程已经终止但是尚未被其父进程获取信息。</td></tr>
<tr><td align="center">T</td><td>stopped (either by a job control signal or because it is being traced) <br> 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td></tr>
<tr><td align="center"><br></td><td></td></tr>
</tbody></table>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png" width="490px"/> </div><br>
<h2><a class="header" href="#sigchld" id="sigchld">SIGCHLD</a></h2>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号；</li>
<li>waitpid() 或者 wait() 调用会返回。</li>
</ul>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p>
<div align="center"> <!-- <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/flow.png" width=""/> --> </div><br>
<h2><a class="header" href="#wait" id="wait">wait()</a></h2>
<pre><code class="language-c">pid_t wait(int *status)
</code></pre>
<p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<h2><a class="header" href="#waitpid" id="waitpid">waitpid()</a></h2>
<pre><code class="language-c">pid_t waitpid(pid_t pid, int *status, int options)
</code></pre>
<p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h2><a class="header" href="#孤儿进程" id="孤儿进程">孤儿进程</a></h2>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h2><a class="header" href="#僵尸进程" id="僵尸进程">僵尸进程</a></h2>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h1><a class="header" href="#参考资料-1" id="参考资料-1">参考资料</a></h1>
<ul>
<li>鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009.</li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html">Linux 平台上的软件包管理</a></li>
<li><a href="http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></li>
<li><a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link">What is the difference between a symbolic link and a hard link?</a></li>
<li><a href="https://idea.popcount.org/2012-12-11-linux-process-states/">Linux process states</a></li>
<li><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GUID Partition Table</a></li>
<li><a href="https://blog.csdn.net/kevinhg/article/details/7001719">详解 wait 和 waitpid 函数</a></li>
<li><a href="https://blog.csdn.net/tianlesoftware/article/details/6009110">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</a></li>
<li><a href="http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/">Akai IB-301S SCSI Interface for S2800,S3000</a></li>
<li><a href="https://en.wikipedia.org/wiki/Parallel_ATA">Parallel ATA</a></li>
<li><a href="http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</a></li>
<li><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1">Decoding UCS Invicta – Part 1</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a></li>
<li><a href="http://www.differencebetween.info/difference-between-sas-and-sata">Difference between SAS and SATA</a></li>
<li><a href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a></li>
<li><a href="https://www.cs.rutgers.edu/%7Epxk/416/notes/13-fs-studies.html">File system design case studies</a></li>
<li><a href="https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml">Programming Project #4</a></li>
<li><a href="http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html">FILE SYSTEM DESIGN</a></li>
</ul>
<h1><a class="header" href="#一进程间的通信方式" id="一进程间的通信方式">一、进程间的通信方式</a></h1>
<h2><a class="header" href="#管道-pipe-" id="管道-pipe-">管道( pipe )：</a></h2>
<p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<h2><a class="header" href="#有名管道-namedpipe-" id="有名管道-namedpipe-">有名管道 (namedpipe) ：</a></h2>
<p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<h2><a class="header" href="#信号量semophore--" id="信号量semophore--">信号量(semophore ) ：</a></h2>
<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h2><a class="header" href="#消息队列-messagequeue--" id="消息队列-messagequeue--">消息队列( messagequeue ) ：</a></h2>
<p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h2><a class="header" href="#信号-sinal--" id="信号-sinal--">信号 (sinal ) ：</a></h2>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h2><a class="header" href="#共享内存shared-memory--" id="共享内存shared-memory--">共享内存(shared memory ) ：</a></h2>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<h2><a class="header" href="#套接字socket--" id="套接字socket--">套接字(socket ) ：</a></h2>
<p>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
<h1><a class="header" href="#二线程间的通信方式" id="二线程间的通信方式">二、线程间的通信方式</a></h1>
<h2><a class="header" href="#锁机制包括互斥锁条件变量读写锁" id="锁机制包括互斥锁条件变量读写锁">锁机制：包括互斥锁、条件变量、读写锁</a></h2>
<p>互斥锁提供了以排他方式防止数据结构被并发修改的方法。
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<h2><a class="header" href="#信号量机制semaphore包括无名线程信号量和命名线程信号量" id="信号量机制semaphore包括无名线程信号量和命名线程信号量">信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</a></h2>
<h2><a class="header" href="#信号机制signal类似进程间的信号处理" id="信号机制signal类似进程间的信号处理">信号机制(Signal)：类似进程间的信号处理</a></h2>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<!-- GFM-TOC -->
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html#%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F">编译系统</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5">静态链接</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">目标文件</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">动态链接</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#编译系统" id="编译系统">编译系统</a></h1>
<p>以下是一个 hello.c 程序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;hello, world\n&quot;);
    return 0;
}
</code></pre>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<pre><code class="language-bash">gcc -o hello hello.c
</code></pre>
<p>这个过程大致如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h1><a class="header" href="#静态链接" id="静态链接">静态链接</a></h1>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br>
<h1><a class="header" href="#目标文件" id="目标文件">目标文件</a></h1>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h1><a class="header" href="#动态链接" id="动态链接">动态链接</a></h1>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>
<!-- GFM-TOC -->
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84">磁盘结构</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">磁盘调度算法</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1">1. 先来先服务</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html#2-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88">2. 最短寻道时间优先</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html#3-%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95">3. 电梯算法</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#磁盘结构" id="磁盘结构">磁盘结构</a></h1>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div><br>
<h1><a class="header" href="#磁盘调度算法" id="磁盘调度算法">磁盘调度算法</a></h1>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h2><a class="header" href="#1-先来先服务" id="1-先来先服务">1. 先来先服务</a></h2>
<blockquote>
<p>FCFS, First Come First Served</p>
</blockquote>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h2><a class="header" href="#2-最短寻道时间优先" id="2-最短寻道时间优先">2. 最短寻道时间优先</a></h2>
<blockquote>
<p>SSTF, Shortest Seek Time First</p>
</blockquote>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div><br>
<h2><a class="header" href="#3-电梯算法" id="3-电梯算法">3. 电梯算法</a></h2>
<blockquote>
<p>SCAN</p>
</blockquote>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png"/> </div><br>
<!-- GFM-TOC -->
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">进程与线程</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#1-%E8%BF%9B%E7%A8%8B">1. 进程</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#2-%E7%BA%BF%E7%A8%8B">2. 线程</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#3-%E5%8C%BA%E5%88%AB">3. 区别</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2">进程状态的切换</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">进程调度算法</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1. 批处理系统</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F">2. 交互式系统</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#3-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F">3. 实时系统</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#1-%E4%B8%B4%E7%95%8C%E5%8C%BA">1. 临界区</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#2-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5">2. 同步与互斥</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#3-%E4%BF%A1%E5%8F%B7%E9%87%8F">3. 信号量</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#4-%E7%AE%A1%E7%A8%8B">4. 管程</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98">经典同步问题</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#1-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98">1. 哲学家进餐问题</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">2. 读者-写者问题</a></li>
</ul>
</li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a>
<ul>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#1-%E7%AE%A1%E9%81%93">1. 管道</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#2-fifo">2. FIFO</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">3. 消息队列</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#4-%E4%BF%A1%E5%8F%B7%E9%87%8F">4. 信号量</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#5-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8">5. 共享存储</a></li>
<li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#6-%E5%A5%97%E6%8E%A5%E5%AD%97">6. 套接字</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#进程与线程" id="进程与线程">进程与线程</a></h1>
<h2><a class="header" href="#1-进程" id="1-进程">1. 进程</a></h2>
<p>进程是资源分配的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/> </div><br>
<h2><a class="header" href="#2-线程" id="2-线程">2. 线程</a></h2>
<p>线程是独立调度的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/> </div><br>
<h2><a class="header" href="#3-区别" id="3-区别">3. 区别</a></h2>
<p>Ⅰ 拥有资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
<p>Ⅱ 调度</p>
<p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<p>Ⅲ 系统开销</p>
<p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
<p>Ⅳ 通信方面</p>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p>
<h1><a class="header" href="#进程状态的切换" id="进程状态的切换">进程状态的切换</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div><br>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h1><a class="header" href="#进程调度算法" id="进程调度算法">进程调度算法</a></h1>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h2><a class="header" href="#1-批处理系统" id="1-批处理系统">1. 批处理系统</a></h2>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h2><a class="header" href="#2-交互式系统" id="2-交互式系统">2. 交互式系统</a></h2>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div><br>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div><br>
<h2><a class="header" href="#3-实时系统" id="3-实时系统">3. 实时系统</a></h2>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h1><a class="header" href="#进程同步" id="进程同步">进程同步</a></h1>
<h2><a class="header" href="#1-临界区" id="1-临界区">1. 临界区</a></h2>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<pre><code class="language-html">// entry section
// critical section;
// exit section
</code></pre>
<h2><a class="header" href="#2-同步与互斥" id="2-同步与互斥">2. 同步与互斥</a></h2>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h2><a class="header" href="#3-信号量" id="3-信号量">3. 信号量</a></h2>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了   <strong>互斥量（Mutex）</strong>  ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<pre><code class="language-c">typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&amp;mutex);
    // 临界区
    up(&amp;mutex);
}

void P2() {
    down(&amp;mutex);
    // 临界区
    up(&amp;mutex);
}
</code></pre>
<p><font size=3>   <strong>使用信号量实现生产者-消费者问题</strong>   </font> </br></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<pre><code class="language-c">#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&amp;empty);
        down(&amp;mutex);
        insert_item(item);
        up(&amp;mutex);
        up(&amp;full);
    }
}

void consumer() {
    while(TRUE) {
        down(&amp;full);
        down(&amp;mutex);
        int item = remove_item();
        consume_item(item);
        up(&amp;mutex);
        up(&amp;empty);
    }
}
</code></pre>
<h2><a class="header" href="#4-管程" id="4-管程">4. 管程</a></h2>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<pre><code class="language-pascal">monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
</code></pre>
<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了   <strong>条件变量</strong>   以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><font size=3>  <strong>使用管程实现生产者-消费者问题</strong>  </font><br></p>
<pre><code class="language-pascal">// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
</code></pre>
<h1><a class="header" href="#经典同步问题" id="经典同步问题">经典同步问题</a></h1>
<p>生产者和消费者问题前面已经讨论过了。</p>
<h2><a class="header" href="#1-哲学家进餐问题" id="1-哲学家进餐问题">1. 哲学家进餐问题</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<pre><code class="language-c">#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
</code></pre>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<pre><code class="language-c">#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&amp;mutex);
    state[i] = HUNGRY;
    check(i);
    up(&amp;mutex);
    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&amp;mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&amp;mutex);
}

void eat(int i) {
    down(&amp;mutex);
    state[i] = EATING;
    up(&amp;mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&amp;s[i]);
    }
}
</code></pre>
<h2><a class="header" href="#2-读者-写者问题" id="2-读者-写者问题">2. 读者-写者问题</a></h2>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code class="language-c">typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&amp;count_mutex);
        count++;
        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&amp;count_mutex);
        read();
        down(&amp;count_mutex);
        count--;
        if(count == 0) up(&amp;data_mutex);
        up(&amp;count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&amp;data_mutex);
        write();
        up(&amp;data_mutex);
    }
}
</code></pre>
<p>以下内容由 <a href="https://github.com/yugandharbandi">@Bandi Yugandhar</a> 提供。</p>
<p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p>
<pre><code class="language-c">int readcount, writecount;                   //(initial value = 0)
semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)

//READER
void reader() {
&lt;ENTRY Section&gt;
 down(&amp;readLock);                 //  reader is trying to enter
 down(&amp;rmutex);                  //   lock to increase readcount
  readcount++;                 
  if (readcount == 1)          
   down(&amp;resource);              //if you are the first reader then lock  the resource
 up(&amp;rmutex);                  //release  for other readers
 up(&amp;readLock);                 //Done with trying to access the resource

&lt;CRITICAL Section&gt;
//reading is performed

&lt;EXIT Section&gt;
 down(&amp;rmutex);                  //reserve exit section - avoids race condition with readers
 readcount--;                       //indicate you're leaving
  if (readcount == 0)          //checks if you are last reader leaving
   up(&amp;resource);              //if last, you must release the locked resource
 up(&amp;rmutex);                  //release exit section for other readers
}

//WRITER
void writer() {
  &lt;ENTRY Section&gt;
  down(&amp;wmutex);                  //reserve entry section for writers - avoids race conditions
  writecount++;                //report yourself as a writer entering
  if (writecount == 1)         //checks if you're first writer
   down(&amp;readLock);               //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
  up(&amp;wmutex);                  //release entry section

&lt;CRITICAL Section&gt;
 down(&amp;resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
  //writing is performed
 up(&amp;resource);                //release file

&lt;EXIT Section&gt;
  down(&amp;wmutex);                  //reserve exit section
  writecount--;                //indicate you're leaving
  if (writecount == 0)         //checks if you're the last writer
   up(&amp;readLock);               //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
  up(&amp;wmutex);                  //release exit section
}
</code></pre>
<p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p>
<p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p>
<pre><code class="language-source-c">int readCount;                  // init to 0; number of readers currently accessing resource

// all semaphores initialised to 1
Semaphore resourceAccess;       // controls access (read/write) to the resource
Semaphore readCountAccess;      // for syncing changes to shared variable readCount
Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

void writer()
{ 
    down(&amp;serviceQueue);           // wait in line to be servicexs
    // &lt;ENTER&gt;
    down(&amp;resourceAccess);         // request exclusive access to resource
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced

    // &lt;WRITE&gt;
    writeResource();            // writing is performed
    // &lt;/WRITE&gt;

    // &lt;EXIT&gt;
    up(&amp;resourceAccess);         // release resource access for next reader/writer
    // &lt;/EXIT&gt;
}

void reader()
{ 
    down(&amp;serviceQueue);           // wait in line to be serviced
    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;ENTER&gt;
    if (readCount == 0)         // if there are no readers already reading:
        down(&amp;resourceAccess);     // request resource access for readers (writers blocked)
    readCount++;                // update count of active readers
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced
    up(&amp;readCountAccess);        // release access to readCount

    // &lt;READ&gt;
    readResource();             // reading is performed
    // &lt;/READ&gt;

    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;EXIT&gt;
    readCount--;                // update count of active readers
    if (readCount == 0)         // if there are no readers left:
        up(&amp;resourceAccess);     // release resource access for all
    // &lt;/EXIT&gt;
    up(&amp;readCountAccess);        // release access to readCount
}

</code></pre>
<h1><a class="header" href="#进程通信" id="进程通信">进程通信</a></h1>
<p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h2><a class="header" href="#1-管道" id="1-管道">1. 管道</a></h2>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
int pipe(int fd[2]);
</code></pre>
<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在父子进程或者兄弟进程中使用。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>
<h2><a class="header" href="#2-fifo" id="2-fifo">2. FIFO</a></h2>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<pre><code class="language-c">#include &lt;sys/stat.h&gt;
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
</code></pre>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div><br>
<h2><a class="header" href="#3-消息队列" id="3-消息队列">3. 消息队列</a></h2>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h2><a class="header" href="#4-信号量" id="4-信号量">4. 信号量</a></h2>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h2><a class="header" href="#5-共享存储" id="5-共享存储">5. 共享存储</a></h2>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h2><a class="header" href="#6-套接字" id="6-套接字">6. 套接字</a></h2>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h1><a class="header" href="#目录-4" id="目录-4">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#目录-5" id="目录-5">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="redis/Redis.html#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li>
<li><a href="redis/Redis.html#%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">二、数据类型</a>
<ul>
<li><a href="redis/Redis.html#string">STRING</a></li>
<li><a href="redis/Redis.html#list">LIST</a></li>
<li><a href="redis/Redis.html#set">SET</a></li>
<li><a href="redis/Redis.html#hash">HASH</a></li>
<li><a href="redis/Redis.html#zset">ZSET</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E4%B8%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">三、数据结构</a>
<ul>
<li><a href="redis/Redis.html#%E5%AD%97%E5%85%B8">字典</a></li>
<li><a href="redis/Redis.html#%E8%B7%B3%E8%B7%83%E8%A1%A8">跳跃表</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">四、使用场景</a>
<ul>
<li><a href="redis/Redis.html#%E8%AE%A1%E6%95%B0%E5%99%A8">计数器</a></li>
<li><a href="redis/Redis.html#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="redis/Redis.html#%E6%9F%A5%E6%89%BE%E8%A1%A8">查找表</a></li>
<li><a href="redis/Redis.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li>
<li><a href="redis/Redis.html#%E4%BC%9A%E8%AF%9D%E7%BC%93%E5%AD%98">会话缓存</a></li>
<li><a href="redis/Redis.html#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0">分布式锁实现</a></li>
<li><a href="redis/Redis.html#%E5%85%B6%E5%AE%83">其它</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E4%BA%94redis-%E4%B8%8E-memcached">五、Redis 与 Memcached</a>
<ul>
<li><a href="redis/Redis.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="redis/Redis.html#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">数据持久化</a></li>
<li><a href="redis/Redis.html#%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a></li>
<li><a href="redis/Redis.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">内存管理机制</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E5%85%AD%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4">六、键的过期时间</a></li>
<li><a href="redis/Redis.html#%E4%B8%83%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">七、数据淘汰策略</a></li>
<li><a href="redis/Redis.html#%E5%85%AB%E6%8C%81%E4%B9%85%E5%8C%96">八、持久化</a>
<ul>
<li><a href="redis/Redis.html#rdb-%E6%8C%81%E4%B9%85%E5%8C%96">RDB 持久化</a></li>
<li><a href="redis/Redis.html#aof-%E6%8C%81%E4%B9%85%E5%8C%96">AOF 持久化</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E4%B9%9D%E4%BA%8B%E5%8A%A1">九、事务</a></li>
<li><a href="redis/Redis.html#%E5%8D%81%E4%BA%8B%E4%BB%B6">十、事件</a>
<ul>
<li><a href="redis/Redis.html#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6">文件事件</a></li>
<li><a href="redis/Redis.html#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6">时间事件</a></li>
<li><a href="redis/Redis.html#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C">事件的调度与执行</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E5%8D%81%E4%B8%80%E5%A4%8D%E5%88%B6">十一、复制</a>
<ul>
<li><a href="redis/Redis.html#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B">连接过程</a></li>
<li><a href="redis/Redis.html#%E4%B8%BB%E4%BB%8E%E9%93%BE">主从链</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E5%8D%81%E4%BA%8Csentinel">十二、Sentinel</a></li>
<li><a href="redis/Redis.html#%E5%8D%81%E4%B8%89%E5%88%86%E7%89%87">十三、分片</a></li>
<li><a href="redis/Redis.html#%E5%8D%81%E5%9B%9B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BA%E5%9D%9B%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90">十四、一个简单的论坛系统分析</a>
<ul>
<li><a href="redis/Redis.html#%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF">文章信息</a></li>
<li><a href="redis/Redis.html#%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD">点赞功能</a></li>
<li><a href="redis/Redis.html#%E5%AF%B9%E6%96%87%E7%AB%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">对文章进行排序</a></li>
</ul>
</li>
<li><a href="redis/Redis.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一概述" id="一概述">一、概述</a></h1>
<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p>
<h1><a class="header" href="#二数据类型" id="二数据类型">二、数据类型</a></h1>
<table><thead><tr><th align="center">数据类型</th><th align="center">可以存储的值</th><th align="center">操作</th></tr></thead><tbody>
<tr><td align="center">STRING</td><td align="center">字符串、整数或者浮点数</td><td align="center">对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td></tr>
<tr><td align="center">LIST</td><td align="center">列表</td><td align="center">从两端压入或者弹出元素 </br> 对单个或者多个元素进行修剪，</br> 只保留一个范围内的元素</td></tr>
<tr><td align="center">SET</td><td align="center">无序集合</td><td align="center">添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td></tr>
<tr><td align="center">HASH</td><td align="center">包含键值对的无序散列表</td><td align="center">添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td></tr>
<tr><td align="center">ZSET</td><td align="center">有序集合</td><td align="center">添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td></tr>
</tbody></table>
<blockquote>
<p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p>
</blockquote>
<h2><a class="header" href="#string" id="string">STRING</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" width="400"/> </div><br>
<pre><code class="language-html">&gt; set hello world
OK
&gt; get hello
&quot;world&quot;
&gt; del hello
(integer) 1
&gt; get hello
(nil)
</code></pre>
<h2><a class="header" href="#list" id="list">LIST</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" width="400"/> </div><br>
<pre><code class="language-html">&gt; rpush list-key item
(integer) 1
&gt; rpush list-key item2
(integer) 2
&gt; rpush list-key item
(integer) 3

&gt; lrange list-key 0 -1
1) &quot;item&quot;
2) &quot;item2&quot;
3) &quot;item&quot;

&gt; lindex list-key 1
&quot;item2&quot;

&gt; lpop list-key
&quot;item&quot;

&gt; lrange list-key 0 -1
1) &quot;item2&quot;
2) &quot;item&quot;
</code></pre>
<h2><a class="header" href="#set" id="set">SET</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" width="400"/> </div><br>
<pre><code class="language-html">&gt; sadd set-key item
(integer) 1
&gt; sadd set-key item2
(integer) 1
&gt; sadd set-key item3
(integer) 1
&gt; sadd set-key item
(integer) 0

&gt; smembers set-key
1) &quot;item&quot;
2) &quot;item2&quot;
3) &quot;item3&quot;

&gt; sismember set-key item4
(integer) 0
&gt; sismember set-key item
(integer) 1

&gt; srem set-key item2
(integer) 1
&gt; srem set-key item2
(integer) 0

&gt; smembers set-key
1) &quot;item&quot;
2) &quot;item3&quot;
</code></pre>
<h2><a class="header" href="#hash" id="hash">HASH</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" width="400"/> </div><br>
<pre><code class="language-html">&gt; hset hash-key sub-key1 value1
(integer) 1
&gt; hset hash-key sub-key2 value2
(integer) 1
&gt; hset hash-key sub-key1 value1
(integer) 0

&gt; hgetall hash-key
1) &quot;sub-key1&quot;
2) &quot;value1&quot;
3) &quot;sub-key2&quot;
4) &quot;value2&quot;

&gt; hdel hash-key sub-key2
(integer) 1
&gt; hdel hash-key sub-key2
(integer) 0

&gt; hget hash-key sub-key1
&quot;value1&quot;

&gt; hgetall hash-key
1) &quot;sub-key1&quot;
2) &quot;value1&quot;
</code></pre>
<h2><a class="header" href="#zset" id="zset">ZSET</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" width="400"/> </div><br>
<pre><code class="language-html">&gt; zadd zset-key 728 member1
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 0

&gt; zrange zset-key 0 -1 withscores
1) &quot;member1&quot;
2) &quot;728&quot;
3) &quot;member0&quot;
4) &quot;982&quot;

&gt; zrangebyscore zset-key 0 800 withscores
1) &quot;member1&quot;
2) &quot;728&quot;

&gt; zrem zset-key member1
(integer) 1
&gt; zrem zset-key member1
(integer) 0

&gt; zrange zset-key 0 -1 withscores
1) &quot;member0&quot;
2) &quot;982&quot;
</code></pre>
<h1><a class="header" href="#三数据结构" id="三数据结构">三、数据结构</a></h1>
<h2><a class="header" href="#字典" id="字典">字典</a></h2>
<p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p>
<pre><code class="language-c">/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
</code></pre>
<pre><code class="language-c">typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
</code></pre>
<p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p>
<pre><code class="language-c">typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;
</code></pre>
<p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p>
<p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p>
<p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p>
<p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
<pre><code class="language-c">/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d)) return 0;

    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d-&gt;ht[0].size &gt; (unsigned long) d-&gt;rehashidx);
        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {
            d-&gt;rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d-&gt;ht[0].table[d-&gt;rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while (de) {
            uint64_t h;

            nextde = de-&gt;next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;
            de-&gt;next = d-&gt;ht[1].table[h];
            d-&gt;ht[1].table[h] = de;
            d-&gt;ht[0].used--;
            d-&gt;ht[1].used++;
            de = nextde;
        }
        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;
        d-&gt;rehashidx++;
    }

    /* Check if we already rehashed the whole table... */
    if (d-&gt;ht[0].used == 0) {
        zfree(d-&gt;ht[0].table);
        d-&gt;ht[0] = d-&gt;ht[1];
        _dictReset(&amp;d-&gt;ht[1]);
        d-&gt;rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}
</code></pre>
<h2><a class="header" href="#跳跃表" id="跳跃表">跳跃表</a></h2>
<p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" width="600px"/> </div><br>
<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png" width="600px"/> </div><br>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
<h1><a class="header" href="#四使用场景" id="四使用场景">四、使用场景</a></h1>
<h2><a class="header" href="#计数器" id="计数器">计数器</a></h2>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。</p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<h2><a class="header" href="#缓存" id="缓存">缓存</a></h2>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<h2><a class="header" href="#查找表" id="查找表">查找表</a></h2>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。</p>
<p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<h2><a class="header" href="#消息队列" id="消息队列">消息队列</a></h2>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<h2><a class="header" href="#会话缓存" id="会话缓存">会话缓存</a></h2>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<h2><a class="header" href="#分布式锁实现" id="分布式锁实现">分布式锁实现</a></h2>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h2><a class="header" href="#其它" id="其它">其它</a></h2>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h1><a class="header" href="#五redis-与-memcached" id="五redis-与-memcached">五、Redis 与 Memcached</a></h1>
<p>两者都是非关系型内存键值数据库，主要有以下不同：</p>
<h2><a class="header" href="#数据类型" id="数据类型">数据类型</a></h2>
<p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p>
<h2><a class="header" href="#数据持久化" id="数据持久化">数据持久化</a></h2>
<p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p>
<h2><a class="header" href="#分布式" id="分布式">分布式</a></h2>
<p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p>
<p>Redis Cluster 实现了分布式的支持。</p>
<h2><a class="header" href="#内存管理机制" id="内存管理机制">内存管理机制</a></h2>
<ul>
<li>
<p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p>
</li>
<li>
<p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p>
</li>
</ul>
<h1><a class="header" href="#六键的过期时间" id="六键的过期时间">六、键的过期时间</a></h1>
<p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p>
<h1><a class="header" href="#七数据淘汰策略" id="七数据淘汰策略">七、数据淘汰策略</a></h1>
<p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis 具体有 6 种淘汰策略：</p>
<table><thead><tr><th align="center">策略</th><th align="center">描述</th></tr></thead><tbody>
<tr><td align="center">volatile-lru</td><td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr>
<tr><td align="center">volatile-ttl</td><td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr>
<tr><td align="center">volatile-random</td><td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr>
<tr><td align="center">allkeys-lru</td><td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr>
<tr><td align="center">allkeys-random</td><td align="center">从所有数据集中任意选择数据进行淘汰</td></tr>
<tr><td align="center">noeviction</td><td align="center">禁止驱逐数据</td></tr>
</tbody></table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h1><a class="header" href="#八持久化" id="八持久化">八、持久化</a></h1>
<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h2><a class="header" href="#rdb-持久化" id="rdb-持久化">RDB 持久化</a></h2>
<p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量很大，保存快照的时间会很长。</p>
<h2><a class="header" href="#aof-持久化" id="aof-持久化">AOF 持久化</a></h2>
<p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table><thead><tr><th align="center">选项</th><th align="center">同步频率</th></tr></thead><tbody>
<tr><td align="center">always</td><td align="center">每个写命令都同步</td></tr>
<tr><td align="center">everysec</td><td align="center">每秒同步一次</td></tr>
<tr><td align="center">no</td><td align="center">让操作系统来决定何时同步</td></tr>
</tbody></table>
<ul>
<li>always 选项会严重减低服务器的性能；</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h1><a class="header" href="#九事务" id="九事务">九、事务</a></h1>
<p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p>
<h1><a class="header" href="#十事件" id="十事件">十、事件</a></h1>
<p>Redis 服务器是一个事件驱动程序。</p>
<h2><a class="header" href="#文件事件" id="文件事件">文件事件</a></h2>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" width=""/> </div><br>
<h2><a class="header" href="#时间事件" id="时间事件">时间事件</a></h2>
<p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p>
<p>时间事件又分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p>
<h2><a class="header" href="#事件的调度与执行" id="事件的调度与执行">事件的调度与执行</a></h2>
<p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<pre><code class="language-python">def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0
    if remaind_ms &lt; 0:
        remaind_ms = 0
    # 根据 remaind_ms 的值，创建 timeval
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    procesFileEvents()
    # 处理所有已到达的时间事件
    processTimeEvents()
</code></pre>
<p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<pre><code class="language-python">def main():
    # 初始化服务器
    init_server()
    # 一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    # 服务器关闭，执行清理操作
    clean_server()
</code></pre>
<p>从事件处理的角度来看，服务器运行流程如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" width="350"/> </div><br>
<h1><a class="header" href="#十一复制" id="十一复制">十一、复制</a></h1>
<p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h2><a class="header" href="#连接过程" id="连接过程">连接过程</a></h2>
<ol>
<li>
<p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p>
</li>
<li>
<p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p>
</li>
<li>
<p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p>
</li>
</ol>
<h2><a class="header" href="#主从链" id="主从链">主从链</a></h2>
<p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" width="600"/> </div><br>
<h1><a class="header" href="#十二sentinel" id="十二sentinel">十二、Sentinel</a></h1>
<p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h1><a class="header" href="#十三分片" id="十三分片">十三、分片</a></h1>
<p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
<h1><a class="header" href="#十四一个简单的论坛系统分析" id="十四一个简单的论坛系统分析">十四、一个简单的论坛系统分析</a></h1>
<p>该论坛系统功能如下：</p>
<ul>
<li>可以发布文章；</li>
<li>可以对文章进行点赞；</li>
<li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li>
</ul>
<h2><a class="header" href="#文章信息" id="文章信息">文章信息</a></h2>
<p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p>
<p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png" width="400"/> </div><br>
<h2><a class="header" href="#点赞功能" id="点赞功能">点赞功能</a></h2>
<p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p>
<p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png" width="400"/> </div><br>
<h2><a class="header" href="#对文章进行排序" id="对文章进行排序">对文章进行排序</a></h2>
<p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" width="800"/> </div><br>
<h1><a class="header" href="#参考资料-2" id="参考资料-2">参考资料</a></h1>
<ul>
<li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li>
<li><a href="http://redisbook.com/index.html">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li>
<li><a href="https://redislabs.com/ebook/foreword/">REDIS IN ACTION</a></li>
<li><a href="http://ticki.github.io/blog/skip-lists-done-right/">Skip Lists: Done Right</a></li>
<li><a href="http://www.cnblogs.com/loveincode/p/7411911.html">论述 Redis 和 Memcached 的差异</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/redis-guide">Redis 3.0 中文版- 分片</a></li>
<li><a href="http://www.scienjus.com/redis-use-case/">Redis 应用场景</a></li>
<li><a href="https://redis.io/topics/lru-cache">Using Redis as an LRU cache</a></li>
</ul>
<p>1.什么是redis?
Redis 是一个基于内存的高性能key-value数据库。</p>
<p>2.Reids的特点
Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p>
<p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p>
<p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<p>3.使用redis有哪些好处？
1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p>
<p>2.支持丰富数据类型，支持string，list，set，sorted set，hash</p>
<p>1）String</p>
<p>常用命令：set/get/decr/incr/mget等；</p>
<p>应用场景：String是最常用的一种数据类型，普通的key/value存储都可以归为此类；</p>
<p>实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p>
<p>2）Hash</p>
<p>常用命令：hget/hset/hgetall等</p>
<p>应用场景：我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日；</p>
<p>实现方式：Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。</p>
<p>当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p>
<p>3）List</p>
<p>常用命令：lpush/rpush/lpop/rpop/lrange等；</p>
<p>应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现；</p>
<p>实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
<p>4）Set</p>
<p>常用命令：sadd/spop/smembers/sunion等；</p>
<p>应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的；</p>
<p>实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p>
<p>5）Sorted Set</p>
<p>常用命令：zadd/zrange/zrem/zcard等；</p>
<p>应用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p>
<p>实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<p>3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>4.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<p>4.redis相比memcached有哪些优势？
memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
redis的速度比memcached快很多 (3) redis可以持久化其数据
5.Memcache与Redis的区别都有哪些？
存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。
数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。
使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
6.redis适用于的场景?
Redis最适合所有数据in-momory的场景，如：</p>
<p>1.会话缓存（Session Cache）</p>
<p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。</p>
<p>2.全页缓存（FPC）</p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p>
<p>3.队列</p>
<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p>
<p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p>
<p>4.排行榜/计数器</p>
<p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p>
<p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p>
<p>ZRANGE user_scores 0 10 WITHSCORES</p>
<p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p>
<p>5.发布/订阅</p>
<p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。推荐阅读：Redis 的 8 大应用场景。</p>
<p>7、redis的缓存失效策略和主键失效机制
作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略.</p>
<p>在Redis当中，有生存期的key被称为volatile。在创建缓存时，要为给定的key设置生存期，当key过期的时候（生存期为0），它可能会被删除。</p>
<p>1、影响生存时间的一些操作</p>
<p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改key对应的value和使用另外相同的key和value来覆盖以后，当前数据的生存时间不同。</p>
<p>比如说，对一个 key 执行INCR命令，对一个列表进行LPUSH命令，或者对一个哈希表执行HSET命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用RENAME对一个 key 进行改名，那么改名后的 key的生存时间和改名前一样。</p>
<p>RENAME命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。使用PERSIST命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个persistent key 。</p>
<p>2、如何更新生存时间</p>
<p>可以对一个已经带有生存时间的 key 执行EXPIRE命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在1ms之内，主键失效的时间复杂度是O（1），EXPIRE和TTL命令搭配使用，TTL可以查看key的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。</p>
<p>最大缓存配置，在 redis 中，允许用户设置最大使用内存大小</p>
<p>server.maxmemory默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。</p>
<p>redis 提供 6种数据淘汰策略：</p>
<p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据
注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。</p>
<p>使用策略规则：</p>
<p>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru
如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random
三种数据淘汰策略：</p>
<p>ttl和random比较容易理解，实现也会比较简单。主要是Lru最近最少使用淘汰策略，设计上会对key 按失效时间排序，然后取最先失效的key进行淘汰</p>
<p>8.为什么redis需要把所有数据放到内存中?
Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p>
<p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<p>9.Redis是单进程单线程的
redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p>
<p>10.redis的并发竞争问题如何解决?
Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p>
<p>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。
服务器角度，利用setnx实现锁。
注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。
11、redis常见性能问题和解决方案：
1.Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p>
<p>2.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p>
<p>3.Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p>
<p>4.Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</p>
<p>12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?
和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：</p>
<p>1). 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p>
<p>2). 和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p>
<p>3). 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为&quot;BEGIN TRANSACTION&quot;语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。</p>
<p>4). 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</p>
<p>5). 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p>
<p>13.WATCH命令和基于CAS的乐观锁?
在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。</p>
<p>其伪码如下：</p>
<p>val = GET mykey<br />
val = val + 1<br />
SET mykey $val</p>
<p>以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景--竞态争用(race condition)。</p>
<p>比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：</p>
<p>WATCH mykey<br />
val = GET mykey<br />
val = val + 1<br />
MULTI<br />
SET mykey $val<br />
EXEC</p>
<p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p>
<p>14.使用过Redis分布式锁么，它是什么回事？
先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<p>这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p>
<p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
<p>15.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<p>16.使用过Redis做异步队列么，你是怎么用的？
一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<p>如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<p>如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
<p>如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<p>如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p>
<p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<p>17.如果有大量的key需要设置同一时间过期，一般需要注意什么？
如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<p>18.Redis如何做持久化的？
bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<p>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p>
<p>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<p>19.Pipeline有什么好处，为什么要用pipeline？
可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p>
<p>20.Redis的同步机制了解么？
Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<p>21.是否使用过Redis集群，集群的原理是什么？
Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p>
<p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>
<ol start="22">
<li>Redis为啥速度快？</li>
</ol>
<ul>
<li>1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</li>
<li>2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li>
<li>3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>4）使用多路 I/O 复用模型，非阻塞 IO；</li>
<li>5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ul>
<h1><a class="header" href="#redis过期键的删除策略" id="redis过期键的删除策略">Redis过期键的删除策略</a></h1>
<p>定时删除：节省空间费时间
惰性删除：用到的时候再判断是否过期，节省时间，浪费空间
定期过期：把前两者综合起来，定期检查删除</p>
<h1><a class="header" href="#redis为啥采用单线程" id="redis为啥采用单线程">Redis为啥采用单线程</a></h1>
<p>因为Redis是IO密集型应用，CPU不是瓶颈。</p>
<h1><a class="header" href="#缓存的三个问题" id="缓存的三个问题">缓存的三个问题</a></h1>
<p>这三个概念意思十分接近，都是说缓存失效、给数据库造成巨大的压力。</p>
<ul>
<li>缓存雪崩：缓存无效，数据库被涌入的大量请求击垮。</li>
<li>缓存穿透：大量访问不存在的key，数据库中也不存在，导致给数据库压力很大。</li>
<li>缓存击穿：热点数据集中失效，同时去数据库中加载数据。</li>
</ul>
<h1><a class="header" href="#redis的io复用原理" id="redis的io复用原理">redis的IO复用原理</a></h1>
<p>select、poll、epoll。
nginx、redis都使用了epoll，这是linux平台上的高效IO库。</p>
<h1><a class="header" href="#目录-6" id="目录-6">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#攻击技术md" id="攻击技术md">攻击技术.md</a></h1>
<h1><a class="header" href="#目录-7" id="目录-7">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#分库分表md" id="分库分表md">分库分表.md</a></h1>
<h1><a class="header" href="#mysqlmd" id="mysqlmd">MySQL.md</a></h1>
<h1><a class="header" href="#sqlmd" id="sqlmd">SQL.md</a></h1>
<h1><a class="header" href="#缓存md" id="缓存md">缓存.md</a></h1>
<h1><a class="header" href="#数据库系统原理md" id="数据库系统原理md">数据库系统原理.md</a></h1>
<h1><a class="header" href="#目录-8" id="目录-8">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="java/JavaIO.html#%E4%B8%80%E6%A6%82%E8%A7%88">一、概览</a></li>
<li><a href="java/JavaIO.html#%E4%BA%8C%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C">二、磁盘操作</a></li>
<li><a href="java/JavaIO.html#%E4%B8%89%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C">三、字节操作</a>
<ul>
<li><a href="java/JavaIO.html#%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6">实现文件复制</a></li>
<li><a href="java/JavaIO.html#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">装饰者模式</a></li>
</ul>
</li>
<li><a href="java/JavaIO.html#%E5%9B%9B%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C">四、字符操作</a>
<ul>
<li><a href="java/JavaIO.html#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81">编码与解码</a></li>
<li><a href="java/JavaIO.html#string-%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">String 的编码方式</a></li>
<li><a href="java/JavaIO.html#reader-%E4%B8%8E-writer">Reader 与 Writer</a></li>
<li><a href="java/JavaIO.html#%E5%AE%9E%E7%8E%B0%E9%80%90%E8%A1%8C%E8%BE%93%E5%87%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9">实现逐行输出文本文件的内容</a></li>
</ul>
</li>
<li><a href="java/JavaIO.html#%E4%BA%94%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">五、对象操作</a>
<ul>
<li><a href="java/JavaIO.html#%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a></li>
<li><a href="java/JavaIO.html#serializable">Serializable</a></li>
<li><a href="java/JavaIO.html#transient">transient</a></li>
</ul>
</li>
<li><a href="java/JavaIO.html#%E5%85%AD%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C">六、网络操作</a>
<ul>
<li><a href="java/JavaIO.html#inetaddress">InetAddress</a></li>
<li><a href="java/JavaIO.html#url">URL</a></li>
<li><a href="java/JavaIO.html#sockets">Sockets</a></li>
<li><a href="java/JavaIO.html#datagram">Datagram</a></li>
</ul>
</li>
<li><a href="java/JavaIO.html#%E4%B8%83nio">七、NIO</a>
<ul>
<li><a href="java/JavaIO.html#%E6%B5%81%E4%B8%8E%E5%9D%97">流与块</a></li>
<li><a href="java/JavaIO.html#%E9%80%9A%E9%81%93%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA">通道与缓冲区</a></li>
<li><a href="java/JavaIO.html#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F">缓冲区状态变量</a></li>
<li><a href="java/JavaIO.html#%E6%96%87%E4%BB%B6-nio-%E5%AE%9E%E4%BE%8B">文件 NIO 实例</a></li>
<li><a href="java/JavaIO.html#%E9%80%89%E6%8B%A9%E5%99%A8">选择器</a></li>
<li><a href="java/JavaIO.html#%E5%A5%97%E6%8E%A5%E5%AD%97-nio-%E5%AE%9E%E4%BE%8B">套接字 NIO 实例</a></li>
<li><a href="java/JavaIO.html#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6">内存映射文件</a></li>
<li><a href="java/JavaIO.html#%E5%AF%B9%E6%AF%94">对比</a></li>
</ul>
</li>
<li><a href="java/JavaIO.html#%E5%85%AB%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">八、参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一概览" id="一概览">一、概览</a></h1>
<p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h1><a class="header" href="#二磁盘操作" id="二磁盘操作">二、磁盘操作</a></h1>
<p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地列出一个目录下所有文件：</p>
<pre><code class="language-java">public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if (dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for (File file : dir.listFiles()) {
        listAllFiles(file);
    }
}
</code></pre>
<p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h1><a class="header" href="#三字节操作" id="三字节操作">三、字节操作</a></h1>
<h2><a class="header" href="#实现文件复制" id="实现文件复制">实现文件复制</a></h2>
<pre><code class="language-java">public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
</code></pre>
<h2><a class="header" href="#装饰者模式" id="装饰者模式">装饰者模式</a></h2>
<p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9709694b-db05-4cce-8d2f-1c8b09f4d921.png" width="650px"> </div><br>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<pre><code class="language-java">FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
</code></pre>
<p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h1><a class="header" href="#四字符操作" id="四字符操作">四、字符操作</a></h1>
<h2><a class="header" href="#编码与解码" id="编码与解码">编码与解码</a></h2>
<p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h2><a class="header" href="#string-的编码方式" id="string-的编码方式">String 的编码方式</a></h2>
<p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<pre><code class="language-java">String str1 = &quot;中文&quot;;
byte[] bytes = str1.getBytes(&quot;UTF-8&quot;);
String str2 = new String(bytes, &quot;UTF-8&quot;);
System.out.println(str2);
</code></pre>
<p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p>
<pre><code class="language-java">byte[] bytes = str1.getBytes();
</code></pre>
<h2><a class="header" href="#reader-与-writer" id="reader-与-writer">Reader 与 Writer</a></h2>
<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h2><a class="header" href="#实现逐行输出文本文件的内容" id="实现逐行输出文本文件的内容">实现逐行输出文本文件的内容</a></h2>
<pre><code class="language-java">public static void readFileContent(String filePath) throws IOException {

    FileReader fileReader = new FileReader(filePath);
    BufferedReader bufferedReader = new BufferedReader(fileReader);

    String line;
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }

    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
    // 因此只要一个 close() 调用即可
    bufferedReader.close();
}
</code></pre>
<h1><a class="header" href="#五对象操作" id="五对象操作">五、对象操作</a></h1>
<h2><a class="header" href="#序列化" id="序列化">序列化</a></h2>
<p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h2><a class="header" href="#serializable" id="serializable">Serializable</a></h2>
<p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<pre><code class="language-java">public static void main(String[] args) throws IOException, ClassNotFoundException {

    A a1 = new A(123, &quot;abc&quot;);
    String objectFile = &quot;file/a1&quot;;

    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));
    objectOutputStream.writeObject(a1);
    objectOutputStream.close();

    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));
    A a2 = (A) objectInputStream.readObject();
    objectInputStream.close();
    System.out.println(a2);
}

private static class A implements Serializable {

    private int x;
    private String y;

    A(int x, String y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return &quot;x = &quot; + x + &quot;  &quot; + &quot;y = &quot; + y;
    }
}
</code></pre>
<h2><a class="header" href="#transient" id="transient">transient</a></h2>
<p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<pre><code class="language-java">private transient Object[] elementData;
</code></pre>
<h1><a class="header" href="#六网络操作" id="六网络操作">六、网络操作</a></h1>
<p>Java 中的网络支持：</p>
<ul>
<li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li>
<li>URL：统一资源定位符；</li>
<li>Sockets：使用 TCP 协议实现网络通信；</li>
<li>Datagram：使用 UDP 协议实现网络通信。</li>
</ul>
<h2><a class="header" href="#inetaddress" id="inetaddress">InetAddress</a></h2>
<p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<pre><code class="language-java">InetAddress.getByName(String host);
InetAddress.getByAddress(byte[] address);
</code></pre>
<h2><a class="header" href="#url" id="url">URL</a></h2>
<p>可以直接从 URL 中读取字节流数据。</p>
<pre><code class="language-java">public static void main(String[] args) throws IOException {

    URL url = new URL(&quot;http://www.baidu.com&quot;);

    /* 字节流 */
    InputStream is = url.openStream();

    /* 字符流 */
    InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;);

    /* 提供缓存功能 */
    BufferedReader br = new BufferedReader(isr);

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

    br.close();
}
</code></pre>
<h2><a class="header" href="#sockets" id="sockets">Sockets</a></h2>
<ul>
<li>ServerSocket：服务器端类</li>
<li>Socket：客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png" width="550px"> </div><br>
<h2><a class="header" href="#datagram" id="datagram">Datagram</a></h2>
<ul>
<li>DatagramSocket：通信类</li>
<li>DatagramPacket：数据包类</li>
</ul>
<h1><a class="header" href="#七nio" id="七nio">七、NIO</a></h1>
<p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<h2><a class="header" href="#流与块" id="流与块">流与块</a></h2>
<p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2><a class="header" href="#通道与缓冲区" id="通道与缓冲区">通道与缓冲区</a></h2>
<h3><a class="header" href="#1-通道" id="1-通道">1. 通道</a></h3>
<p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3><a class="header" href="#2-缓冲区" id="2-缓冲区">2. 缓冲区</a></h3>
<p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h2><a class="header" href="#缓冲区状态变量" id="缓冲区状态变量">缓冲区状态变量</a></h2>
<ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png"/> </div><br>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png"/> </div><br>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/952e06bd-5a65-4cab-82e4-dd1536462f38.png"/> </div><br>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png"/> </div><br>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67bf5487-c45d-49b6-b9c0-a058d8c68902.png"/> </div><br>
<h2><a class="header" href="#文件-nio-实例" id="文件-nio-实例">文件 NIO 实例</a></h2>
<p>以下展示了使用 NIO 快速复制文件的实例：</p>
<pre><code class="language-java">public static void fastCopy(String src, String dist) throws IOException {

    /* 获得源文件的输入字节流 */
    FileInputStream fin = new FileInputStream(src);

    /* 获取输入字节流的文件通道 */
    FileChannel fcin = fin.getChannel();

    /* 获取目标文件的输出字节流 */
    FileOutputStream fout = new FileOutputStream(dist);

    /* 获取输出字节流的文件通道 */
    FileChannel fcout = fout.getChannel();

    /* 为缓冲区分配 1024 个字节 */
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

    while (true) {

        /* 从输入通道中读取数据到缓冲区中 */
        int r = fcin.read(buffer);

        /* read() 返回 -1 表示 EOF */
        if (r == -1) {
            break;
        }

        /* 切换读写 */
        buffer.flip();

        /* 把缓冲区的内容写入输出文件中 */
        fcout.write(buffer);

        /* 清空缓冲区 */
        buffer.clear();
    }
}
</code></pre>
<h2><a class="header" href="#选择器" id="选择器">选择器</a></h2>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/093f9e57-429c-413a-83ee-c689ba596cef.png" width="350px"> </div><br>
<h3><a class="header" href="#1-创建选择器" id="1-创建选择器">1. 创建选择器</a></h3>
<pre><code class="language-java">Selector selector = Selector.open();
</code></pre>
<h3><a class="header" href="#2-将通道注册到选择器上" id="2-将通道注册到选择器上">2. 将通道注册到选择器上</a></h3>
<pre><code class="language-java">ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
</code></pre>
<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<pre><code class="language-java">public static final int OP_READ = 1 &lt;&lt; 0;
public static final int OP_WRITE = 1 &lt;&lt; 2;
public static final int OP_CONNECT = 1 &lt;&lt; 3;
public static final int OP_ACCEPT = 1 &lt;&lt; 4;
</code></pre>
<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<pre><code class="language-java">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>
<h3><a class="header" href="#3-监听事件" id="3-监听事件">3. 监听事件</a></h3>
<pre><code class="language-java">int num = selector.select();
</code></pre>
<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3><a class="header" href="#4-获取到达的事件" id="4-获取到达的事件">4. 获取到达的事件</a></h3>
<pre><code class="language-java">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key.isAcceptable()) {
        // ...
    } else if (key.isReadable()) {
        // ...
    }
    keyIterator.remove();
}
</code></pre>
<h3><a class="header" href="#5-事件循环" id="5-事件循环">5. 事件循环</a></h3>
<p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<pre><code class="language-java">while (true) {
    int num = selector.select();
    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
            // ...
        } else if (key.isReadable()) {
            // ...
        }
        keyIterator.remove();
    }
}
</code></pre>
<h2><a class="header" href="#套接字-nio-实例" id="套接字-nio-实例">套接字 NIO 实例</a></h2>
<pre><code class="language-java">public class NIOServer {

    public static void main(String[] args) throws IOException {

        Selector selector = Selector.open();

        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        ssChannel.configureBlocking(false);
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);

        ServerSocket serverSocket = ssChannel.socket();
        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 8888);
        serverSocket.bind(address);

        while (true) {

            selector.select();
            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();

            while (keyIterator.hasNext()) {

                SelectionKey key = keyIterator.next();

                if (key.isAcceptable()) {

                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();

                    // 服务器会为每个新连接创建一个 SocketChannel
                    SocketChannel sChannel = ssChannel1.accept();
                    sChannel.configureBlocking(false);

                    // 这个新连接主要用于从客户端读取数据
                    sChannel.register(selector, SelectionKey.OP_READ);

                } else if (key.isReadable()) {

                    SocketChannel sChannel = (SocketChannel) key.channel();
                    System.out.println(readDataFromSocketChannel(sChannel));
                    sChannel.close();
                }

                keyIterator.remove();
            }
        }
    }

    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder data = new StringBuilder();

        while (true) {

            buffer.clear();
            int n = sChannel.read(buffer);
            if (n == -1) {
                break;
            }
            buffer.flip();
            int limit = buffer.limit();
            char[] dst = new char[limit];
            for (int i = 0; i &lt; limit; i++) {
                dst[i] = (char) buffer.get(i);
            }
            data.append(dst);
            buffer.clear();
        }
        return data.toString();
    }
}
</code></pre>
<pre><code class="language-java">public class NIOClient {

    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
        OutputStream out = socket.getOutputStream();
        String s = &quot;hello world&quot;;
        out.write(s.getBytes());
        out.close();
    }
}
</code></pre>
<h2><a class="header" href="#内存映射文件" id="内存映射文件">内存映射文件</a></h2>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<pre><code class="language-java">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
</code></pre>
<h2><a class="header" href="#对比" id="对比">对比</a></h2>
<p>NIO 与普通 I/O 的区别主要有以下两点：</p>
<ul>
<li>NIO 是非阻塞的；</li>
<li>NIO 面向块，I/O 面向流。</li>
</ul>
<h1><a class="header" href="#八参考资料" id="八参考资料">八、参考资料</a></h1>
<ul>
<li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">IBM: NIO 入门</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></li>
<li><a href="https://tech.meituan.com/nio.html">Java NIO 浅析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html">IBM: 深入分析 Java I/O 的工作机制</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html">IBM: 深入分析 Java 中的中文编码问题</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html">IBM: Java 序列化的高级认识</a></li>
<li><a href="http://blog.csdn.net/shimiso/article/details/24990499">NIO 与传统 IO 的区别</a></li>
<li><a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document">Decorator Design Pattern</a></li>
<li><a href="http://labojava.blogspot.com/2012/12/socket-multicast.html">Socket Multicast</a></li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%B8%80%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B">一、使用线程</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%AE%9E%E7%8E%B0-runnable-%E6%8E%A5%E5%8F%A3">实现 Runnable 接口</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%AE%9E%E7%8E%B0-callable-%E6%8E%A5%E5%8F%A3">实现 Callable 接口</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E7%BB%A7%E6%89%BF-thread-%E7%B1%BB">继承 Thread 类</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-vs-%E7%BB%A7%E6%89%BF-thread">实现接口 VS 继承 Thread</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%BA%8C%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6">二、基础线程机制</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#executor">Executor</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#daemon">Daemon</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#sleep">sleep()</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#yield">yield()</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%B8%89%E4%B8%AD%E6%96%AD">三、中断</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#interruptedexception">InterruptedException</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#interrupted">interrupted()</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C">Executor 的中断操作</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%9B%9B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">四、互斥同步</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#synchronized">synchronized</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#reentrantlock">ReentrantLock</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E6%AF%94%E8%BE%83">比较</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9">使用选择</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%BA%94%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C">五、线程之间的协作</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#join">join()</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#wait-notify-notifyall">wait() notify() notifyAll()</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#await-signal-signalall">await() signal() signalAll()</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%85%AD%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81">六、线程状态</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E6%96%B0%E5%BB%BAnew">新建（NEW）</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%8F%AF%E8%BF%90%E8%A1%8Crunable">可运行（RUNABLE）</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E9%98%BB%E5%A1%9Eblocked">阻塞（BLOCKED）</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85waiting">无限期等待（WAITING）</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85timed_waiting">限期等待（TIMED_WAITING）</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E6%AD%BB%E4%BA%A1terminated">死亡（TERMINATED）</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%B8%83juc---aqs">七、J.U.C - AQS</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#countdownlatch">CountDownLatch</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#cyclicbarrier">CyclicBarrier</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#semaphore">Semaphore</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%85%ABjuc---%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6">八、J.U.C - 其它组件</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#futuretask">FutureTask</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#blockingqueue">BlockingQueue</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#forkjoin">ForkJoin</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%B9%9D%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B">九、线程不安全示例</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%8D%81java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">十、Java 内存模型</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98">主内存与工作内存</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C">内存间交互操作</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">内存模型三大特性</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99">先行发生原则</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%8D%81%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">十一、线程安全</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%B8%8D%E5%8F%AF%E5%8F%98">不可变</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">互斥同步</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5">非阻塞同步</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88">无同步方案</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%8D%81%E4%BA%8C%E9%94%81%E4%BC%98%E5%8C%96">十二、锁优化</a>
<ul>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E8%87%AA%E6%97%8B%E9%94%81">自旋锁</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E9%94%81%E6%B6%88%E9%99%A4">锁消除</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E9%94%81%E7%B2%97%E5%8C%96">锁粗化</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a></li>
</ul>
</li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%8D%81%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E8%89%AF%E5%A5%BD%E7%9A%84%E5%AE%9E%E8%B7%B5">十三、多线程开发良好的实践</a></li>
<li><a href="java/Java%E5%B9%B6%E5%8F%91.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一使用线程" id="一使用线程">一、使用线程</a></h1>
<p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p>
<h2><a class="header" href="#实现-runnable-接口" id="实现-runnable-接口">实现 Runnable 接口</a></h2>
<p>需要实现接口中的 run() 方法。</p>
<pre><code class="language-java">public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
</code></pre>
<p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p>
<pre><code class="language-java">public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
</code></pre>
<h2><a class="header" href="#实现-callable-接口" id="实现-callable-接口">实现 Callable 接口</a></h2>
<p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<pre><code class="language-java">public class MyCallable implements Callable&lt;Integer&gt; {
    public Integer call() {
        return 123;
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
</code></pre>
<h2><a class="header" href="#继承-thread-类" id="继承-thread-类">继承 Thread 类</a></h2>
<p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<pre><code class="language-java">public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
</code></pre>
<h2><a class="header" href="#实现接口-vs-继承-thread" id="实现接口-vs-继承-thread">实现接口 VS 继承 Thread</a></h2>
<p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h1><a class="header" href="#二基础线程机制" id="二基础线程机制">二、基础线程机制</a></h1>
<h2><a class="header" href="#executor" id="executor">Executor</a></h2>
<p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
</code></pre>
<h2><a class="header" href="#daemon" id="daemon">Daemon</a></h2>
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p>
<pre><code class="language-java">public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
</code></pre>
<h2><a class="header" href="#sleep" id="sleep">sleep()</a></h2>
<p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<pre><code class="language-java">public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2><a class="header" href="#yield" id="yield">yield()</a></h2>
<p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<pre><code class="language-java">public void run() {
    Thread.yield();
}
</code></pre>
<h1><a class="header" href="#三中断" id="三中断">三、中断</a></h1>
<p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h2><a class="header" href="#interruptedexception" id="interruptedexception">InterruptedException</a></h2>
<p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<pre><code class="language-java">public class InterruptExample {

    private static class MyThread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
                System.out.println(&quot;Thread run&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread thread1 = new MyThread1();
    thread1.start();
    thread1.interrupt();
    System.out.println(&quot;Main run&quot;);
}
</code></pre>
<pre><code class="language-html">Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptExample.lambda$main$0(InterruptExample.java:5)
    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
</code></pre>
<h2><a class="header" href="#interrupted" id="interrupted">interrupted()</a></h2>
<p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<pre><code class="language-java">public class InterruptExample {

    private static class MyThread2 extends Thread {
        @Override
        public void run() {
            while (!interrupted()) {
                // ..
            }
            System.out.println(&quot;Thread end&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread thread2 = new MyThread2();
    thread2.start();
    thread2.interrupt();
}
</code></pre>
<pre><code class="language-html">Thread end
</code></pre>
<h2><a class="header" href="#executor-的中断操作" id="executor-的中断操作">Executor 的中断操作</a></h2>
<p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<pre><code class="language-java">public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; {
        try {
            Thread.sleep(2000);
            System.out.println(&quot;Thread run&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    executorService.shutdownNow();
    System.out.println(&quot;Main run&quot;);
}
</code></pre>
<pre><code class="language-html">Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
</code></pre>
<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<pre><code class="language-java">Future&lt;?&gt; future = executorService.submit(() -&gt; {
    // ..
});
future.cancel(true);
</code></pre>
<h1><a class="header" href="#四互斥同步" id="四互斥同步">四、互斥同步</a></h1>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h2><a class="header" href="#synchronized" id="synchronized">synchronized</a></h2>
<p><strong>1. 同步一个代码块</strong></p>
<pre><code class="language-java">public void func() {
    synchronized (this) {
        // ...
    }
}
</code></pre>
<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<pre><code class="language-java">public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e1.func1());
}
</code></pre>
<pre><code class="language-html">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<pre><code class="language-java">public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e2.func1());
}
</code></pre>
<pre><code class="language-html">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
</code></pre>
<p><strong>2. 同步一个方法</strong></p>
<pre><code class="language-java">public synchronized void func () {
    // ...
}
</code></pre>
<p>它和同步代码块一样，作用于同一个对象。</p>
<p><strong>3. 同步一个类</strong></p>
<pre><code class="language-java">public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
</code></pre>
<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<pre><code class="language-java">public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func2());
    executorService.execute(() -&gt; e2.func2());
}
</code></pre>
<pre><code class="language-html">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre>
<p><strong>4. 同步一个静态方法</strong></p>
<pre><code class="language-java">public synchronized static void fun() {
    // ...
}
</code></pre>
<p>作用于整个类。</p>
<h2><a class="header" href="#reentrantlock" id="reentrantlock">ReentrantLock</a></h2>
<p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<pre><code class="language-java">public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; lockExample.func());
    executorService.execute(() -&gt; lockExample.func());
}
</code></pre>
<pre><code class="language-html">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre>
<h2><a class="header" href="#比较" id="比较">比较</a></h2>
<p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<h2><a class="header" href="#使用选择" id="使用选择">使用选择</a></h2>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h1><a class="header" href="#五线程之间的协作" id="五线程之间的协作">五、线程之间的协作</a></h1>
<p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h2><a class="header" href="#join" id="join">join()</a></h2>
<p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<pre><code class="language-java">public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println(&quot;A&quot;);
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;B&quot;);
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}
</code></pre>
<pre><code>A
B
</code></pre>
<h2><a class="header" href="#wait-notify-notifyall" id="wait-notify-notifyall">wait() notify() notifyAll()</a></h2>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<pre><code class="language-java">public class WaitNotifyExample {

    public synchronized void before() {
        System.out.println(&quot;before&quot;);
        notifyAll();
    }

    public synchronized void after() {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;after&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
}
</code></pre>
<pre><code class="language-html">before
after
</code></pre>
<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
<h2><a class="header" href="#await-signal-signalall" id="await-signal-signalall">await() signal() signalAll()</a></h2>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<pre><code class="language-java">public class AwaitSignalExample {

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println(&quot;before&quot;);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println(&quot;after&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
}
</code></pre>
<pre><code class="language-html">before
after
</code></pre>
<h1><a class="header" href="#六线程状态" id="六线程状态">六、线程状态</a></h1>
<p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p>
<h2><a class="header" href="#新建new" id="新建new">新建（NEW）</a></h2>
<p>创建后尚未启动。</p>
<h2><a class="header" href="#可运行runable" id="可运行runable">可运行（RUNABLE）</a></h2>
<p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p>
<h2><a class="header" href="#阻塞blocked" id="阻塞blocked">阻塞（BLOCKED）</a></h2>
<p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</p>
<h2><a class="header" href="#无限期等待waiting" id="无限期等待waiting">无限期等待（WAITING）</a></h2>
<p>等待其它线程显式地唤醒。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用  Object.wait() 等方法进入。</p>
<table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody>
<tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr>
<tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr>
<tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr>
</tbody></table>
<h2><a class="header" href="#限期等待timed_waiting" id="限期等待timed_waiting">限期等待（TIMED_WAITING）</a></h2>
<p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody>
<tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr>
<tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr>
<tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr>
<tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr>
<tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr>
</tbody></table>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<h2><a class="header" href="#死亡terminated" id="死亡terminated">死亡（TERMINATED）</a></h2>
<p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html">Java SE 9 Enum Thread.State</a></p>
<h1><a class="header" href="#七juc---aqs" id="七juc---aqs">七、J.U.C - AQS</a></h1>
<p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h2><a class="header" href="#countdownlatch" id="countdownlatch">CountDownLatch</a></h2>
<p>用来控制一个或者多个线程等待多个线程。</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br>
<pre><code class="language-java">public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) {
            executorService.execute(() -&gt; {
                System.out.print(&quot;run..&quot;);
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println(&quot;end&quot;);
        executorService.shutdown();
    }
}
</code></pre>
<pre><code class="language-html">run..run..run..run..run..run..run..run..run..run..end
</code></pre>
<h2><a class="header" href="#cyclicbarrier" id="cyclicbarrier">CyclicBarrier</a></h2>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<pre><code class="language-java">public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br>
<pre><code class="language-java">public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) {
            executorService.execute(() -&gt; {
                System.out.print(&quot;before..&quot;);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print(&quot;after..&quot;);
            });
        }
        executorService.shutdown();
    }
}
</code></pre>
<pre><code class="language-html">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
</code></pre>
<h2><a class="header" href="#semaphore" id="semaphore">Semaphore</a></h2>
<p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<pre><code class="language-java">public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalRequestCount; i++) {
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + &quot; &quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
</code></pre>
<pre><code class="language-html">2 1 2 2 2 2 2 1 2 2
</code></pre>
<h1><a class="header" href="#八juc---其它组件" id="八juc---其它组件">八、J.U.C - 其它组件</a></h1>
<h2><a class="header" href="#futuretask" id="futuretask">FutureTask</a></h2>
<p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future<V> 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<pre><code class="language-java">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;
</code></pre>
<pre><code class="language-java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;
</code></pre>
<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<pre><code class="language-java">public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() {
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i &lt; 100; i++) {
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });

        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread otherThread = new Thread(() -&gt; {
            System.out.println(&quot;other task is running...&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        System.out.println(futureTask.get());
    }
}
</code></pre>
<pre><code class="language-html">other task is running...
4950
</code></pre>
<h2><a class="header" href="#blockingqueue" id="blockingqueue">BlockingQueue</a></h2>
<p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li><strong>FIFO 队列</strong>  ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li><strong>优先级队列</strong>  ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
<p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p>
<pre><code class="language-java">public class ProducerConsumer {

    private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);

    private static class Producer extends Thread {
        @Override
        public void run() {
            try {
                queue.put(&quot;product&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&quot;produce..&quot;);
        }
    }

    private static class Consumer extends Thread {

        @Override
        public void run() {
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&quot;consume..&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    for (int i = 0; i &lt; 2; i++) {
        Producer producer = new Producer();
        producer.start();
    }
    for (int i = 0; i &lt; 5; i++) {
        Consumer consumer = new Consumer();
        consumer.start();
    }
    for (int i = 0; i &lt; 3; i++) {
        Producer producer = new Producer();
        producer.start();
    }
}
</code></pre>
<pre><code class="language-html">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..
</code></pre>
<h2><a class="header" href="#forkjoin" id="forkjoin">ForkJoin</a></h2>
<p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>
<pre><code class="language-java">public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; {

    private final int threshold = 5;
    private int first;
    private int last;

    public ForkJoinExample(int first, int last) {
        this.first = first;
        this.last = last;
    }

    @Override
    protected Integer compute() {
        int result = 0;
        if (last - first &lt;= threshold) {
            // 任务足够小则直接计算
            for (int i = first; i &lt;= last; i++) {
                result += i;
            }
        } else {
            // 拆分成小任务
            int middle = first + (last - first) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(first, middle);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
            leftTask.fork();
            rightTask.fork();
            result = leftTask.join() + rightTask.join();
        }
        return result;
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    ForkJoinExample example = new ForkJoinExample(1, 10000);
    ForkJoinPool forkJoinPool = new ForkJoinPool();
    Future result = forkJoinPool.submit(example);
    System.out.println(result.get());
}
</code></pre>
<p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p>
<pre><code class="language-java">public class ForkJoinPool extends AbstractExecutorService
</code></pre>
<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" width="300px"> </div><br>
<h1><a class="header" href="#九线程不安全示例" id="九线程不安全示例">九、线程不安全示例</a></h1>
<p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<pre><code class="language-java">public class ThreadUnsafeExample {

    private int cnt = 0;

    public void add() {
        cnt++;
    }

    public int get() {
        return cnt;
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
</code></pre>
<pre><code class="language-html">997
</code></pre>
<h1><a class="header" href="#十java-内存模型" id="十java-内存模型">十、Java 内存模型</a></h1>
<p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h2><a class="header" href="#主内存与工作内存" id="主内存与工作内存">主内存与工作内存</a></h2>
<p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="600px"> </div><br>
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="600px"> </div><br>
<h2><a class="header" href="#内存间交互操作" id="内存间交互操作">内存间交互操作</a></h2>
<p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="450px"> </div><br>
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h2><a class="header" href="#内存模型三大特性" id="内存模型三大特性">内存模型三大特性</a></h2>
<h3><a class="header" href="#1-原子性" id="1-原子性">1. 原子性</a></h3>
<p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="300px"> </div><br>
<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="300px"> </div><br>
<p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p>
<pre><code class="language-java">public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();

    public void add() {
        cnt.incrementAndGet();
    }

    public int get() {
        return cnt.get();
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicExample example = new AtomicExample(); // 只修改这条语句
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
</code></pre>
<pre><code class="language-html">1000
</code></pre>
<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p>
<pre><code class="language-java">public class AtomicSynchronizedExample {
    private int cnt = 0;

    public synchronized void add() {
        cnt++;
    }

    public synchronized int get() {
        return cnt;
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicSynchronizedExample example = new AtomicSynchronizedExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
</code></pre>
<pre><code class="language-html">1000
</code></pre>
<h3><a class="header" href="#2-可见性" id="2-可见性">2. 可见性</a></h3>
<p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p>
<h3><a class="header" href="#3-有序性" id="3-有序性">3. 有序性</a></h3>
<p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h2><a class="header" href="#先行发生原则" id="先行发生原则">先行发生原则</a></h2>
<p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<h3><a class="header" href="#1-单一线程原则" id="1-单一线程原则">1. 单一线程原则</a></h3>
<blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" width="180px"> </div><br>
<h3><a class="header" href="#2-管程锁定规则" id="2-管程锁定规则">2. 管程锁定规则</a></h3>
<blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" width="350px"> </div><br>
<h3><a class="header" href="#3-volatile-变量规则" id="3-volatile-变量规则">3. volatile 变量规则</a></h3>
<blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942f33c9-8ad9-4987-836f-007de4c21de0.png" width="400px"> </div><br>
<h3><a class="header" href="#4-线程启动规则" id="4-线程启动规则">4. 线程启动规则</a></h3>
<blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png" width="380px"> </div><br>
<h3><a class="header" href="#5-线程加入规则" id="5-线程加入规则">5. 线程加入规则</a></h3>
<blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/233f8d89-31d7-413f-9c02-042f19c46ba1.png" width="400px"> </div><br>
<h3><a class="header" href="#6-线程中断规则" id="6-线程中断规则">6. 线程中断规则</a></h3>
<blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h3><a class="header" href="#7-对象终结规则" id="7-对象终结规则">7. 对象终结规则</a></h3>
<blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
<h3><a class="header" href="#8-传递性" id="8-传递性">8. 传递性</a></h3>
<blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h1><a class="header" href="#十一线程安全" id="十一线程安全">十一、线程安全</a></h1>
<p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p>
<p>线程安全有以下几种实现方式：</p>
<h2><a class="header" href="#不可变" id="不可变">不可变</a></h2>
<p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<pre><code class="language-java">public class ImmutableExample {
    public static void main(String[] args) {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put(&quot;a&quot;, 1);
    }
}
</code></pre>
<pre><code class="language-html">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)
</code></pre>
<p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p>
<pre><code class="language-java">public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
</code></pre>
<h2><a class="header" href="#互斥同步" id="互斥同步">互斥同步</a></h2>
<p>synchronized 和 ReentrantLock。</p>
<h2><a class="header" href="#非阻塞同步" id="非阻塞同步">非阻塞同步</a></h2>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<h3><a class="header" href="#1-cas" id="1-cas">1. CAS</a></h3>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h3><a class="header" href="#2-atomicinteger" id="2-atomicinteger">2. AtomicInteger</a></h3>
<p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<pre><code class="language-java">private AtomicInteger cnt = new AtomicInteger();

public void add() {
    cnt.incrementAndGet();
}
</code></pre>
<p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p>
<pre><code class="language-java">public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
</code></pre>
<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<pre><code class="language-java">public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
</code></pre>
<h3><a class="header" href="#3-aba" id="3-aba">3. ABA</a></h3>
<p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h2><a class="header" href="#无同步方案" id="无同步方案">无同步方案</a></h2>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h3><a class="header" href="#1-栈封闭" id="1-栈封闭">1. 栈封闭</a></h3>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<pre><code class="language-java">public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i &lt; 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; example.add100());
    executorService.execute(() -&gt; example.add100());
    executorService.shutdown();
}
</code></pre>
<pre><code class="language-html">100
100
</code></pre>
<h3><a class="header" href="#2-线程本地存储thread-local-storage" id="2-线程本地存储thread-local-storage">2. 线程本地存储（Thread Local Storage）</a></h3>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<pre><code class="language-java">public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -&gt; {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -&gt; {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<pre><code class="language-html">1
</code></pre>
<p>为了理解 ThreadLocal，先看以下代码：</p>
<pre><code class="language-java">public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -&gt; {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -&gt; {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<p>它所对应的底层结构图为：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png" width="500px"> </div><br>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<pre><code class="language-java">/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre>
<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<pre><code class="language-java">public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre>
<p>get() 方法类似。</p>
<pre><code class="language-java">public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
</code></pre>
<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h3><a class="header" href="#3-可重入代码reentrant-code" id="3-可重入代码reentrant-code">3. 可重入代码（Reentrant Code）</a></h3>
<p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h1><a class="header" href="#十二锁优化" id="十二锁优化">十二、锁优化</a></h1>
<p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<h2><a class="header" href="#自旋锁" id="自旋锁">自旋锁</a></h2>
<p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h2><a class="header" href="#锁消除" id="锁消除">锁消除</a></h2>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<pre><code class="language-java">public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
</code></pre>
<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<pre><code class="language-java">public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
</code></pre>
<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h2><a class="header" href="#锁粗化" id="锁粗化">锁粗化</a></h2>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h2><a class="header" href="#轻量级锁" id="轻量级锁">轻量级锁</a></h2>
<p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" width="500"/> </div><br>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png" width="500"/> </div><br>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png" width="400"/> </div><br>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h2><a class="header" href="#偏向锁" id="偏向锁">偏向锁</a></h2>
<p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg" width="600"/> </div><br>
<h1><a class="header" href="#十三多线程开发良好的实践" id="十三多线程开发良好的实践">十三、多线程开发良好的实践</a></h1>
<ul>
<li>
<p>给线程起个有意义的名字，这样可以方便找 Bug。</p>
</li>
<li>
<p>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</p>
</li>
<li>
<p>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</p>
</li>
<li>
<p>使用 BlockingQueue 实现生产者消费者问题。</p>
</li>
<li>
<p>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</p>
</li>
<li>
<p>使用本地变量和不可变类来保证线程安全。</p>
</li>
<li>
<p>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</p>
</li>
</ul>
<h1><a class="header" href="#参考资料-3" id="参考资料-3">参考资料</a></h1>
<ul>
<li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html">Threads and Locks</a></li>
<li><a href="http://ifeve.com/thread-signaling/#missed_signal">线程通信</a></li>
<li><a href="http://www.importnew.com/12773.html">Java 线程面试题 Top 50</a></li>
<li><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html">BlockingQueue</a></li>
<li><a href="https://stackoverflow.com/questions/11265289/thread-state-java">thread state java</a></li>
<li><a href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN">CSC 456 Spring 2012/ch7 MN</a></li>
<li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html">Java - Understanding Happens-before relationship</a></li>
<li><a href="https://www.slideshare.net/novathinker/6-thread-synchronization">6장 Thread Synchronization</a></li>
<li><a href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015">How is Java's ThreadLocal implemented under the hood?</a></li>
<li><a href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&amp;showPrintDialog=1">Concurrent</a></li>
<li><a href="http://www.javacreed.com/java-fork-join-example/" title="Java Fork Join Example">JAVA FORK JOIN EXAMPLE</a></li>
<li><a href="http://ifeve.com/talk-concurrency-forkjoin/">聊聊并发（八）——Fork/Join 框架介绍</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/105643505">问题链接</a></p>
<h1><a class="header" href="#一java基础" id="一java基础">一、Java基础</a></h1>
<ul>
<li>解释下什么是面向对象？面向对象和面向过程的区别？
最初的编程语言是面向过程的，主要元素是函数。面向对象是现代化编程语言的必备特性，面向对象的主要元素是类。面向对象提供了更高级的封装，使得代码可维护性更好；面向对象对世界的建模更合理，使得代码可读性更好。</li>
<li>面向对象的三大特性？分别解释下？
继承、封装、多态。</li>
<li>JDK、JRE、JVM 三者之间的关系？
JDK是Java开发工具箱，是程序员需要安装的工具集，它包括javac编译器，javac用于把java源代码编译成字节码。JRE是java运行时环境，用于运行字节码。JVM是java虚拟机，用于执行字节码。</li>
<li>重载和重写的区别？
重写是派生类重写父类函数，函数的参数完全相同。重载是函数名相同而参数类型不同。</li>
<li>Java 中是否可以重写一个 private 或者 static 方法？</li>
<li>构造器是否可以被重写？</li>
<li>构造方法有哪些特性？</li>
<li>在 Java 中定义一个不做事且没有参数的构造方法有什么作用？</li>
<li>Java 中创建对象的几种方式？</li>
<li>抽象类和接口有什么区别？</li>
<li>静态变量和实例变量的区别？</li>
<li>成员变量和局部变量的区别？</li>
<li>short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？</li>
<li>Integer 和 int 的区别？</li>
<li>装箱和拆箱</li>
<li>switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？</li>
<li>字节和字符的区别？</li>
<li>String 为什么要设计为不可变类？</li>
<li>String、StringBuilder、StringBuffer 的区别？</li>
<li>String str = &quot;i&quot; 与 String str = new String(&quot;i&quot;) 一样吗？</li>
<li>String 类的常用方法都有那些？</li>
<li>final 修饰 StringBuffer 后还可以 append 吗？</li>
<li>Object 的常用方法有哪些？</li>
<li>为什么 wait/notify 方法放在 Object 类中而不是 Thread 类中？</li>
<li>final、finally、finalize 的区别？</li>
<li>finally 块中的代码什么时候被执行？finally 是不是一定会被执行到？</li>
<li>try-catch-finally 中哪个部分可以省略？</li>
<li>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</li>
<li>static 关键字的作用？</li>
<li>super 关键字的作用？</li>
<li>transient关键字的作用？</li>
<li>== 和 equals 的区别？</li>
<li>两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？</li>
<li>为什么重写 equals() 就一定要重写 hashCode() 方法？</li>
<li>&amp; 和 &amp;&amp; 的区别？</li>
<li>Java 中的参数传递时传值呢？还是传引用？</li>
<li>Java 中的 Math.round(-1.5) 等于多少？</li>
<li>两个数的异或结果是什么？</li>
<li>error 和 exception 的区别？</li>
<li>throw 和 throws 的区别？</li>
<li>常见的异常类有哪些？</li>
<li>运行时异常与受检异常有何异同？</li>
<li>主线程可以捕获到子线程的异常吗？</li>
<li>Java 的泛型是如何工作的 ? 什么是类型擦除 ?</li>
<li>什么是泛型中的限定通配符和非限定通配符 ?</li>
<li>List&lt;? extends T&gt; 和 List &lt;? super T&gt; 之间有什么区别 ?</li>
<li>如何实现对象的克隆？</li>
<li>深克隆和浅克隆的区别？</li>
<li>什么是 Java 的序列化，如何实现 Java 的序列化？</li>
<li>Java 中的反射是什么意思？有哪些应用场景？</li>
<li>反射的优缺点？</li>
<li>Java 中的动态代理是什么？有哪些应用？</li>
<li>怎么实现动态代理？</li>
<li>Java 中的 IO 流的分类？说出几个你熟悉的实现类？</li>
<li>字节流和字符流有什么区别？</li>
<li>BIO、NIO、AIO 有什么区别？</li>
</ul>
<h1><a class="header" href="#二java集合类" id="二java集合类">二、Java集合类</a></h1>
<ul>
<li>Java 中常用的容器有哪些？</li>
<li>ArrayList 和 LinkedList 的区别？</li>
<li>ArrayList 的扩容机制？</li>
<li>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</li>
<li>HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8</li>
<li>HashMap 的 get、put、resize 方法的过程？</li>
<li>HashMap 的 size 为什么必须是 2 的整数次方？</li>
<li>HashMap 多线程死循环问题？</li>
<li>HashMap 的 get 方法能否判断某个元素是否在 Map 中？</li>
<li>HashMap 与 HashTable/ConcurrentHashMap 的区别是什么?</li>
<li>HashTable 和 ConcurrentHashMap 的区别是什么?</li>
<li>ConcurrentHashMap 的实现原理是什么？</li>
<li>HashSet 的实现原理？怎么保证元素不重复的？</li>
<li>LinkedHashMap 的实现原理?</li>
<li>Iterator 怎么使用？有什么特点？</li>
<li>Iterator 和 Enumeration 接口的区别？</li>
<li>fail-fast 与 fail-safe 有什么区别？</li>
<li>Collection 和 Collections 有什么区别？</li>
</ul>
<h1><a class="header" href="#四java虚拟机" id="四java虚拟机">四、Java虚拟机</a></h1>
<ul>
<li>说一下 Jvm 的主要组成部分？及其作用？</li>
<li>谈谈对运行时数据区的理解？</li>
<li>谈谈对堆和栈的理解？堆中存什么？栈中存什么？</li>
<li>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</li>
<li>Java 中的参数传递时传值呢？还是传引用？</li>
<li>Java 对象的大小是怎么计算的？</li>
<li>对象的访问定位的两种方式？</li>
<li>判断垃圾可以回收的方法有哪些？有什么优缺点？</li>
<li>被标记为垃圾的对象一定会被回收吗？</li>
<li>谈谈对 Java 中引用的了解？</li>
<li>谈谈对内存泄漏的理解？举几个内存泄漏的案例？</li>
<li>常用的垃圾收集算法有哪些？各自的优缺点是什么？</li>
<li>为什么要采用分代收集算法？</li>
<li>什么是浮动垃圾？</li>
<li>常用的垃圾收集器有哪些？</li>
<li>谈谈 CMS 和 G1 的区别？</li>
<li>谈谈对 G1 收集器的理解？</li>
<li>详细说下垃圾回收策略？</li>
<li>谈谈你对内存分配的理解？大对象怎么分配？空间分配担保？</li>
<li>说下你用过的 JVM 监控工具？</li>
<li>谈谈你对 JVM 调优的理解？有过工程调优经验吗？</li>
<li>JVM 设置最大堆的参数是什么？</li>
<li>谈谈你对类文件结构的理解？有哪些部分组成？</li>
<li>谈谈你对类加载机制的了解？</li>
<li>类加载各阶段的作用分别是什么？</li>
<li>有哪些类加载器？分别有什么作用？</li>
<li>怎么实现一个自定义的类加载器？需要注意什么？</li>
<li>谈谈你对双亲委派模型的理解？工作过程？为什么要使用？</li>
<li>怎么打破双亲委派模型？有哪些实际场景是需要打破双亲委派模型的？</li>
<li>谈谈你对编译期优化和运行期优化的理解？</li>
<li>谈谈你对词法分析和语法分析的理解？</li>
<li>为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？</li>
<li>编译优化技术有哪些？</li>
<li>说下你对 Java 内存模型的理解？</li>
<li>内存间的交互操作有哪些？需要满足什么规则？</li>
<li>说一下jdk的对空间的内存划分是怎样的？</li>
<li>GC的回收流程是怎样的？</li>
<li>请解释StackOverflowError和OutOfMemeryError的区别？</li>
<li>JVM的引用类型有哪些？</li>
<li>说说垃圾回收期的一些常见算法？</li>
<li>请你谈谈你对JVM的理解？Java8的虚拟机有什么更新</li>
<li>JVM的常用参数调优你知道哪些?</li>
<li>内存快照抓取和MAT分析DUMP文件知道吗？</li>
<li>谈谈JVM中，对类加载器的认识</li>
<li>在JVM中，如何判断一个对象是否死亡？</li>
</ul>
<h1><a class="header" href="#九spring" id="九spring">九、Spring</a></h1>
<ul>
<li>AOP 的代理有哪几种方式？</li>
<li>怎么实现 JDK 动态代理？</li>
<li>AOP 的基本概念：切面、连接点、切入点等？</li>
<li>谈谈你对 IOC 的理解？</li>
<li>Bean 的生命周期？</li>
<li>Bean 的作用域?</li>
<li>Spring 中的单例 Bean 的线程安全问题了解吗？</li>
<li>谈谈你对 Spring 中的事物的理解？</li>
<li>Spring 中的事务隔离级别？</li>
<li>Spring 中的事物传播行为？</li>
<li>Spring 常用的注入方式有哪些？</li>
<li>Spring 框架中用到了哪些设计模式？</li>
<li>Spring是什么?</li>
</ul>
<blockquote>
<p>Spring框架具有两大特性：IOC（控制反转）以及AOP（面相切面），同时它封装了很多成熟的功能可以使我们无需重复造『轮子』。着重说明的是IOC它通过Java的反射机制进行对象的实例化，并且集中统一管理，当然，『工厂模式』也可以进行实例化对象的管理，Spring使用IOC而没有使用『工厂模式』的原因在于IOC是通过反射机制来实现的。当我们的需求出现变动时，工厂模式会需要进行相应的变化。但是IOC的反射机制允许我们不重新编译代码，因为它的对象都是动态生成的。</p>
</blockquote>
<ul>
<li>Spring 的优点？</li>
<li>Spring的AOP理解</li>
<li>Spring的IoC理解</li>
<li>BeanFactory和ApplicationContext有什么区别？</li>
<li>请解释Spring Bean的生命周期？</li>
<li>解释Spring支持的几种bean的作用域。</li>
<li>Spring框架中的单例Beans是线程安全的么？</li>
<li>Spring如何处理线程并发问题？</li>
<li>Spring 框架中都用到了哪些设计模式？</li>
</ul>
<h1><a class="header" href="#十springmvc" id="十springmvc">十、SpringMVC</a></h1>
<ul>
<li>谈谈你对 MVC 模式的理解？</li>
<li>SpringMVC 的工作原理/执行流程？</li>
<li>SpringMVC 的重要组件有哪些？</li>
<li>谈谈你对 DispatcherServlet 的源码理解？</li>
<li>SpringMVC 常用的注解有哪些？</li>
<li>SpringMVC 怎么样设定重定向和转发的？</li>
<li>如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？</li>
<li>SpringMVC 的控制器是不是单例模式，如果是，有什么问题，怎么解决？</li>
<li>SpringMVC 里面拦截器是怎么写的？</li>
<li>SpringMVC 用什么对象从后台向前台传递数据的？</li>
</ul>
<h1><a class="header" href="#十一mybatis" id="十一mybatis">十一、MyBatis</a></h1>
<ul>
<li>Mybatis 中 #{}和 ${}的区别是什么？</li>
<li>Mybatis 有几种分页方式？</li>
<li>Mybatis 逻辑分页和物理分页的区别是什么？</li>
<li>Mybatis 是否支持延迟加载？延迟加载的原理是什么？</li>
<li>说一下 Mybatis 的一级缓存和二级缓存？</li>
<li>Mybatis 和 Hibernate 的区别有哪些？</li>
</ul>
<blockquote>
<p>答：Hibernate框架对面向对象的思想有很好的实践，但是它在处理复杂关联中会带来严重的性能问题。而相比Hibernate框架MyBatis框架则入手相对容易，因为MyBatis框架选择SQL作为它的处理语言，并且MyBatis提供了逆向工程等方法帮助我们快速实践Model和Table的绑定。同时引入MyBatis也意味着破坏一些面向对象的规则。</p>
</blockquote>
<ul>
<li>Mybatis 有哪些执行器（Executor）？</li>
<li>Mybatis 分页插件的实现原理是什么？</li>
</ul>
<h1><a class="header" href="#三设计模式部分" id="三设计模式部分">三、设计模式部分</a></h1>
<ol>
<li>请列举出在JDK中几个常用的设计模式?</li>
<li>什么是设计模式?你是否在你的代码里面使用过任何设计模式?</li>
<li>Java 中什么叫单例设计模式?请用Java 写出线程安全的单例模式</li>
<li>在Java 中，什么叫观察者设计模式(observer design pattern)?</li>
<li>使用工厂模式最主要的好处是什么?在哪里使用?</li>
<li>举一个用Java 实现的装饰模式(decorator design pattern)? 它是作用于对象层次还是类层次?</li>
<li>在Java 中，为什么不允许从静态方法中访问非静态变量?</li>
<li>设计一个ATM机，请说出你的设计思路?</li>
<li>在Java中，什么时候用重载，什么时候用重写?</li>
<li>举例说明什么情况下会更倾向于使用抽象类而不是接口?</li>
</ol>
<h1><a class="header" href="#四并发编程部分" id="四并发编程部分">四、并发编程部分</a></h1>
<ul>
<li>并行和并发有什么区别？</li>
<li>线程和进程的区别？</li>
<li>守护线程是什么？</li>
<li>创建线程的几种方式？</li>
<li>runnable 和 callable 有什么区别？</li>
<li>线程状态及转换？</li>
<li>sleep() 和 wait() 的区别？</li>
<li>线程的 run() 和 start() 有什么区别？</li>
<li>在 Java 程序中怎么保证多线程的运行安全？</li>
<li>Java 线程同步的几种方法？</li>
<li>Thread.interrupt() 方法的工作原理是什么？</li>
<li>谈谈对 ThreadLocal 的理解？</li>
<li>多线程并行运行，主线程怎么收集子线程的信息？</li>
<li>说一说自己对于 synchronized 关键字的了解？项目中怎么使用的？</li>
<li>说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</li>
<li>谈谈 synchronized 和 ReenTrantLock 的区别？</li>
<li>synchronized 和 volatile 的区别是什么？</li>
<li>简单介绍下 volatile？volatile 的底层原理是什么？内存屏障是如何实现的？</li>
<li>说下对 ReentrantReadWriteLock 的理解？</li>
<li>说下对悲观锁和乐观锁的理解？</li>
<li>乐观锁常见的两种实现方式是什么？分别有什么问题？</li>
<li>CAS 和 synchronized 的使用场景？</li>
<li>什么是 CAS，内部怎么实现的？</li>
<li>简单说下对 Java 中的原子类的理解？atomic 的原理是什么？</li>
<li>说下对同步器 AQS 的理解？</li>
<li>说下对信号量 Semaphore 的理解？</li>
<li>CountDownLatch 和 CyclicBarrier 有什么区别？</li>
<li>说下对线程池的理解？为什么要使用线程池？</li>
<li>实现 Runnable 接口和 Callable 接口的区别？</li>
<li>执行 execute() 方法和 submit() 方法的区别是什么呢？</li>
<li>如何创建线程池？</li>
<li>创建线程池的参数有哪些？</li>
<li>线程池中的的线程数一般怎么设置？需要考虑哪些问题？</li>
<li>说下对 Fork/Join 并行计算框架的理解？</li>
<li>JDK 中提供了哪些并发容器？</li>
<li>谈谈对 CopyOnWriteArrayList 的理解？</li>
<li>谈谈对 ConcurrentLinkedQueue 的理解？</li>
<li>谈谈对 ConcurrentSkipListMap 的理解？</li>
<li>谈谈对 BlockingQueue 的理解？分别有哪些实现类？</li>
</ul>
<h2><a class="header" href="#1-synchronized-相关问题" id="1-synchronized-相关问题">1. Synchronized 相关问题</a></h2>
<ul>
<li>Synchronized用过吗，其原理是什么?</li>
<li>你刚才提到获取对象的锁，这个&quot;锁”到底是什么?如何确定对象的锁?</li>
<li>什么是可重入性，为什么说Synchronized是可重入锁?</li>
<li>JVM对Java 的原生锁做了哪些优化?</li>
<li>为什么说Synchronized 是非公平锁?</li>
<li>什么是锁消除和锁粗化?</li>
<li>为什么说Synchronized 是一个悲观锁 ?乐观锁的实现原理又是什么?什么是CAS，它有什么特性?</li>
<li>乐观锁一定就是好的吗？</li>
</ul>
<h2><a class="header" href="#2-可重入锁reentrantlock-及其他显式锁相关问题" id="2-可重入锁reentrantlock-及其他显式锁相关问题">2. 可重入锁ReentrantLock 及其他显式锁相关问题</a></h2>
<ul>
<li>跟Synchronized 相比，可重入锁ReentrantLock 其实现原理有什么不同?</li>
<li>那么请谈谈AQS框架是怎么回事儿?</li>
<li>请尽可能详尽地对比下Synchronized和ReentrantLock 的异同。</li>
<li>ReentrantLock是如何实现可重入性的?</li>
<li>除了ReetrantLock，你还接触过JUC 中的哪些并发工具?</li>
<li>请谈谈ReadWriteLock和StampedLock.</li>
<li>如何让Java 的线程彼此同步?你了解过哪些同步器?请分别介绍下。</li>
<li>CyclicBarrier 和CountDownLatch 看起来很相似，请对比下呢?</li>
</ul>
<h2><a class="header" href="#3-java线程池相关问题" id="3-java线程池相关问题">3. Java线程池相关问题</a></h2>
<ul>
<li>Java中的线程池是如何实现的?</li>
<li>创建线程池的几个核心构造参数?</li>
<li>线程池中的线程是怎么创建的?是一开始就随着线程池的启动创建好的吗?</li>
<li>既然提到可以通过配置不同参数创建出不同的线程池，那么Java中默认实现好的线程池又有哪些呢?请比较它们的异同。</li>
<li>如何在Java 线程池中提交线程?</li>
</ul>
<h2><a class="header" href="#4-java内存模型相关问题" id="4-java内存模型相关问题">4. Java内存模型相关问题</a></h2>
<ul>
<li>什么是Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的?</li>
<li>请谈谈volatile 有什么特点，为什么它能保证变量对所有线程的可见性?</li>
<li>既然volatile 能够保证线程间的变量可见性，是不是就意味着基于volatile变量的运算就是并发安全的?</li>
<li>请对比下volatile 对比Synchronized 的异同。</li>
<li>请谈谈ThreadLocal是怎么解决并发安全的?</li>
<li>很多人都说要慎用ThreadLocal, 谈谈你的理解，使用ThreadLocal需要注意些什么?
docker</li>
</ul>
<h1><a class="header" href="#学习java要多读代码" id="学习java要多读代码">学习Java要多读代码</a></h1>
<ul>
<li>JVM底层</li>
<li>Spring家族</li>
<li>ORM-Hibernate/Mybabit</li>
<li>线程池/数据库连接池</li>
<li>高可用接入：Netty</li>
</ul>
<h1><a class="header" href="#关于string" id="关于string">关于String</a></h1>
<p>三个类：String、StringBuffer、StringBuilder。<br />
StringBuffer支持并行。StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder</p>
<!-- GFM-TOC -->
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">一、数据类型</a>
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B">包装类型</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E7%BC%93%E5%AD%98%E6%B1%A0">缓存池</a></li>
</ul>
</li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E4%BA%8Cstring">二、String</a>
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E6%A6%82%E8%A7%88">概览</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84">不可变的好处</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#string,-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#string-pool">String Pool</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#new-string%22abc%22">new String(&quot;abc&quot;)</a></li>
</ul>
</li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E4%B8%89%E8%BF%90%E7%AE%97">三、运算</a>
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#float-%E4%B8%8E-double">float 与 double</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐式类型转换</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#switch">switch</a></li>
</ul>
</li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%9B%9B%E5%85%B3%E9%94%AE%E5%AD%97">四、关键字</a>
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#final">final</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#static">static</a></li>
</ul>
</li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E4%BA%94object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95">五、Object 通用方法</a>
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E6%A6%82%E8%A7%88">概览</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#equals">equals()</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#hashcode">hashCode()</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#tostring">toString()</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#clone">clone()</a></li>
</ul>
</li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%85%AD%E7%BB%A7%E6%89%BF">六、继承</a>
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">访问权限</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">抽象类与接口</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#super">super</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD">重写与重载</a></li>
</ul>
</li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E4%B8%83%E5%8F%8D%E5%B0%84">七、反射</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%85%AB%E5%BC%82%E5%B8%B8">八、异常</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E4%B9%9D%E6%B3%9B%E5%9E%8B">九、泛型</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%8D%81%E6%B3%A8%E8%A7%A3">十、注解</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%8D%81%E4%B8%80%E7%89%B9%E6%80%A7">十一、特性</a>
<ul>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">Java 各版本的新特性</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#java-%E4%B8%8E-c-%E7%9A%84%E5%8C%BA%E5%88%AB">Java 与 C++ 的区别</a></li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#jre-or-jdk">JRE or JDK</a></li>
</ul>
</li>
<li><a href="java/Java%E5%9F%BA%E7%A1%80.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一数据类型" id="一数据类型">一、数据类型</a></h1>
<h2><a class="header" href="#基本类型" id="基本类型">基本类型</a></h2>
<ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">The Java® Virtual Machine Specification</a></li>
</ul>
<h2><a class="header" href="#包装类型" id="包装类型">包装类型</a></h2>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<pre><code class="language-java">Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
</code></pre>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a></li>
</ul>
<h2><a class="header" href="#缓存池" id="缓存池">缓存池</a></h2>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<pre><code class="language-java">Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
</code></pre>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<pre><code class="language-java">public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
</code></pre>
<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<pre><code class="language-java">static final int low = -128;
static final int high;
static final Integer cache[];

static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k &lt; cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high &gt;= 127;
}
</code></pre>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<pre><code class="language-java">Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
</code></pre>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123
</a></p>
<h1><a class="header" href="#二string" id="二string">二、String</a></h1>
<h2><a class="header" href="#概览" id="概览">概览</a></h2>
<p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
</code></pre>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
</code></pre>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2><a class="header" href="#不可变的好处" id="不可变的好处">不可变的好处</a></h2>
<p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png"/> </div><br>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">Program Creek : Why String is immutable in Java?</a></p>
<h2><a class="header" href="#string-stringbuffer-and-stringbuilder" id="string-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder</a></h2>
<p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder">StackOverflow : String, StringBuffer, and StringBuilder</a></p>
<h2><a class="header" href="#string-pool" id="string-pool">String Pool</a></h2>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<pre><code class="language-java">String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4);           // true
</code></pre>
<p>如果是采用 &quot;bbb&quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<pre><code class="language-java">String s5 = &quot;bbb&quot;;
String s6 = &quot;bbb&quot;;
System.out.println(s5 == s6);  // true
</code></pre>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning">StackOverflow : What is String interning?</a></li>
<li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析 String#intern</a></li>
</ul>
<h2><a class="header" href="#new-stringabc" id="new-stringabc">new String(&quot;abc&quot;)</a></h2>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &quot;abc&quot; 字符串对象）。</p>
<ul>
<li>&quot;abc&quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &quot;abc&quot; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<pre><code class="language-java">public class NewStringTest {
    public static void main(String[] args) {
        String s = new String(&quot;abc&quot;);
    }
}
</code></pre>
<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<pre><code class="language-java">// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V
         9: astore_1
// ...
</code></pre>
<p>在 Constant Pool 中，#19 存储这字符串字面量 &quot;abc&quot;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre><code class="language-java">public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
</code></pre>
<h1><a class="header" href="#三运算" id="三运算">三、运算</a></h1>
<h2><a class="header" href="#参数传递" id="参数传递">参数传递</a></h2>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p>
<pre><code class="language-java">public class Dog {

    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
</code></pre>
<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<pre><code class="language-java">class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName(&quot;B&quot;);
    }
}
</code></pre>
<p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<pre><code class="language-java">public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog(&quot;B&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
</code></pre>
<p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p>
<h2><a class="header" href="#float-与-double" id="float-与-double">float 与 double</a></h2>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<pre><code class="language-java">// float f = 1.1;
</code></pre>
<p>1.1f 字面量才是 float 类型。</p>
<pre><code class="language-java">float f = 1.1f;
</code></pre>
<h2><a class="header" href="#隐式类型转换" id="隐式类型转换">隐式类型转换</a></h2>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<pre><code class="language-java">short s1 = 1;
// s1 = s1 + 1;
</code></pre>
<p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<pre><code class="language-java">s1 += 1;
s1++;
</code></pre>
<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<pre><code class="language-java">s1 = (short) (s1 + 1);
</code></pre>
<p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting">StackOverflow : Why don't Java's +=, -=, *=, /= compound assignment operators require casting?</a></p>
<h2><a class="header" href="#switch" id="switch">switch</a></h2>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<pre><code class="language-java">String s = &quot;a&quot;;
switch (s) {
    case &quot;a&quot;:
        System.out.println(&quot;aaa&quot;);
        break;
    case &quot;b&quot;:
        System.out.println(&quot;bbb&quot;);
        break;
}
</code></pre>
<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<pre><code class="language-java">// long x = 111;
// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
</code></pre>
<p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java">StackOverflow : Why can't your switch statement data type be long, Java?</a></p>
<h1><a class="header" href="#四关键字" id="四关键字">四、关键字</a></h1>
<h2><a class="header" href="#final" id="final">final</a></h2>
<p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<pre><code class="language-java">final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
</code></pre>
<p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<h2><a class="header" href="#static" id="static">static</a></h2>
<p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<pre><code class="language-java">public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
</code></pre>
<p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<pre><code class="language-java">public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
}
</code></pre>
<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p>
<pre><code class="language-java">public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;     // 'A.this' cannot be referenced from a static context
    }
}
</code></pre>
<p><strong>3. 静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<pre><code class="language-java">public class A {
    static {
        System.out.println(&quot;123&quot;);
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
</code></pre>
<pre><code class="language-html">123
</code></pre>
<p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<pre><code class="language-java">public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
</code></pre>
<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<pre><code class="language-java">import static com.xxx.ClassName.*
</code></pre>
<p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<pre><code class="language-java">public static String staticField = &quot;静态变量&quot;;
</code></pre>
<pre><code class="language-java">static {
    System.out.println(&quot;静态语句块&quot;);
}
</code></pre>
<pre><code class="language-java">public String field = &quot;实例变量&quot;;
</code></pre>
<pre><code class="language-java">{
    System.out.println(&quot;普通语句块&quot;);
}
</code></pre>
<p>最后才是构造函数的初始化。</p>
<pre><code class="language-java">public InitialOrderTest() {
    System.out.println(&quot;构造函数&quot;);
}
</code></pre>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1><a class="header" href="#五object-通用方法" id="五object-通用方法">五、Object 通用方法</a></h1>
<h2><a class="header" href="#概览-1" id="概览-1">概览</a></h2>
<pre><code class="language-java">
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
</code></pre>
<h2><a class="header" href="#equals" id="equals">equals()</a></h2>
<p><strong>1. 等价关系</strong></p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<p>Ⅰ 自反性</p>
<pre><code class="language-java">x.equals(x); // true
</code></pre>
<p>Ⅱ 对称性</p>
<pre><code class="language-java">x.equals(y) == y.equals(x); // true
</code></pre>
<p>Ⅲ 传递性</p>
<pre><code class="language-java">if (x.equals(y) &amp;&amp; y.equals(z))
    x.equals(z); // true;
</code></pre>
<p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<pre><code class="language-java">x.equals(y) == x.equals(y); // true
</code></pre>
<p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<pre><code class="language-java">x.equals(null); // false;
</code></pre>
<p><strong>2. 等价与相等</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<pre><code class="language-java">Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
</code></pre>
<p><strong>3. 实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<pre><code class="language-java">public class EqualExample {

    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
</code></pre>
<h2><a class="header" href="#hashcode" id="hashcode">hashCode()</a></h2>
<p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<pre><code class="language-java">EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
</code></pre>
<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<pre><code class="language-java">@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
</code></pre>
<h2><a class="header" href="#tostring" id="tostring">toString()</a></h2>
<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<pre><code class="language-java">public class ToStringExample {

    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
</code></pre>
<pre><code class="language-java">ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
</code></pre>
<pre><code class="language-html">ToStringExample@4554617c
</code></pre>
<h2><a class="header" href="#clone" id="clone">clone()</a></h2>
<p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;
}
</code></pre>
<pre><code class="language-java">CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'
</code></pre>
<p>重写 clone() 得到以下实现：</p>
<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
</code></pre>
<pre><code class="language-java">CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
</code></pre>
<pre><code class="language-html">java.lang.CloneNotSupportedException: CloneExample
</code></pre>
<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<pre><code class="language-java">public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<pre><code class="language-java">public class ShallowCloneExample implements Cloneable {

    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
</code></pre>
<pre><code class="language-java">ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
</code></pre>
<p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<pre><code class="language-java">public class DeepCloneExample implements Cloneable {

    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
</code></pre>
<pre><code class="language-java">DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>
<p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<pre><code class="language-java">public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
</code></pre>
<pre><code class="language-java">CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>
<h1><a class="header" href="#六继承" id="六继承">六、继承</a></h1>
<h2><a class="header" href="#访问权限" id="访问权限">访问权限</a></h2>
<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<pre><code class="language-java">public class AccessExample {
    public String id;
}
</code></pre>
<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<pre><code class="language-java">public class AccessExample {

    private int id;

    public String getId() {
        return id + &quot;&quot;;
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
</code></pre>
<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<pre><code class="language-java">public class AccessWithInnerClassExample {

    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问
    }
}
</code></pre>
<h2><a class="header" href="#抽象类与接口" id="抽象类与接口">抽象类与接口</a></h2>
<p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<pre><code class="language-java">public abstract class AbstractClassExample {

    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println(&quot;func2&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
</code></pre>
<pre><code class="language-java">// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
</code></pre>
<p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<pre><code class="language-java">public interface InterfaceExample {

    void func1();

    default void func2(){
        System.out.println(&quot;func2&quot;);
    }

    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}
</code></pre>
<pre><code class="language-java">public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
</code></pre>
<pre><code class="language-java">// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
</code></pre>
<p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">Abstract Methods and Classes</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface</a></li>
<li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface</a></li>
</ul>
<h2><a class="header" href="#super" id="super">super</a></h2>
<ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<pre><code class="language-java">public class SuperExample {

    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println(&quot;SuperExample.func()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class SuperExtendExample extends SuperExample {

    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        super.func();
        System.out.println(&quot;SuperExtendExample.func()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
</code></pre>
<pre><code class="language-html">SuperExample.func()
SuperExtendExample.func()
</code></pre>
<p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html">Using the Keyword super</a></p>
<h2><a class="header" href="#重写与重载" id="重写与重载">重写与重载</a></h2>
<p><strong>1. 重写（Override）</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList<Integer>，是父类返回类型 List<Integer> 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<pre><code class="language-java">class SuperClass {
    protected List&lt;Integer&gt; func() throws Throwable {
        return new ArrayList&lt;&gt;();
    }
}

class SubClass extends SuperClass {
    @Override
    public ArrayList&lt;Integer&gt; func() throws Exception {
        return new ArrayList&lt;&gt;();
    }
}
</code></pre>
<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<pre><code class="language-java">/*
    A
    |
    B
    |
    C
    |
    D
 */


class A {

    public void show(A obj) {
        System.out.println(&quot;A.show(A)&quot;);
    }

    public void show(C obj) {
        System.out.println(&quot;A.show(C)&quot;);
    }
}

class B extends A {

    @Override
    public void show(A obj) {
        System.out.println(&quot;B.show(A)&quot;);
    }
}

class C extends B {
}

class D extends C {
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
</code></pre>
<p><strong>2. 重载（Overload）</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h1><a class="header" href="#七反射" id="七反射">七、反射</a></h1>
<p>每个类都有一个   <strong>Class</strong>   对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong>  ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong>  ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong>  ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li>
<pre><code>**可扩展性**   ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
</code></pre>
</li>
<li>
<pre><code>**类浏览器和可视化开发环境**   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
</code></pre>
</li>
<li>
<pre><code>**调试器和测试工具**   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。
</code></pre>
</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li>
<pre><code>**性能开销**   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
</code></pre>
</li>
<li>
<pre><code>**安全限制**   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
</code></pre>
</li>
<li>
<pre><code>**内部暴露**   ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。
</code></pre>
</li>
</ul>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API</a></li>
<li><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></li>
</ul>
<h1><a class="header" href="#八异常" id="八异常">八、异常</a></h1>
<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：  <strong>Error</strong>   和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong>  ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong>  ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png" width="600"/> </div><br>
<ul>
<li><a href="https://www.tianmaying.com/tutorial/Java-Exception">Java 入门之异常处理</a></li>
<li><a href="http://www.importnew.com/7383.html">Java 异常的面试问题及答案 -Part 1</a></li>
</ul>
<h1><a class="header" href="#九泛型" id="九泛型">九、泛型</a></h1>
<pre><code class="language-java">public class Box&lt;T&gt; {
    // T stands for &quot;Type&quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
</code></pre>
<ul>
<li><a href="http://www.importnew.com/24029.html">Java 泛型详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></li>
</ul>
<h1><a class="header" href="#十注解" id="十注解">十、注解</a></h1>
<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解 Annotation 实现原理与自定义注解例子</a></p>
<h1><a class="header" href="#十一特性" id="十一特性">十一、特性</a></h1>
<h2><a class="header" href="#java-各版本的新特性" id="java-各版本的新特性">Java 各版本的新特性</a></h2>
<p><strong>New highlights in Java SE 8</strong></p>
<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<p><strong>New highlights in Java SE 7</strong></p>
<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li>Diamond Syntax</li>
</ol>
<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?</a></li>
<li><a href="http://www.importnew.com/19345.html">Java 8 特性</a></li>
</ul>
<h2><a class="header" href="#java-与-c-的区别" id="java-与-c-的区别">Java 与 C++ 的区别</a></h2>
<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php">What are the main differences between Java and C++?</a></p>
<h2><a class="header" href="#jre-or-jdk" id="jre-or-jdk">JRE or JDK</a></h2>
<ul>
<li>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</li>
<li>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</li>
</ul>
<h1><a class="header" href="#参考资料-4" id="参考资料-4">参考资料</a></h1>
<ul>
<li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#%E4%B8%80%E6%A6%82%E8%A7%88">一、概览</a>
<ul>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#collection">Collection</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#map">Map</a></li>
</ul>
</li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#%E4%BA%8C%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">二、容器中的设计模式</a>
<ul>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li>
</ul>
</li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#%E4%B8%89%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">三、源码分析</a>
<ul>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#arraylist">ArrayList</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#vector">Vector</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#copyonwritearraylist">CopyOnWriteArrayList</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#linkedlist">LinkedList</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#hashmap">HashMap</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#concurrenthashmap">ConcurrentHashMap</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#linkedhashmap">LinkedHashMap</a></li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#weakhashmap">WeakHashMap</a></li>
</ul>
</li>
<li><a href="java/Java%E5%AE%B9%E5%99%A8.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一概览-1" id="一概览-1">一、概览</a></h1>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2><a class="header" href="#collection" id="collection">Collection</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png"/> </div><br>
<h3><a class="header" href="#1-set" id="1-set">1. Set</a></h3>
<ul>
<li>
<p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
</li>
<li>
<p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
</li>
<li>
<p>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</p>
</li>
</ul>
<h3><a class="header" href="#2-list" id="2-list">2. List</a></h3>
<ul>
<li>
<p>ArrayList：基于动态数组实现，支持随机访问。</p>
</li>
<li>
<p>Vector：和 ArrayList 类似，但它是线程安全的。</p>
</li>
<li>
<p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
</ul>
<h3><a class="header" href="#3-queue" id="3-queue">3. Queue</a></h3>
<ul>
<li>
<p>LinkedList：可以用它来实现双向队列。</p>
</li>
<li>
<p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</p>
</li>
</ul>
<h2><a class="header" href="#map" id="map">Map</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208224757855.png"/> </div><br>
<ul>
<li>
<p>TreeMap：基于红黑树实现。</p>
</li>
<li>
<p>HashMap：基于哈希表实现。JDK1.8 中，当同一个hash值（ Table 上元素）的链表节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树。这就是 JDK7 与 JDK8 中 HashMap 实现的最大区别。</p>
</li>
<li>
<p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
</li>
<li>
<p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p>
</li>
<li>
<p>ConcurrentHashMap:基于分段锁的高并发集合。</p>
</li>
</ul>
<h1><a class="header" href="#二容器中的设计模式" id="二容器中的设计模式">二、容器中的设计模式</a></h1>
<h2><a class="header" href="#迭代器模式" id="迭代器模式">迭代器模式</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png"/> </div><br>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;a&quot;);
list.add(&quot;b&quot;);
for (String item : list) {
    System.out.println(item);
}
</code></pre>
<h2><a class="header" href="#适配器模式" id="适配器模式">适配器模式</a></h2>
<p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<pre><code class="language-java">@SafeVarargs
public static &lt;T&gt; List&lt;T&gt; asList(T... a)
</code></pre>
<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<pre><code class="language-java">Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
</code></pre>
<p>也可以使用以下方式调用 asList()：</p>
<pre><code class="language-java">List list = Arrays.asList(1, 2, 3);
</code></pre>
<h1><a class="header" href="#三源码分析" id="三源码分析">三、源码分析</a></h1>
<p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h2><a class="header" href="#arraylist" id="arraylist">ArrayList</a></h2>
<h3><a class="header" href="#1-概览" id="1-概览">1. 概览</a></h3>
<p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<p>数组的默认大小为 10。</p>
<pre><code class="language-java">private static final int DEFAULT_CAPACITY = 10;
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png"/> </div><br>
<h3><a class="header" href="#2-扩容" id="2-扩容">2. 扩容</a></h3>
<p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<h3><a class="header" href="#3-删除元素" id="3-删除元素">3. 删除元素</a></h3>
<p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<pre><code class="language-java">public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
</code></pre>
<h3><a class="header" href="#4-序列化" id="4-序列化">4. 序列化</a></h3>
<p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<pre><code class="language-java">transient Object[] elementData; // non-private to simplify nested class access
</code></pre>
<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<pre><code class="language-java">private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}
</code></pre>
<pre><code class="language-java">private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<pre><code class="language-java">ArrayList list = new ArrayList();
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
oos.writeObject(list);
</code></pre>
<h3><a class="header" href="#5-fail-fast" id="5-fail-fast">5. Fail-Fast</a></h3>
<p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<h2><a class="header" href="#vector" id="vector">Vector</a></h2>
<h3><a class="header" href="#1-同步" id="1-同步">1. 同步</a></h3>
<p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<pre><code class="language-java">public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
</code></pre>
<h3><a class="header" href="#2-扩容-1" id="2-扩容-1">2. 扩容</a></h3>
<p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<pre><code class="language-java">public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}
</code></pre>
<pre><code class="language-java">private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<pre><code class="language-java">public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector() {
    this(10);
}
</code></pre>
<h3><a class="header" href="#3-与-arraylist-的比较" id="3-与-arraylist-的比较">3. 与 ArrayList 的比较</a></h3>
<ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h3><a class="header" href="#4-替代方案" id="4-替代方案">4. 替代方案</a></h3>
<p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;String&gt; synList = Collections.synchronizedList(list);
</code></pre>
<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<pre><code class="language-java">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h2><a class="header" href="#copyonwritearraylist" id="copyonwritearraylist">CopyOnWriteArrayList</a></h2>
<h3><a class="header" href="#1-读写分离" id="1-读写分离">1. 读写分离</a></h3>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<pre><code class="language-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}
</code></pre>
<pre><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}
</code></pre>
<h3><a class="header" href="#2-适用场景" id="2-适用场景">2. 适用场景</a></h3>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2><a class="header" href="#linkedlist" id="linkedlist">LinkedList</a></h2>
<h3><a class="header" href="#1-概览-1" id="1-概览-1">1. 概览</a></h3>
<p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<pre><code class="language-java">private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
}
</code></pre>
<p>每个链表存储了 first 和 last 指针：</p>
<pre><code class="language-java">transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png"/> </div><br>
<h3><a class="header" href="#2-与-arraylist-的比较" id="2-与-arraylist-的比较">2. 与 ArrayList 的比较</a></h3>
<p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h2><a class="header" href="#hashmap" id="hashmap">HashMap</a></h2>
<p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<h3><a class="header" href="#1-存储结构" id="1-存储结构">1. 存储结构</a></h3>
<p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png"/> </div><br>
<pre><code class="language-java">transient Entry[] table;
</code></pre>
<pre><code class="language-java">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;

    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                return true;
        }
        return false;
    }

    public final int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }

    public final String toString() {
        return getKey() + &quot;=&quot; + getValue();
    }
}
</code></pre>
<h3><a class="header" href="#2-拉链法的工作原理" id="2-拉链法的工作原理">2. 拉链法的工作原理</a></h3>
<pre><code class="language-java">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;K1&quot;, &quot;V1&quot;);
map.put(&quot;K2&quot;, &quot;V2&quot;);
map.put(&quot;K3&quot;, &quot;V3&quot;);
</code></pre>
<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208235258643.png"/> </div><br>
<h3><a class="header" href="#3-put-操作" id="3-put-操作">3. put 操作</a></h3>
<pre><code class="language-java">public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
</code></pre>
<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<pre><code class="language-java">private V putForNullKey(V value) {
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}
</code></pre>
<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    // 头插法，链表头部指向新的键值对
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}
</code></pre>
<pre><code class="language-java">Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
    value = v;
    next = n;
    key = k;
    hash = h;
}
</code></pre>
<h3><a class="header" href="#4-确定桶下标" id="4-确定桶下标">4. 确定桶下标</a></h3>
<p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<pre><code class="language-java">int hash = hash(key);
int i = indexFor(hash, table.length);
</code></pre>
<p><strong>4.1 计算 hash 值</strong></p>
<pre><code class="language-java">final int hash(Object k) {
    int h = hashSeed;
    if (0 != h &amp;&amp; k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
</code></pre>
<pre><code class="language-java">public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}
</code></pre>
<p><strong>4.2 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<pre><code>x   : 00010000
x-1 : 00001111
</code></pre>
<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<pre><code>y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010
</code></pre>
<p>这个性质和 y 对 x 取模效果是一样的：</p>
<pre><code>y   : 10110010
x   : 00010000
y%x : 00000010
</code></pre>
<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<pre><code class="language-java">static int indexFor(int h, int length) {
    return h &amp; (length-1);
}
</code></pre>
<h3><a class="header" href="#5-扩容-基本原理" id="5-扩容-基本原理">5. 扩容-基本原理</a></h3>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table><thead><tr><th align="center">参数</th><th align="left">含义</th></tr></thead><tbody>
<tr><td align="center">capacity</td><td align="left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr>
<tr><td align="center">size</td><td align="left">键值对数量。</td></tr>
<tr><td align="center">threshold</td><td align="left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td></tr>
<tr><td align="center">loadFactor</td><td align="left">装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td></tr>
</tbody></table>
<pre><code class="language-java">static final int DEFAULT_INITIAL_CAPACITY = 16;

static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

static final float DEFAULT_LOAD_FACTOR = 0.75f;

transient Entry[] table;

transient int size;

int threshold;

final float loadFactor;

transient int modCount;
</code></pre>
<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    if (size++ &gt;= threshold)
        resize(2 * table.length);
}
</code></pre>
<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<pre><code class="language-java">void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}

void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j &lt; src.length; j++) {
        Entry&lt;K,V&gt; e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry&lt;K,V&gt; next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
</code></pre>
<h3><a class="header" href="#6-扩容-重新计算桶下标" id="6-扩容-重新计算桶下标">6. 扩容-重新计算桶下标</a></h3>
<p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<pre><code class="language-html">capacity     : 00010000
new capacity : 00100000
</code></pre>
<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3><a class="header" href="#7-计算数组容量" id="7-计算数组容量">7. 计算数组容量</a></h3>
<p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<pre><code>mask |= mask &gt;&gt; 1    11011000
mask |= mask &gt;&gt; 2    11111110
mask |= mask &gt;&gt; 4    11111111
</code></pre>
<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<pre><code>num     10010000
mask+1 100000000
</code></pre>
<p>以下是 HashMap 中计算数组容量的代码：</p>
<pre><code class="language-java">static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<h3><a class="header" href="#8-链表转红黑树" id="8-链表转红黑树">8. 链表转红黑树</a></h3>
<p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h3><a class="header" href="#9-与-hashtable-的比较" id="9-与-hashtable-的比较">9. 与 Hashtable 的比较</a></h3>
<ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2><a class="header" href="#concurrenthashmap" id="concurrenthashmap">ConcurrentHashMap</a></h2>
<h3><a class="header" href="#1-存储结构-1" id="1-存储结构-1">1. 存储结构</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209001038024.png"/> </div><br>
<pre><code class="language-java">static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}
</code></pre>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<pre><code class="language-java">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {

    private static final long serialVersionUID = 2249069246763182397L;

    static final int MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;

    transient volatile HashEntry&lt;K,V&gt;[] table;

    transient int count;

    transient int modCount;

    transient int threshold;

    final float loadFactor;
}
</code></pre>
<pre><code class="language-java">final Segment&lt;K,V&gt;[] segments;
</code></pre>
<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<pre><code class="language-java">static final int DEFAULT_CONCURRENCY_LEVEL = 16;
</code></pre>
<h3><a class="header" href="#2-size-操作" id="2-size-操作">2. size 操作</a></h3>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<pre><code class="language-java">/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
</code></pre>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<pre><code class="language-java">
/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;

public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &lt; segments.length; ++j) {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                }
            }
            // 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries &gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
</code></pre>
<h3><a class="header" href="#3-jdk-18-的改动" id="3-jdk-18-的改动">3. JDK 1.8 的改动</a></h3>
<p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2><a class="header" href="#linkedhashmap" id="linkedhashmap">LinkedHashMap</a></h2>
<h3><a class="header" href="#存储结构" id="存储结构">存储结构</a></h3>
<p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre>
<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<pre><code class="language-java">/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<pre><code class="language-java">final boolean accessOrder;
</code></pre>
<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }
</code></pre>
<h3><a class="header" href="#afternodeaccess" id="afternodeaccess">afterNodeAccess()</a></h3>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre>
<h3><a class="header" href="#afternodeinsertion" id="afternodeinsertion">afterNodeInsertion()</a></h3>
<p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<pre><code class="language-java">void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
</code></pre>
<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<pre><code class="language-java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
</code></pre>
<h3><a class="header" href="#lru-缓存" id="lru-缓存">LRU 缓存</a></h3>
<p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES  为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<pre><code class="language-java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() &gt; MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();
    cache.put(1, &quot;a&quot;);
    cache.put(2, &quot;b&quot;);
    cache.put(3, &quot;c&quot;);
    cache.get(1);
    cache.put(4, &quot;d&quot;);
    System.out.println(cache.keySet());
}
</code></pre>
<pre><code class="language-html">[3, 1, 4]
</code></pre>
<h2><a class="header" href="#weakhashmap" id="weakhashmap">WeakHashMap</a></h2>
<h3><a class="header" href="#存储结构-1" id="存储结构-1">存储结构</a></h3>
<p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<pre><code class="language-java">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;
</code></pre>
<h3><a class="header" href="#concurrentcache" id="concurrentcache">ConcurrentCache</a></h3>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<pre><code class="language-java">public final class ConcurrentCache&lt;K, V&gt; {

    private final int size;

    private final Map&lt;K, V&gt; eden;

    private final Map&lt;K, V&gt; longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap&lt;&gt;(size);
        this.longterm = new WeakHashMap&lt;&gt;(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() &gt;= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
</code></pre>
<h1><a class="header" href="#参考资料-5" id="参考资料-5">参考资料</a></h1>
<ul>
<li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a href="https://www.w3resource.com/java-tutorial/java-collections.php">Java Collection Framework</a></li>
<li><a href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm">Iterator 模式</a></li>
<li><a href="https://tech.meituan.com/java_hashmap.html">Java 8 系列之重新认识 HashMap</a></li>
<li><a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html">What is difference between HashMap and Hashtable in Java?</a></li>
<li><a href="http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/">Java 集合之 HashMap</a></li>
<li><a href="http://www.programering.com/a/MDO3QDNwATM.html">The principle of ConcurrentHashMap analysis</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
<li><a href="https://www.jianshu.com/p/75adf47958a7">HashMap 相关面试题及其解答</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html">Java 集合细节（二）：asList 的缺陷</a></li>
<li><a href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/">Java Collection Framework – The LinkedList Class</a></li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E4%B8%80%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">一、运行时数据区域</a>
<ul>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java 虚拟机栈</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%A0%86">堆</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li>
</ul>
</li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E4%BA%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86">二、垃圾收集</a>
<ul>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E5%9B%9E%E6%94%B6">判断一个对象是否可被回收</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">垃圾收集算法</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">垃圾收集器</a></li>
</ul>
</li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E4%B8%89%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">三、内存分配与回收策略</a>
<ul>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#minor-gc-%E5%92%8C-full-gc">Minor GC 和 Full GC</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">内存分配策略</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#full-gc-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">Full GC 的触发条件</a></li>
</ul>
</li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">四、类加载机制</a>
<ul>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">类的生命周期</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">类加载过程</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA">类初始化时机</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类与类加载器</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB">类加载器分类</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">双亲委派模型</a></li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0">自定义类加载器实现</a></li>
</ul>
</li>
<li><a href="java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<p>本文大部分内容参考   <strong>周志明《深入理解 Java 虚拟机》</strong>  ，想要深入学习的话请看原书。</p>
<h1><a class="header" href="#一运行时数据区域" id="一运行时数据区域">一、运行时数据区域</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" width="400px"> </div><br>
<h2><a class="header" href="#程序计数器" id="程序计数器">程序计数器</a></h2>
<p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<h2><a class="header" href="#java-虚拟机栈" id="java-虚拟机栈">Java 虚拟机栈</a></h2>
<p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" width="400px"> </div><br>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p>
<pre><code class="language-plain">java -Xss2M HackTheJava
</code></pre>
<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<h2><a class="header" href="#本地方法栈" id="本地方法栈">本地方法栈</a></h2>
<p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png" width="300px"> </div><br>
<h2><a class="header" href="#堆" id="堆">堆</a></h2>
<p>所有对象都在这里分配内存，是垃圾收集的主要区域（&quot;GC 堆&quot;）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<pre><code class="language-plain">java -Xms1M -Xmx2M HackTheJava
</code></pre>
<h2><a class="header" href="#方法区" id="方法区">方法区</a></h2>
<p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<h2><a class="header" href="#运行时常量池" id="运行时常量池">运行时常量池</a></h2>
<p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<h2><a class="header" href="#直接内存" id="直接内存">直接内存</a></h2>
<p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h1><a class="header" href="#二垃圾收集" id="二垃圾收集">二、垃圾收集</a></h1>
<p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2><a class="header" href="#判断一个对象是否可被回收" id="判断一个对象是否可被回收">判断一个对象是否可被回收</a></h2>
<h3><a class="header" href="#1-引用计数算法" id="1-引用计数算法">1. 引用计数算法</a></h3>
<p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<pre><code class="language-java">public class Test {

    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
}
</code></pre>
<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<h3><a class="header" href="#2-可达性分析算法" id="2-可达性分析算法">2. 可达性分析算法</a></h3>
<p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d909d2-3858-4fe1-8ff4-16471db0b180.png" width="350px"> </div><br>
<h3><a class="header" href="#3-方法区的回收" id="3-方法区的回收">3. 方法区的回收</a></h3>
<p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h3><a class="header" href="#4-finalize" id="4-finalize">4. finalize()</a></h3>
<p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h2><a class="header" href="#引用类型" id="引用类型">引用类型</a></h2>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h3><a class="header" href="#1-强引用" id="1-强引用">1. 强引用</a></h3>
<p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<pre><code class="language-java">Object obj = new Object();
</code></pre>
<h3><a class="header" href="#2-软引用" id="2-软引用">2. 软引用</a></h3>
<p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<pre><code class="language-java">Object obj = new Object();
SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj = null;  // 使对象只被软引用关联
</code></pre>
<h3><a class="header" href="#3-弱引用" id="3-弱引用">3. 弱引用</a></h3>
<p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<pre><code class="language-java">Object obj = new Object();
WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);
obj = null;
</code></pre>
<h3><a class="header" href="#4-虚引用" id="4-虚引用">4. 虚引用</a></h3>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<pre><code class="language-java">Object obj = new Object();
PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);
obj = null;
</code></pre>
<h2><a class="header" href="#垃圾收集算法" id="垃圾收集算法">垃圾收集算法</a></h2>
<h3><a class="header" href="#1-标记---清除" id="1-标记---清除">1. 标记 - 清除</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="400px"> </div><br>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3><a class="header" href="#2-标记---整理" id="2-标记---整理">2. 标记 - 整理</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="400px"> </div><br>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<h3><a class="header" href="#3-复制" id="3-复制">3. 复制</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="400px"> </div><br>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3><a class="header" href="#4-分代收集" id="4-分代收集">4. 分代收集</a></h3>
<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2><a class="header" href="#垃圾收集器" id="垃圾收集器">垃圾收集器</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" width=""/> </div><br>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h3><a class="header" href="#1-serial-收集器" id="1-serial-收集器">1. Serial 收集器</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" width=""/> </div><br>
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3><a class="header" href="#2-parnew-收集器" id="2-parnew-收集器">2. ParNew 收集器</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" width=""/> </div><br>
<p>它是 Serial 收集器的多线程版本。</p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h3><a class="header" href="#3-parallel-scavenge-收集器" id="3-parallel-scavenge-收集器">3. Parallel Scavenge 收集器</a></h3>
<p>与 ParNew 一样是多线程收集器。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h3><a class="header" href="#4-serial-old-收集器" id="4-serial-old-收集器">4. Serial Old 收集器</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" width=""/> </div><br>
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3><a class="header" href="#5-parallel-old-收集器" id="5-parallel-old-收集器">5. Parallel Old 收集器</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg" width=""/> </div><br>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3><a class="header" href="#6-cms-收集器" id="6-cms-收集器">6. CMS 收集器</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" width=""/> </div><br>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h3><a class="header" href="#7-g1-收集器" id="7-g1-收集器">7. G1 收集器</a></h3>
<p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png" width="600"/> </div><br>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" width="600"/> </div><br>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" width=""/> </div><br>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h1><a class="header" href="#三内存分配与回收策略" id="三内存分配与回收策略">三、内存分配与回收策略</a></h1>
<h2><a class="header" href="#minor-gc-和-full-gc" id="minor-gc-和-full-gc">Minor GC 和 Full GC</a></h2>
<ul>
<li>
<p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
</li>
<li>
<p>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
</li>
</ul>
<h2><a class="header" href="#内存分配策略" id="内存分配策略">内存分配策略</a></h2>
<h3><a class="header" href="#1-对象优先在-eden-分配" id="1-对象优先在-eden-分配">1. 对象优先在 Eden 分配</a></h3>
<p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3><a class="header" href="#2-大对象直接进入老年代" id="2-大对象直接进入老年代">2. 大对象直接进入老年代</a></h3>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3><a class="header" href="#3-长期存活的对象进入老年代" id="3-长期存活的对象进入老年代">3. 长期存活的对象进入老年代</a></h3>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3><a class="header" href="#4-动态对象年龄判定" id="4-动态对象年龄判定">4. 动态对象年龄判定</a></h3>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3><a class="header" href="#5-空间分配担保" id="5-空间分配担保">5. 空间分配担保</a></h3>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2><a class="header" href="#full-gc-的触发条件" id="full-gc-的触发条件">Full GC 的触发条件</a></h2>
<p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h3><a class="header" href="#1-调用-systemgc" id="1-调用-systemgc">1. 调用 System.gc()</a></h3>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3><a class="header" href="#2-老年代空间不足" id="2-老年代空间不足">2. 老年代空间不足</a></h3>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h3><a class="header" href="#3-空间分配担保失败" id="3-空间分配担保失败">3. 空间分配担保失败</a></h3>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h3><a class="header" href="#4-jdk-17-及以前的永久代空间不足" id="4-jdk-17-及以前的永久代空间不足">4. JDK 1.7 及以前的永久代空间不足</a></h3>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3><a class="header" href="#5-concurrent-mode-failure" id="5-concurrent-mode-failure">5. Concurrent Mode Failure</a></h3>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1><a class="header" href="#四类加载机制" id="四类加载机制">四、类加载机制</a></h1>
<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2><a class="header" href="#类的生命周期" id="类的生命周期">类的生命周期</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="600px"> </div><br>
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h2><a class="header" href="#类加载过程" id="类加载过程">类加载过程</a></h2>
<p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h3><a class="header" href="#1-加载" id="1-加载">1. 加载</a></h3>
<p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h3><a class="header" href="#2-验证" id="2-验证">2. 验证</a></h3>
<p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3><a class="header" href="#3-准备" id="3-准备">3. 准备</a></h3>
<p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<pre><code class="language-java">public static int value = 123;
</code></pre>
<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<pre><code class="language-java">public static final int value = 123;
</code></pre>
<h3><a class="header" href="#4-解析" id="4-解析">4. 解析</a></h3>
<p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<div data="补充为什么可以支持动态绑定 --> <--"></div>
### 5. 初始化
<div data="modify -->"></div>
初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。
<p>&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<pre><code class="language-java">public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
</code></pre>
<p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<pre><code class="language-java">static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
</code></pre>
<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2><a class="header" href="#类初始化时机" id="类初始化时机">类初始化时机</a></h2>
<h3><a class="header" href="#1-主动引用" id="1-主动引用">1. 主动引用</a></h3>
<p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li>
<p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li>
<p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li>
<p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li>
<p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p>
</li>
<li>
<p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p>
</li>
</ul>
<h3><a class="header" href="#2-被动引用" id="2-被动引用">2. 被动引用</a></h3>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<pre><code class="language-java">System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
</code></pre>
<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li>
</ul>
<pre><code class="language-java">SuperClass[] sca = new SuperClass[10];
</code></pre>
<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<pre><code class="language-java">System.out.println(ConstClass.HELLOWORLD);
</code></pre>
<h2><a class="header" href="#类与类加载器" id="类与类加载器">类与类加载器</a></h2>
<p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2><a class="header" href="#类加载器分类" id="类加载器分类">类加载器分类</a></h2>
<p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>
<p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</p>
</li>
<li>
<p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p>
</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li>
<p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p>
</li>
<li>
<p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li>
<p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<div data="modify <--"></div>
## 双亲委派模型
<p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="500px"> </div><br>
<h3><a class="header" href="#1-工作过程" id="1-工作过程">1. 工作过程</a></h3>
<p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<h3><a class="header" href="#2-好处" id="2-好处">2. 好处</a></h3>
<p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<h3><a class="header" href="#3-实现" id="3-实现">3. 实现</a></h3>
<p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<pre><code class="language-java">public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
</code></pre>
<h2><a class="header" href="#自定义类加载器实现" id="自定义类加载器实现">自定义类加载器实现</a></h2>
<p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<pre><code class="language-java">public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + &quot;.class&quot;;
    }
}
</code></pre>
<h1><a class="header" href="#参考资料-6" id="参考资料-6">参考资料</a></h1>
<ul>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Chapter 2. The Structure of the Java Virtual Machine</a></li>
<li><a href="https://www.slideshare.net/benewu/jvm-memory">Jvm memory</a>
<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">Getting Started with the G1 Garbage Collector</a></li>
<li><a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></li>
<li><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/">Memory Architecture Of JVM(Runtime Data Areas)</a></li>
<li><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/">JVM Run-Time Data Areas</a></li>
<li><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271">Android on x86: Java Native Interface and the Android Native Development Kit</a></li>
<li><a href="https://crowhawk.github.io/2017/08/10/jvm_2/">深入理解 JVM(2)——GC 算法与内存分配策略</a></li>
<li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/">深入理解 JVM(3)——7 种垃圾收集器</a></li>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6">深入探讨 Java 类加载器</a></li>
<li><a href="http://www.baeldung.com/java-weakhashmap">Guide to WeakHashMap in Java</a></li>
<li><a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml">Tomcat example source code file (ConcurrentCache.java)</a></li>
</ul>
<h1><a class="header" href="#目录-9" id="目录-9">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">一 、基础概念</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#uri">URI</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">请求和响应报文</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%BA%8Chttp-%E6%96%B9%E6%B3%95">二、HTTP 方法</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#get">GET</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#head">HEAD</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#post">POST</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#put">PUT</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#patch">PATCH</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#delete">DELETE</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#options">OPTIONS</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#connect">CONNECT</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#trace">TRACE</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%B8%89http-%E7%8A%B6%E6%80%81%E7%A0%81">三、HTTP 状态码</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#1xx-%E4%BF%A1%E6%81%AF">1XX 信息</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#2xx-%E6%88%90%E5%8A%9F">2XX 成功</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#3xx-%E9%87%8D%E5%AE%9A%E5%90%91">3XX 重定向</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF">4XX 客户端错误</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">5XX 服务器错误</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%9B%9Bhttp-%E9%A6%96%E9%83%A8">四、HTTP 首部</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">通用首部字段</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">请求首部字段</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">响应首部字段</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">实体首部字段</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%BA%94%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8">五、具体应用</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#cookie">Cookie</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">内容协商</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81">内容编码</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82">范围请求</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">分块传输编码</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88">多部分对象集合</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA">虚拟主机</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91">通信数据转发</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%85%ADhttps">六、HTTPS</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%8A%A0%E5%AF%86">加密</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E8%AE%A4%E8%AF%81">认证</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4">完整性保护</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#https-%E7%9A%84%E7%BC%BA%E7%82%B9">HTTPS 的缺点</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%B8%83http20">七、HTTP/2.0</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#http1x-%E7%BC%BA%E9%99%B7">HTTP/1.x 缺陷</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82">二进制分帧层</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81">服务端推送</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9">首部压缩</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%85%ABhttp11-%E6%96%B0%E7%89%B9%E6%80%A7">八、HTTP/1.1 新特性</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%B9%9Dget-%E5%92%8C-post-%E6%AF%94%E8%BE%83">九、GET 和 POST 比较</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E4%BD%9C%E7%94%A8">作用</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%AE%89%E5%85%A8">安全</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%B9%82%E7%AD%89%E6%80%A7">幂等性</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%8F%AF%E7%BC%93%E5%AD%98">可缓存</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#xmlhttprequest">XMLHttpRequest</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一-基础概念" id="一-基础概念">一 、基础概念</a></h1>
<h2><a class="header" href="#uri" id="uri">URI</a></h2>
<p>URI 包含 URL 和 URN。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" width="500px"> </div><br>
<h2><a class="header" href="#请求和响应报文" id="请求和响应报文">请求和响应报文</a></h2>
<h3><a class="header" href="#1-请求报文" id="1-请求报文">1. 请求报文</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_RequestMessageExample.png" width=""/> </div><br>
<h3><a class="header" href="#2-响应报文" id="2-响应报文">2. 响应报文</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_ResponseMessageExample.png" width=""/> </div><br>
<h1><a class="header" href="#二http-方法" id="二http-方法">二、HTTP 方法</a></h1>
<p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p>
<h2><a class="header" href="#get" id="get">GET</a></h2>
<blockquote>
<p>获取资源</p>
</blockquote>
<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>
<h2><a class="header" href="#head" id="head">HEAD</a></h2>
<blockquote>
<p>获取报文首部</p>
</blockquote>
<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<h2><a class="header" href="#post" id="post">POST</a></h2>
<blockquote>
<p>传输实体主体</p>
</blockquote>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
<p>更多 POST 与 GET 的比较请见第九章。</p>
<h2><a class="header" href="#put" id="put">PUT</a></h2>
<blockquote>
<p>上传文件</p>
</blockquote>
<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<pre><code class="language-html">PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

&lt;p&gt;New File&lt;/p&gt;
</code></pre>
<h2><a class="header" href="#patch" id="patch">PATCH</a></h2>
<blockquote>
<p>对资源进行部分修改</p>
</blockquote>
<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<pre><code class="language-html">PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: &quot;e0023aa4e&quot;
Content-Length: 100

[description of changes]
</code></pre>
<h2><a class="header" href="#delete" id="delete">DELETE</a></h2>
<blockquote>
<p>删除文件</p>
</blockquote>
<p>与 PUT 功能相反，并且同样不带验证机制。</p>
<pre><code class="language-html">DELETE /file.html HTTP/1.1
</code></pre>
<h2><a class="header" href="#options" id="options">OPTIONS</a></h2>
<blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的 URL 能够支持的方法。</p>
<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
<h2><a class="header" href="#connect" id="connect">CONNECT</a></h2>
<blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<pre><code class="language-html">CONNECT www.example.com:443 HTTP/1.1
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg" width=""/> </div><br>
<h2><a class="header" href="#trace" id="trace">TRACE</a></h2>
<blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h1><a class="header" href="#三http-状态码" id="三http-状态码">三、HTTP 状态码</a></h1>
<p>服务器返回的   <strong>响应报文</strong>   中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">含义</th></tr></thead><tbody>
<tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr>
<tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr>
<tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr>
<tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr>
<tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr>
</tbody></table>
<h2><a class="header" href="#1xx-信息" id="1xx-信息">1XX 信息</a></h2>
<ul>
<li><strong>100 Continue</strong>  ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h2><a class="header" href="#2xx-成功" id="2xx-成功">2XX 成功</a></h2>
<ul>
<li>
<p><strong>200 OK</strong></p>
</li>
<li>
<p><strong>204 No Content</strong>  ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li>
<p><strong>206 Partial Content</strong>  ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h2><a class="header" href="#3xx-重定向" id="3xx-重定向">3XX 重定向</a></h2>
<ul>
<li>
<p><strong>301 Moved Permanently</strong>  ：永久性重定向</p>
</li>
<li>
<p><strong>302 Found</strong>  ：临时性重定向</p>
</li>
<li>
<p><strong>303 See Other</strong>  ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
</li>
<li>
<p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p>
</li>
<li>
<p><strong>304 Not Modified</strong>  ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
</li>
<li>
<p><strong>307 Temporary Redirect</strong>  ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
</ul>
<h2><a class="header" href="#4xx-客户端错误" id="4xx-客户端错误">4XX 客户端错误</a></h2>
<ul>
<li>
<p><strong>400 Bad Request</strong>  ：请求报文中存在语法错误。</p>
</li>
<li>
<p><strong>401 Unauthorized</strong>  ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
</li>
<li>
<p><strong>403 Forbidden</strong>  ：请求被拒绝。</p>
</li>
<li>
<p><strong>404 Not Found</strong></p>
</li>
</ul>
<h2><a class="header" href="#5xx-服务器错误" id="5xx-服务器错误">5XX 服务器错误</a></h2>
<ul>
<li>
<p><strong>500 Internal Server Error</strong>  ：服务器正在执行请求时发生错误。</p>
</li>
<li>
<p><strong>503 Service Unavailable</strong>  ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ul>
<h1><a class="header" href="#四http-首部" id="四http-首部">四、HTTP 首部</a></h1>
<p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>
<h2><a class="header" href="#通用首部字段" id="通用首部字段">通用首部字段</a></h2>
<table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr>
<tr><td align="center">Connection</td><td align="center">控制不再转发给代理的首部字段、管理持久连接</td></tr>
<tr><td align="center">Date</td><td align="center">创建报文的日期时间</td></tr>
<tr><td align="center">Pragma</td><td align="center">报文指令</td></tr>
<tr><td align="center">Trailer</td><td align="center">报文末端的首部一览</td></tr>
<tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr>
<tr><td align="center">Upgrade</td><td align="center">升级为其他协议</td></tr>
<tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr>
<tr><td align="center">Warning</td><td align="center">错误通知</td></tr>
</tbody></table>
<h2><a class="header" href="#请求首部字段" id="请求首部字段">请求首部字段</a></h2>
<table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr>
<tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr>
<tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr>
<tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr>
<tr><td align="center">Authorization</td><td align="center">Web 认证信息</td></tr>
<tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr>
<tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr>
<tr><td align="center">Host</td><td align="center">请求资源所在服务器</td></tr>
<tr><td align="center">If-Match</td><td align="center">比较实体标记（ETag）</td></tr>
<tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr>
<tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与 If-Match 相反）</td></tr>
<tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体 Byte 的范围请求</td></tr>
<tr><td align="center">If-Unmodified-Since</td><td align="center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr>
<tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr>
<tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr>
<tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr>
<tr><td align="center">Referer</td><td align="center">对请求中 URI 的原始获取方</td></tr>
<tr><td align="center">TE</td><td align="center">传输编码的优先级</td></tr>
<tr><td align="center">User-Agent</td><td align="center">HTTP 客户端程序的信息</td></tr>
</tbody></table>
<h2><a class="header" href="#响应首部字段" id="响应首部字段">响应首部字段</a></h2>
<table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr>
<tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr>
<tr><td align="center">ETag</td><td align="center">资源的匹配信息</td></tr>
<tr><td align="center">Location</td><td align="center">令客户端重定向至指定 URI</td></tr>
<tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr>
<tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr>
<tr><td align="center">Server</td><td align="center">HTTP 服务器的安装信息</td></tr>
<tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr>
<tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr>
</tbody></table>
<h2><a class="header" href="#实体首部字段" id="实体首部字段">实体首部字段</a></h2>
<table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">Allow</td><td align="center">资源可支持的 HTTP 方法</td></tr>
<tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr>
<tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr>
<tr><td align="center">Content-Length</td><td align="center">实体主体的大小</td></tr>
<tr><td align="center">Content-Location</td><td align="center">替代对应资源的 URI</td></tr>
<tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr>
<tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr>
<tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr>
<tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr>
<tr><td align="center">Last-Modified</td><td align="center">资源的最后修改日期时间</td></tr>
</tbody></table>
<h1><a class="header" href="#五具体应用" id="五具体应用">五、具体应用</a></h1>
<h2><a class="header" href="#连接管理" id="连接管理">连接管理</a></h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" width="800"/> </div><br>
<h3><a class="header" href="#1-短连接与长连接" id="1-短连接与长连接">1. 短连接与长连接</a></h3>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<h3><a class="header" href="#2-流水线" id="2-流水线">2. 流水线</a></h3>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<h2><a class="header" href="#cookie" id="cookie">Cookie</a></h2>
<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h3><a class="header" href="#1-用途" id="1-用途">1. 用途</a></h3>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3><a class="header" href="#2-创建过程" id="2-创建过程">2. 创建过程</a></h3>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<pre><code class="language-html">HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
</code></pre>
<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<pre><code class="language-html">GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
</code></pre>
<h3><a class="header" href="#3-分类" id="3-分类">3. 分类</a></h3>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<pre><code class="language-html">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</code></pre>
<h3><a class="header" href="#4-作用域" id="4-作用域">4. 作用域</a></h3>
<p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h3><a class="header" href="#5-javascript" id="5-javascript">5. JavaScript</a></h3>
<p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<pre><code class="language-html">document.cookie = &quot;yummy_cookie=choco&quot;;
document.cookie = &quot;tasty_cookie=strawberry&quot;;
console.log(document.cookie);
</code></pre>
<h3><a class="header" href="#6-httponly" id="6-httponly">6. HttpOnly</a></h3>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<pre><code class="language-html">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre>
<h3><a class="header" href="#7-secure" id="7-secure">7. Secure</a></h3>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<h3><a class="header" href="#8-session" id="8-session">8. Session</a></h3>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3><a class="header" href="#9-浏览器禁用-cookie" id="9-浏览器禁用-cookie">9. 浏览器禁用 Cookie</a></h3>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h3><a class="header" href="#10-cookie-与-session-选择" id="10-cookie-与-session-选择">10. Cookie 与 Session 选择</a></h3>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2><a class="header" href="#缓存-1" id="缓存-1">缓存</a></h2>
<h3><a class="header" href="#1-优点" id="1-优点">1. 优点</a></h3>
<ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>
<h3><a class="header" href="#2-实现方法" id="2-实现方法">2. 实现方法</a></h3>
<ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存。</li>
</ul>
<h3><a class="header" href="#3-cache-control" id="3-cache-control">3. Cache-Control</a></h3>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p><strong>3.1 禁止进行缓存</strong></p>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<pre><code class="language-html">Cache-Control: no-store
</code></pre>
<p><strong>3.2 强制确认缓存</strong></p>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<pre><code class="language-html">Cache-Control: no-cache
</code></pre>
<p><strong>3.3 私有缓存和公共缓存</strong></p>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<pre><code class="language-html">Cache-Control: private
</code></pre>
<p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<pre><code class="language-html">Cache-Control: public
</code></pre>
<p><strong>3.4 缓存过期机制</strong></p>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<pre><code class="language-html">Cache-Control: max-age=31536000
</code></pre>
<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<pre><code class="language-html">Expires: Wed, 04 Jul 2012 08:26:05 GMT
</code></pre>
<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h3><a class="header" href="#4-缓存验证" id="4-缓存验证">4. 缓存验证</a></h3>
<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<pre><code class="language-html">ETag: &quot;82e22293907ce725faf67773957acd12&quot;
</code></pre>
<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<pre><code class="language-html">If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;
</code></pre>
<p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>
<pre><code class="language-html">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre>
<pre><code class="language-html">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre>
<h2><a class="header" href="#内容协商" id="内容协商">内容协商</a></h2>
<p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>
<h3><a class="header" href="#1-类型" id="1-类型">1. 类型</a></h3>
<p><strong>1.1 服务端驱动型</strong></p>
<p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p>
<p>它存在以下问题：</p>
<ul>
<li>服务器很难知道客户端浏览器的全部信息；</li>
<li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li>
<li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li>
</ul>
<p><strong>1.2 代理驱动型</strong></p>
<p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p>
<h3><a class="header" href="#2-vary" id="2-vary">2. Vary</a></h3>
<pre><code class="language-html">Vary: Accept-Language
</code></pre>
<p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p>
<p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p>
<h2><a class="header" href="#内容编码" id="内容编码">内容编码</a></h2>
<p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p>
<p>常用的内容编码有：gzip、compress、deflate、identity。</p>
<p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p>
<h2><a class="header" href="#范围请求" id="范围请求">范围请求</a></h2>
<p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p>
<h3><a class="header" href="#1-range" id="1-range">1. Range</a></h3>
<p>在请求报文中添加 Range 首部字段指定请求的范围。</p>
<pre><code class="language-html">GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
</code></pre>
<p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p>
<pre><code class="language-html">HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
</code></pre>
<h3><a class="header" href="#2-accept-ranges" id="2-accept-ranges">2. Accept-Ranges</a></h3>
<p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p>
<pre><code class="language-html">Accept-Ranges: bytes
</code></pre>
<h3><a class="header" href="#3-响应状态码" id="3-响应状态码">3. 响应状态码</a></h3>
<ul>
<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
<li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>
<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
</ul>
<h2><a class="header" href="#分块传输编码" id="分块传输编码">分块传输编码</a></h2>
<p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p>
<h2><a class="header" href="#多部分对象集合" id="多部分对象集合">多部分对象集合</a></h2>
<p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p>
<p>例如，上传多个表单时可以使用如下方式：</p>
<pre><code class="language-html">Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name=&quot;submit-name&quot;

Larry
--AaB03x
Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
</code></pre>
<h2><a class="header" href="#虚拟主机" id="虚拟主机">虚拟主机</a></h2>
<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
<h2><a class="header" href="#通信数据转发" id="通信数据转发">通信数据转发</a></h2>
<h3><a class="header" href="#1-代理" id="1-代理">1. 代理</a></h3>
<p>代理服务器接受客户端的请求，并且转发给其它服务器。</p>
<p>使用代理的主要目的是：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>代理服务器分为正向代理和反向代理两种：</p>
<ul>
<li>用户察觉得到正向代理的存在。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" width=""/> </div><br>
<ul>
<li>而反向代理一般位于内部网络中，用户察觉不到。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png" width=""/> </div><br>
<h3><a class="header" href="#2-网关" id="2-网关">2. 网关</a></h3>
<p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p>
<h3><a class="header" href="#3-隧道" id="3-隧道">3. 隧道</a></h3>
<p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>
<h1><a class="header" href="#六https" id="六https">六、HTTPS</a></h1>
<p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg" width="700"/> </div><br>
<h2><a class="header" href="#加密" id="加密">加密</a></h2>
<h3><a class="header" href="#1-对称密钥加密" id="1-对称密钥加密">1. 对称密钥加密</a></h3>
<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"/> </div><br>
<h3><a class="header" href="#2非对称密钥加密" id="2非对称密钥加密">2.非对称密钥加密</a></h3>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"/> </div><br>
<h3><a class="header" href="#3-https-采用的加密方式" id="3-https-采用的加密方式">3. HTTPS 采用的加密方式</a></h3>
<p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key  传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" width="600"/> </div><br>
<h2><a class="header" href="#认证" id="认证">认证</a></h2>
<p>通过使用   <strong>证书</strong>   来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" width=""/> </div><br>
<h2><a class="header" href="#完整性保护" id="完整性保护">完整性保护</a></h2>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h2><a class="header" href="#https-的缺点" id="https-的缺点">HTTPS 的缺点</a></h2>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h1><a class="header" href="#七http20" id="七http20">七、HTTP/2.0</a></h1>
<h2><a class="header" href="#http1x-缺陷" id="http1x-缺陷">HTTP/1.x 缺陷</a></h2>
<p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>
<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<h2><a class="header" href="#二进制分帧层" id="二进制分帧层">二进制分帧层</a></h2>
<p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png" width="400"/> </div><br>
<p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>
<ul>
<li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li>
<li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li>
<li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png" width="600"/> </div><br>
<h2><a class="header" href="#服务端推送" id="服务端推送">服务端推送</a></h2>
<p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" width="800"/> </div><br>
<h2><a class="header" href="#首部压缩" id="首部压缩">首部压缩</a></h2>
<p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png" width="600"/> </div><br>
<h1><a class="header" href="#八http11-新特性" id="八http11-新特性">八、HTTP/1.1 新特性</a></h1>
<p>详细内容请见上文</p>
<ul>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<h1><a class="header" href="#九get-和-post-比较" id="九get-和-post-比较">九、GET 和 POST 比较</a></h1>
<h2><a class="header" href="#作用" id="作用">作用</a></h2>
<p>GET 用于获取资源，而 POST 用于传输实体主体。</p>
<h2><a class="header" href="#参数" id="参数">参数</a></h2>
<p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<pre><code>GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1
</code></pre>
<pre><code>POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2
</code></pre>
<h2><a class="header" href="#安全" id="安全">安全</a></h2>
<p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h2><a class="header" href="#幂等性" id="幂等性">幂等性</a></h2>
<p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<pre><code>GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
</code></pre>
<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<pre><code>POST /add_row HTTP/1.1   -&gt; Adds a 1nd row
POST /add_row HTTP/1.1   -&gt; Adds a 2nd row
POST /add_row HTTP/1.1   -&gt; Adds a 3rd row
</code></pre>
<p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p>
<pre><code>DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404
</code></pre>
<h2><a class="header" href="#可缓存" id="可缓存">可缓存</a></h2>
<p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h2><a class="header" href="#xmlhttprequest" id="xmlhttprequest">XMLHttpRequest</a></h2>
<p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
<li>而 GET 方法 Header 和 Data 会一起发送。</li>
</ul>
<h1><a class="header" href="#参考资料-7" id="参考资料-7">参考资料</a></h1>
<ul>
<li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">MDN : HTTP</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">HTTP/2 简介</a></li>
<li><a href="http://php.net/manual/zh/function.htmlspecialchars.php">htmlspecialchars</a></li>
<li><a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java">Difference between file URI and URL in java</a></li>
<li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li>
<li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html">浅谈 HTTP 中 Get 与 Post 的区别</a></li>
<li><a href="https://www.webdancers.com/are-http-and-www-necesary/">Are http:// and www really necessary?</a></li>
<li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html">HTTP (HyperText Transfer Protocol)</a></li>
<li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li>
<li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg">File:HTTP persistent connection.svg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proxy_server">Proxy server</a></li>
<li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li>
<li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/">What is SSL Offloading?</a></li>
<li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li>
<li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication">An Introduction to Mutual SSL Authentication</a></li>
<li><a href="https://danielmiessler.com/study/url-uri/">The Difference Between URLs and URIs</a></li>
<li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment">Cookie 与 Session 的区别</a></li>
<li><a href="https://www.zhihu.com/question/19786827">COOKIE 和 SESSION 有什么区别</a></li>
<li><a href="https://harttle.land/2015/08/10/cookie-session.html">Cookie/Session 的机制与安全</a></li>
<li><a href="https://shijianan.com/2017/06/11/https/">HTTPS 证书原理</a></li>
<li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn">What is the difference between a URI, a URL and a URN?</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li>
<li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li>
<li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences">Symmetric vs. Asymmetric Encryption – What are differences?</a></li>
<li><a href="https://www.kancloud.cn/digest/web-performance-http2">Web 性能优化与 HTTP/2</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">HTTP/2 简介</a></li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#ip-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#ip-%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F">IP 地址编址方式</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#1-%E5%88%86%E7%B1%BB">1. 分类</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#2-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86">2. 子网划分</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#3-%E6%97%A0%E5%88%86%E7%B1%BB">3. 无分类</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp">地址解析协议 ARP</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-icmp">网际控制报文协议 ICMP</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#1-ping">1. Ping</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#2-traceroute">2. Traceroute</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-vpn">虚拟专用网 VPN</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-nat">网络地址转换 NAT</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">路由选择协议</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-rip">1. 内部网关协议 RIP</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-ospf">2. 内部网关协议 OSPF</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html#3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-bgp">3. 外部网关协议 BGP</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#概述" id="概述">概述</a></h1>
<p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" width="800"/> </div><br>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h1><a class="header" href="#ip-数据报格式" id="ip-数据报格式">IP 数据报格式</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"/> </div><br>
<ul>
<li>
<p><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li>
<p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
</li>
<li>
<p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p>
</li>
<li>
<p><strong>总长度</strong>   : 包括首部长度和数据部分长度。</p>
</li>
<li>
<p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
<li>
<p><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
</li>
<li>
<p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>
</li>
<li>
<p><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
</li>
<li>
<p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"/> </div><br>
<h1><a class="header" href="#ip-地址编址方式" id="ip-地址编址方式">IP 地址编址方式</a></h1>
<p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h2><a class="header" href="#1-分类" id="1-分类">1. 分类</a></h2>
<p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"/> </div><br>
<h2><a class="header" href="#2-子网划分" id="2-子网划分">2. 子网划分</a></h2>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h2><a class="header" href="#3-无分类" id="3-无分类">3. 无分类</a></h2>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h1><a class="header" href="#地址解析协议-arp" id="地址解析协议-arp">地址解析协议 ARP</a></h1>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700"/> </div><br>
<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" width="500"/> </div><br>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700"/> </div><br>
<h1><a class="header" href="#网际控制报文协议-icmp" id="网际控制报文协议-icmp">网际控制报文协议 ICMP</a></h1>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"/> </div><br>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"/> </div><br>
<h2><a class="header" href="#1-ping" id="1-ping">1. Ping</a></h2>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h2><a class="header" href="#2-traceroute" id="2-traceroute">2. Traceroute</a></h2>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h1><a class="header" href="#虚拟专用网-vpn" id="虚拟专用网-vpn">虚拟专用网 VPN</a></h1>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"/> </div><br>
<h1><a class="header" href="#网络地址转换-nat" id="网络地址转换-nat">网络地址转换 NAT</a></h1>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""/> </div><br>
<h1><a class="header" href="#路由器的结构" id="路由器的结构">路由器的结构</a></h1>
<p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" width="600"/> </div><br>
<h1><a class="header" href="#路由器分组转发流程" id="路由器分组转发流程">路由器分组转发流程</a></h1>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"/> </div><br>
<h1><a class="header" href="#路由选择协议" id="路由选择协议">路由选择协议</a></h1>
<p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h2><a class="header" href="#1-内部网关协议-rip" id="1-内部网关协议-rip">1. 内部网关协议 RIP</a></h2>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h2><a class="header" href="#2-内部网关协议-ospf" id="2-内部网关协议-ospf">2. 内部网关协议 OSPF</a></h2>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h2><a class="header" href="#3-外部网关协议-bgp" id="3-外部网关协议-bgp">3. 外部网关协议 BGP</a></h2>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"/> </div><br>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">文件传送协议</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机配置协议</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%8D%8F%E8%AE%AE">远程登录协议</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE">电子邮件协议</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#1-smtp">1. SMTP</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#2-pop3">2. POP3</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#3-imap">3. IMAP</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3">常用端口</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">Web 页面请求过程</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#1-dhcp-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF">1. DHCP 配置主机信息</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#2-arp-%E8%A7%A3%E6%9E%90-mac-%E5%9C%B0%E5%9D%80">2. ARP 解析 MAC 地址</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#3-dns-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">3. DNS 解析域名</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html#4-http-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2">4. HTTP 请求页面</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#域名系统" id="域名系统">域名系统</a></h1>
<p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg"/> </div><br>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<h1><a class="header" href="#文件传送协议" id="文件传送协议">文件传送协议</a></h1>
<p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg"/> </div><br>
<ul>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg"/> </div><br>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h1><a class="header" href="#动态主机配置协议" id="动态主机配置协议">动态主机配置协议</a></h1>
<p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg"/> </div><br>
<h1><a class="header" href="#远程登录协议" id="远程登录协议">远程登录协议</a></h1>
<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h1><a class="header" href="#电子邮件协议" id="电子邮件协议">电子邮件协议</a></h1>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" width="700"/> </div><br>
<h2><a class="header" href="#1-smtp" id="1-smtp">1. SMTP</a></h2>
<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed5522bb-3a60-481c-8654-43e7195a48fe.png" width=""/> </div><br>
<h2><a class="header" href="#2-pop3" id="2-pop3">2. POP3</a></h2>
<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p>
<h2><a class="header" href="#3-imap" id="3-imap">3. IMAP</a></h2>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h1><a class="header" href="#常用端口" id="常用端口">常用端口</a></h1>
<table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">端口号</th><th align="center">传输层协议</th><th align="center">备注</th></tr></thead><tbody>
<tr><td align="center">域名解析</td><td align="center">DNS</td><td align="center">53</td><td align="center">UDP/TCP</td><td align="center">长度超过 512 字节时使用 TCP</td></tr>
<tr><td align="center">动态主机配置协议</td><td align="center">DHCP</td><td align="center">67/68</td><td align="center">UDP</td><td align="center"></td></tr>
<tr><td align="center">简单网络管理协议</td><td align="center">SNMP</td><td align="center">161/162</td><td align="center">UDP</td><td align="center"></td></tr>
<tr><td align="center">文件传送协议</td><td align="center">FTP</td><td align="center">20/21</td><td align="center">TCP</td><td align="center">控制连接 21，数据连接 20</td></tr>
<tr><td align="center">远程终端协议</td><td align="center">TELNET</td><td align="center">23</td><td align="center">TCP</td><td align="center"></td></tr>
<tr><td align="center">超文本传送协议</td><td align="center">HTTP</td><td align="center">80</td><td align="center">TCP</td><td align="center"></td></tr>
<tr><td align="center">简单邮件传送协议</td><td align="center">SMTP</td><td align="center">25</td><td align="center">TCP</td><td align="center"></td></tr>
<tr><td align="center">邮件读取协议</td><td align="center">POP3</td><td align="center">110</td><td align="center">TCP</td><td align="center"></td></tr>
<tr><td align="center">网际报文存取协议</td><td align="center">IMAP</td><td align="center">143</td><td align="center">TCP</td><td align="center"></td></tr>
</tbody></table>
<h1><a class="header" href="#web-页面请求过程" id="web-页面请求过程">Web 页面请求过程</a></h1>
<h2><a class="header" href="#1-dhcp-配置主机信息" id="1-dhcp-配置主机信息">1. DHCP 配置主机信息</a></h2>
<ul>
<li>
<p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p>
</li>
<li>
<p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p>
</li>
<li>
<p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p>
</li>
<li>
<p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF，将广播到与交换机连接的所有设备。</p>
</li>
<li>
<p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p>
</li>
<li>
<p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p>
</li>
<li>
<p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p>
</li>
</ul>
<h2><a class="header" href="#2-arp-解析-mac-地址" id="2-arp-解析-mac-地址">2. ARP 解析 MAC 地址</a></h2>
<ul>
<li>
<p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p>
</li>
<li>
<p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p>
</li>
<li>
<p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p>
</li>
<li>
<p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p>
</li>
<li>
<p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p>
</li>
<li>
<p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p>
</li>
<li>
<p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
</li>
</ul>
<h2><a class="header" href="#3-dns-解析域名" id="3-dns-解析域名">3. DNS 解析域名</a></h2>
<ul>
<li>
<p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p>
</li>
<li>
<p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p>
</li>
<li>
<p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p>
</li>
<li>
<p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p>
</li>
<li>
<p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p>
</li>
</ul>
<h2><a class="header" href="#4-http-请求页面" id="4-http-请求页面">4. HTTP 请求页面</a></h2>
<ul>
<li>
<p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
</li>
<li>
<p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p>
</li>
<li>
<p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p>
</li>
<li>
<p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p>
</li>
<li>
<p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p>
</li>
<li>
<p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>
</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C">网络的网络</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#isp">ISP</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">主机之间的通信方式</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">电路交换与分组交换</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1. 电路交换</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">2. 分组交换</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#%E6%97%B6%E5%BB%B6">时延</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#1-%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">1. 排队时延</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#2-%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">2. 处理时延</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#3-%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6">3. 传输时延</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#4-%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">4. 传播时延</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#1-%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE">1. 五层协议</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#2-osi">2. OSI</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#3-tcpip">3. TCP/IP</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html#4-%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B">4. 数据在各层之间的传递过程</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#网络的网络" id="网络的网络">网络的网络</a></h1>
<p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/network-of-networks.gif" width="450"/> </div><br>
<h1><a class="header" href="#isp" id="isp">ISP</a></h1>
<p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png" width="500"/> </div><br>
<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3be42601-9d33-4d29-8358-a9d16453af93.png" width="500"/> </div><br>
<h1><a class="header" href="#主机之间的通信方式" id="主机之间的通信方式">主机之间的通信方式</a></h1>
<ul>
<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" width="240px"> </div><br>
<ul>
<li>对等（P2P）：不区分客户和服务器。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" width="200px"> </div><br>
<h1><a class="header" href="#电路交换与分组交换" id="电路交换与分组交换">电路交换与分组交换</a></h1>
<h2><a class="header" href="#1-电路交换" id="1-电路交换">1. 电路交换</a></h2>
<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<h2><a class="header" href="#2-分组交换" id="2-分组交换">2. 分组交换</a></h2>
<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h1><a class="header" href="#时延" id="时延">时延</a></h1>
<p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" width="380"/> </div><br>
<h2><a class="header" href="#1-排队时延" id="1-排队时延">1. 排队时延</a></h2>
<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<h2><a class="header" href="#2-处理时延" id="2-处理时延">2. 处理时延</a></h2>
<p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>
<h2><a class="header" href="#3-传输时延" id="3-传输时延">3. 传输时延</a></h2>
<p>主机或路由器传输数据帧所需要的时间。</p>
<!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(bit)}{v(bit/s)}" class="mathjax-pic"/></div> <br> -->
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png" width="150px"> </div><br>
<p>其中 l 表示数据帧的长度，v 表示传输速率。</p>
<h2><a class="header" href="#4-传播时延" id="4-传播时延">4. 传播时延</a></h2>
<p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p>
<!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(m)}{v(m/s)}" class="mathjax-pic"/></div> <br> -->
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png" width="150"> </div><br>
<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p>
<h1><a class="header" href="#计算机网络体系结构" id="计算机网络体系结构">计算机网络体系结构</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="450"/> </div><br>
<h2><a class="header" href="#1-五层协议" id="1-五层协议">1. 五层协议</a></h2>
<p>七层协议多了表示层和会话层。</p>
<ul>
<li>
<p><strong>应用层</strong>  ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p>
</li>
<li>
<p><strong>传输层</strong>  ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
</li>
<li>
<p><strong>网络层</strong>  ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</p>
</li>
<li>
<p><strong>数据链路层</strong>  ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
</li>
<li>
<p><strong>物理层</strong>  ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
</li>
</ul>
<h2><a class="header" href="#2-osi" id="2-osi">2. OSI</a></h2>
<p>其中表示层和会话层用途如下：</p>
<ul>
<li>
<p><strong>表示层</strong>  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
</li>
<li>
<p><strong>会话层</strong>  ：建立及管理会话。</p>
</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<h2><a class="header" href="#3-tcpip" id="3-tcpip">3. TCP/IP</a></h2>
<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" width="250"/> </div><br>
<h2><a class="header" href="#4-数据在各层之间的传递过程" id="4-数据在各层之间的传递过程">4. 数据在各层之间的传递过程</a></h2>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E4%B8%80io-%E6%A8%A1%E5%9E%8B">一、I/O 模型</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E9%98%BB%E5%A1%9E%E5%BC%8F-io">阻塞式 I/O</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-io">非阻塞式 I/O</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#io-%E5%A4%8D%E7%94%A8">I/O 复用</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-io">信号驱动 I/O</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E5%BC%82%E6%AD%A5-io">异步 I/O</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E4%BA%94%E5%A4%A7-io-%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83">五大 I/O 模型比较</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E4%BA%8Cio-%E5%A4%8D%E7%94%A8">二、I/O 复用</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#select">select</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#poll">poll</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E6%AF%94%E8%BE%83">比较</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#epoll">epoll</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">工作模式</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一io-模型" id="一io-模型">一、I/O 模型</a></h1>
<p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ul>
<h2><a class="header" href="#阻塞式-io" id="阻塞式-io">阻塞式 I/O</a></h2>
<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<pre><code class="language-c">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928416812_4.png"/> </div><br>
<h2><a class="header" href="#非阻塞式-io" id="非阻塞式-io">非阻塞式 I/O</a></h2>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929000361_5.png"/> </div><br>
<h2><a class="header" href="#io-复用" id="io-复用">I/O 复用</a></h2>
<p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929444818_6.png"/> </div><br>
<h2><a class="header" href="#信号驱动-io" id="信号驱动-io">信号驱动 I/O</a></h2>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929553651_7.png"/> </div><br>
<h2><a class="header" href="#异步-io" id="异步-io">异步 I/O</a></h2>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492930243286_8.png"/> </div><br>
<h2><a class="header" href="#五大-io-模型比较" id="五大-io-模型比较">五大 I/O 模型比较</a></h2>
<ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I/O：第二阶段应用进程不会阻塞。</li>
</ul>
<p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928105791_3.png"/> </div><br>
<h1><a class="header" href="#二io-复用" id="二io-复用">二、I/O 复用</a></h1>
<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h2><a class="header" href="#select" id="select">select</a></h2>
<pre><code class="language-c">int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<ul>
<li>
<p>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</p>
</li>
<li>
<p>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</p>
</li>
<li>
<p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p>
</li>
</ul>
<pre><code class="language-c">fd_set fd_in, fd_out;
struct timeval tv;

// Reset the sets
FD_ZERO( &amp;fd_in );
FD_ZERO( &amp;fd_out );

// Monitor sock1 for input events
FD_SET( sock1, &amp;fd_in );

// Monitor sock2 for output events
FD_SET( sock2, &amp;fd_out );

// Find out which socket has the largest numeric value as select requires it
int largest_sock = sock1 &gt; sock2 ? sock1 : sock2;

// Wait up to 10 seconds
tv.tv_sec = 10;
tv.tv_usec = 0;

// Call the select
int ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv );

// Check if select actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    if ( FD_ISSET( sock1, &amp;fd_in ) )
        // input event on sock1

    if ( FD_ISSET( sock2, &amp;fd_out ) )
        // output event on sock2
}
</code></pre>
<h2><a class="header" href="#poll" id="poll">poll</a></h2>
<pre><code class="language-c">int poll(struct pollfd *fds, unsigned int nfds, int timeout);
</code></pre>
<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>
<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<pre><code class="language-c">struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };
</code></pre>
<pre><code class="language-c">// The structure for two events
struct pollfd fds[2];

// Monitor sock1 for input
fds[0].fd = sock1;
fds[0].events = POLLIN;

// Monitor sock2 for output
fds[1].fd = sock2;
fds[1].events = POLLOUT;

// Wait 10 seconds
int ret = poll( &amp;fds, 2, 10000 );
// Check if poll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // If we detect the event, zero it out so we can reuse the structure
    if ( fds[0].revents &amp; POLLIN )
        fds[0].revents = 0;
        // input event on sock1

    if ( fds[1].revents &amp; POLLOUT )
        fds[1].revents = 0;
        // output event on sock2
}
</code></pre>
<h2><a class="header" href="#比较-1" id="比较-1">比较</a></h2>
<h3><a class="header" href="#1-功能" id="1-功能">1. 功能</a></h3>
<p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<h3><a class="header" href="#2-速度" id="2-速度">2. 速度</a></h3>
<p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<h3><a class="header" href="#3-可移植性" id="3-可移植性">3. 可移植性</a></h3>
<p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h2><a class="header" href="#epoll" id="epoll">epoll</a></h2>
<pre><code class="language-c">int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
</code></pre>
<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<pre><code class="language-c">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.
// The function argument is ignored (it was not before, but now it is), so put your favorite number here
int pollingfd = epoll_create( 0xCAFE );

if ( pollingfd &lt; 0 )
 // report error

// Initialize the epoll structure in case more members are added in future
struct epoll_event ev = { 0 };

// Associate the connection class instance with the event. You can associate anything
// you want, epoll does not use this information. We store a connection class pointer, pConnection1
ev.data.ptr = pConnection1;

// Monitor for input, and do not automatically rearm the descriptor after the event
ev.events = EPOLLIN | EPOLLONESHOT;
// Add the descriptor into the monitoring list. We can do it even if another thread is
// waiting in epoll_wait - the descriptor will be properly added
if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 )
    // report error

// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)
struct epoll_event pevents[ 20 ];

// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array
int ready = epoll_wait( pollingfd, pevents, 20, 10000 );
// Check if epoll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // Check if any events detected
    for ( int i = 0; i &lt; ret; i++ )
    {
        if ( pevents[i].events &amp; EPOLLIN )
        {
            // Get back our connection pointer
            Connection * c = (Connection*) pevents[i].data.ptr;
            c-&gt;handleReadEvent();
         }
    }
}
</code></pre>
<h2><a class="header" href="#工作模式" id="工作模式">工作模式</a></h2>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<h3><a class="header" href="#1-lt-模式" id="1-lt-模式">1. LT 模式</a></h3>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<h3><a class="header" href="#2-et-模式" id="2-et-模式">2. ET 模式</a></h3>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h2><a class="header" href="#应用场景" id="应用场景">应用场景</a></h2>
<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<h3><a class="header" href="#1-select-应用场景" id="1-select-应用场景">1. select 应用场景</a></h3>
<p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h3><a class="header" href="#2-poll-应用场景" id="2-poll-应用场景">2. poll 应用场景</a></h3>
<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h3><a class="header" href="#3-epoll-应用场景" id="3-epoll-应用场景">3. epoll 应用场景</a></h3>
<p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<h1><a class="header" href="#参考资料-8" id="参考资料-8">参考资料</a></h1>
<ul>
<li>Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.</li>
<li>http://man7.org/linux/man-pages/man2/select.2.html</li>
<li>http://man7.org/linux/man-pages/man2/poll.2.html</li>
<li><a href="https://www.ibm.com/developerworks/linux/library/l-async/">Boost application performance using asynchronous I/O</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85).aspx">Synchronous and Asynchronous I/O</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859">Linux IO 模式及 select、poll、epoll 详解</a></li>
<li><a href="https://daniel.haxx.se/docs/poll-vs-select.html">poll vs select vs event-based</a></li>
<li><a href="http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/">select / poll / epoll: practical difference for system architects</a></li>
<li><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/">Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online</a></li>
</ul>
<h1><a class="header" href="#tcp与udp基本区别" id="tcp与udp基本区别">TCP与UDP基本区别</a></h1>
<p>1.基于连接与无连接
2.TCP要求系统资源较多，UDP较少； 
3.UDP程序结构较简单 
4.流模式（TCP）与数据报模式(UDP); 
5.TCP保证数据正确性，UDP可能丢包 
6.TCP保证数据顺序，UDP不保证 </p>
<h1><a class="header" href="#udp应用场景" id="udp应用场景">UDP应用场景</a></h1>
<p>1.面向数据报方式
2.网络数据大多为短消息 
3.拥有大量Client
4.对数据安全性无特殊要求
5.网络负担非常重，但对响应速度要求高
 </p>
<h1><a class="header" href="#具体编程时的区别" id="具体编程时的区别">具体编程时的区别</a></h1>
<p>1.socket()的参数不同 
2.UDP Server不需要调用listen和accept 
3.UDP收发数据用sendto/recvfrom函数 
4.TCP：地址信息在connect/accept时确定 
5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息 
6.UDP：shutdown函数无效
 </p>
<h1><a class="header" href="#编程区别" id="编程区别">编程区别</a></h1>
<p>通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。 <br />
SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。 </p>
<p>而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。 </p>
<p>基于上述不同，UDP和TCP编程步骤也有些不同，如下：</p>
<p>TCP: 
TCP编程的服务器端一般步骤是： 
1、创建一个socket，用函数socket()； 
2、设置socket属性，用函数setsockopt(); * 可选 
3、绑定IP地址、端口等信息到socket上，用函数bind(); 
4、开启监听，用函数listen()； 
5、接收客户端上来的连接，用函数accept()； 
6、收发数据，用函数send()和recv()，或者read()和write(); 
7、关闭网络连接； 
8、关闭监听； </p>
<p>TCP编程的客户端一般步骤是： 
1、创建一个socket，用函数socket()； 
2、设置socket属性，用函数setsockopt();* 可选 
3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
4、设置要连接的对方的IP地址和端口等属性； 
5、连接服务器，用函数connect()； 
6、收发数据，用函数send()和recv()，或者read()和write(); 
7、关闭网络连接；</p>
<p>UDP:
与之对应的UDP编程步骤要简单许多，分别如下： 
　　UDP编程的服务器端一般步骤是： 
1、创建一个socket，用函数socket()； 
2、设置socket属性，用函数setsockopt();* 可选 
3、绑定IP地址、端口等信息到socket上，用函数bind(); 
4、循环接收数据，用函数recvfrom(); 
5、关闭网络连接； </p>
<p>UDP编程的客户端一般步骤是： 
1、创建一个socket，用函数socket()； 
2、设置socket属性，用函数setsockopt();* 可选 
3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
4、设置对方的IP地址和端口等属性; 
5、发送数据，用函数sendto(); 
6、关闭网络连接；</p>
<p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>UDP补充：
   UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。</p>
<p>TCP补充：
  TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<p>TCP与UDP区别总结：
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<h1><a class="header" href="#三次握手建立连接四次挥手关闭连接" id="三次握手建立连接四次挥手关闭连接">三次握手建立连接，四次挥手关闭连接</a></h1>
<p>建立连接：服务端处于监听状态。客户端说：我想跟你聊聊。服务器说：好呀。客户端说：那我开始说了。<br />
关闭连接：服务端和客户端都可以选择关闭连接。</p>
<ul>
<li>我没话可说了，今天就聊到这里吧。</li>
<li>可以呀。</li>
<li>再见</li>
<li>好的，再见</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">通信方式</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html#%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6">带通调制</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#通信方式" id="通信方式">通信方式</a></h1>
<p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h1><a class="header" href="#带通调制" id="带通调制">带通调制</a></h1>
<p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c34f4503-f62c-4043-9dc6-3e03288657df.jpg" width="500"/> </div><br>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">基本问题</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#1-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">1. 封装成帧</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#2-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">2. 透明传输</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3. 差错检测</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#%E4%BF%A1%E9%81%93%E5%88%86%E7%B1%BB">信道分类</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#1-%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">1. 广播信道</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#2-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">2. 点对点信道</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#1-%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8">1. 频分复用</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#2-%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">2. 时分复用</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#3-%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">3. 统计时分复用</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#4-%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8">4. 波分复用</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#5-%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8">5. 码分复用</a></li>
</ul>
</li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#csmacd-%E5%8D%8F%E8%AE%AE">CSMA/CD 协议</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#ppp-%E5%8D%8F%E8%AE%AE">PPP 协议</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#mac-%E5%9C%B0%E5%9D%80">MAC 地址</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#%E4%BA%A4%E6%8D%A2%E6%9C%BA">交换机</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">虚拟局域网</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#基本问题" id="基本问题">基本问题</a></h1>
<h2><a class="header" href="#1-封装成帧" id="1-封装成帧">1. 封装成帧</a></h2>
<p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" width="300"/> </div><br>
<h2><a class="header" href="#2-透明传输" id="2-透明传输">2. 透明传输</a></h2>
<p>透明表示一个实际存在的事物看起来好像不存在一样。</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" width="500"/> </div><br>
<h2><a class="header" href="#3-差错检测" id="3-差错检测">3. 差错检测</a></h2>
<p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p>
<h1><a class="header" href="#信道分类" id="信道分类">信道分类</a></h1>
<h2><a class="header" href="#1-广播信道" id="1-广播信道">1. 广播信道</a></h2>
<p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>
<h2><a class="header" href="#2-点对点信道" id="2-点对点信道">2. 点对点信道</a></h2>
<p>一对一通信。</p>
<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>
<h1><a class="header" href="#信道复用技术" id="信道复用技术">信道复用技术</a></h1>
<h2><a class="header" href="#1-频分复用" id="1-频分复用">1. 频分复用</a></h2>
<p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" width="350"/> </div><br>
<h2><a class="header" href="#2-时分复用" id="2-时分复用">2. 时分复用</a></h2>
<p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" width="350"/> </div><br>
<p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p>
<h2><a class="header" href="#3-统计时分复用" id="3-统计时分复用">3. 统计时分复用</a></h2>
<p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png" width="350"/> </div><br>
<h2><a class="header" href="#4-波分复用" id="4-波分复用">4. 波分复用</a></h2>
<p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
<h2><a class="header" href="#5-码分复用" id="5-码分复用">5. 码分复用</a></h2>
<p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}" class="mathjax-pic"/> 和 <img src="https://latex.codecogs.com/gif.latex?\vec{T}" class="mathjax-pic"/> 有</p>
<!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{T}=0" class="mathjax-pic"/></div> <br> -->
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png" width="100px"> </div><br>
<p>为了讨论方便，取 m=8，设码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}" class="mathjax-pic"/> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>
<!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S}=1" class="mathjax-pic"/></div> <br> -->
<!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S'}=-1" class="mathjax-pic"/></div> <br> -->
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png" width="100px"> </div><br>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png" width="125px"> </div><br>
<p>其中 <img src="https://latex.codecogs.com/gif.latex?\vec{S'}" class="mathjax-pic"/> 为 <img src="https://latex.codecogs.com/gif.latex?\vec{S}" class="mathjax-pic"/> 的反码。</p>
<p>利用上面的式子我们知道，当接收端使用码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}" class="mathjax-pic"/> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p>
<p>码分复用需要发送的数据量为原先的 m 倍。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" width="500px"> </div><br>
<h1><a class="header" href="#csmacd-协议" id="csmacd-协议">CSMA/CD 协议</a></h1>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/19d423e9-74f7-4c2b-9b97-55890e0d5193.png" width="400"/> </div><br>
<h1><a class="header" href="#ppp-协议" id="ppp-协议">PPP 协议</a></h1>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg" width="300"/> </div><br>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/759013d7-61d8-4509-897a-d75af598a236.png" width="400"/> </div><br>
<h1><a class="header" href="#mac-地址" id="mac-地址">MAC 地址</a></h1>
<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h1><a class="header" href="#局域网" id="局域网">局域网</a></h1>
<p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>
<p>可以按照网络拓扑结构对局域网进行分类：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg" width="800"/> </div><br>
<h1><a class="header" href="#以太网" id="以太网">以太网</a></h1>
<p>以太网是一种星型拓扑结构局域网。</p>
<p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p>
<p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p>
<p>以太网帧格式：</p>
<ul>
<li><strong>类型</strong>  ：标记上层使用的协议；</li>
<li><strong>数据</strong>  ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li><strong>FCS</strong>  ：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png" width="500"/> </div><br>
<h1><a class="header" href="#交换机" id="交换机">交换机</a></h1>
<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" width="800"/> </div><br>
<h1><a class="header" href="#虚拟局域网" id="虚拟局域网">虚拟局域网</a></h1>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" width="500"/> </div><br>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9">UDP 和 TCP 的特点</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">UDP 首部格式</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP 首部格式</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP 的三次握手</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 的四次挥手</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 滑动窗口</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a>
<ul>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#1-%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">1. 慢开始与拥塞避免</a></li>
<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html#2-%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">2. 快重传与快恢复</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<h1><a class="header" href="#udp-和-tcp-的特点" id="udp-和-tcp-的特点">UDP 和 TCP 的特点</a></h1>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
</ul>
<h1><a class="header" href="#udp-首部格式" id="udp-首部格式">UDP 首部格式</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"/> </div><br>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h1><a class="header" href="#tcp-首部格式" id="tcp-首部格式">TCP 首部格式</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"/> </div><br>
<ul>
<li>
<p><strong>序号</strong>   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认号</strong>   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p><strong>数据偏移</strong>   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li>
<p><strong>确认 ACK</strong>   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong>   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li>
<p><strong>终止 FIN</strong>   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li>
<p><strong>窗口</strong>   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h1><a class="header" href="#tcp-的三次握手" id="tcp-的三次握手">TCP 的三次握手</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"/> </div><br>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li>
<p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
</li>
<li>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
</li>
<li>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
</li>
<li>
<p>B 收到 A 的确认后，连接建立。</p>
</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h1><a class="header" href="#tcp-的四次挥手" id="tcp-的四次挥手">TCP 的四次挥手</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"/> </div><br>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>
<p>A 发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p>
</li>
<li>
<p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
</li>
<li>
<p>B 收到 A 的确认后释放连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>
<p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
<h1><a class="header" href="#tcp-可靠传输" id="tcp-可靠传输">TCP 可靠传输</a></h1>
<p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT" class="mathjax-pic"/></div> <br>
其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d" class="mathjax-pic"/></div> <br>
其中 RTT<sub>d</sub> 为偏差的加权平均值。
<h1><a class="header" href="#tcp-滑动窗口" id="tcp-滑动窗口">TCP 滑动窗口</a></h1>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"/> </div><br>
<h1><a class="header" href="#tcp-流量控制" id="tcp-流量控制">TCP 流量控制</a></h1>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h1><a class="header" href="#tcp-拥塞控制" id="tcp-拥塞控制">TCP 拥塞控制</a></h1>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"/> </div><br>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"/> </div><br>
<h2><a class="header" href="#1-慢开始与拥塞避免" id="1-慢开始与拥塞避免">1. 慢开始与拥塞避免</a></h2>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<h2><a class="header" href="#2-快重传与快恢复" id="2-快重传与快恢复">2. 快重传与快恢复</a></h2>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"/> </div><br>
<h1><a class="header" href="#目录-10" id="目录-10">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<p>微服务包括两大部分：服务治理与服务实现。</p>
<h1><a class="header" href="#微服务的优点" id="微服务的优点">微服务的优点</a></h1>
<ul>
<li>
<p>独立开发  – 所有微服务都可以根据各自的功能轻松开发</p>
</li>
<li>
<p>独立部署  – 基于其服务，可以在任何应用程序中单独部署它们</p>
</li>
<li>
<p>故障隔离  – 即使应用程序的一项服务不起作用，系统仍可继续运行</p>
</li>
<li>
<p>混合技术堆栈  – 可以使用不同的语言和技术来构建同一应用程序的不同服务</p>
</li>
<li>
<p>粒度缩放  – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起</p>
</li>
<li>
<p>解耦  – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展</p>
</li>
<li>
<p>组件化  – 微服务被视为可以轻松更换和升级的独立组件</p>
</li>
<li>
<p>业务能力  – 微服务非常简单，专注于单一功能</p>
</li>
<li>
<p>自治  – 开发人员和团队可以彼此独立工作，从而提高速度</p>
</li>
<li>
<p>持续交付  – 通过软件创建，测试和批准的系统自动化，允许频繁发布软件</p>
</li>
<li>
<p>责任  – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品</p>
</li>
<li>
<p>分散治理  – 重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</p>
</li>
<li>
<p>敏捷  – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃</p>
</li>
</ul>
<p>Spring Cloud和Dubbo是两大主流微服务框架，前者是Spring公司的产品，后者是阿里巴巴的产品。Spring Cloud基于HTTP调用，Dubbo基于RPC进行调用。</p>
<p>Spring Cloud是服务治理相关的一套体系，Spring Boot是实现单个服务的库，Spring Cloud包括Spring Boot。</p>
<h1><a class="header" href="#熔断和降级" id="熔断和降级">熔断和降级</a></h1>
<ul>
<li>熔断机制：熔断机制应对雪崩效应的一种微服务链路保护机制，目的是防止单个服务挂掉影响大量的其它服务。当查出链路中的某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常时则恢复调用链路。在SpringCloud 框架里熔断机制通过 Hystrix 实现，Hystrix 会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</li>
<li>服务降级：一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback 回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。</li>
</ul>
<h1><a class="header" href="#微服务的优点和缺点" id="微服务的优点和缺点">微服务的优点和缺点</a></h1>
<h2><a class="header" href="#优点" id="优点">优点：</a></h2>
<p>【1】每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求。
【2】开发简单，开发效率提高，一个服务可能就是专一的只干一件事。
【3】微服务能够被小团队开发，这个团队可以是2到5个开发人员组成。
【4】微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
【5】微服务能使用不同的语言开发。
【6】易于第三方集成，微服务允许使用容易且灵活的方式集成自动部署，通过持续集成集成工具，如Jenkins、Hudson等。
【7】微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作体现价值。
【8】微服务允许你融合最新技术。
【9】微服务知识业务逻辑代码，不会和 HTML 和 CSS 其他界面组件混合。
【10】每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库。</p>
<h2><a class="header" href="#缺点" id="缺点">缺点：</a></h2>
<p>【1】开发人员要处理分布式系统的复杂性。
【2】多服务运维难度，随着服务的增加，运维的压力也在增加。
【3】系统部署依赖。
【4】服务间通讯成本。
【5】数据一致性。
【6】系统集成测试。
【7】性能监控。</p>
<h1><a class="header" href="#微服务包括的内容及其相关技术" id="微服务包括的内容及其相关技术">微服务包括的内容及其相关技术</a></h1>
<ul>
<li>服务开发	SpringBoot、Spring、SpringMVC	 </li>
<li>服务配置管理	Netfilx公司的Archaius、阿里的Diamond等	 </li>
<li>服务注册与发现	Eureka、Consul、Zookeeper	 </li>
<li>服务调用	RPC、Rest、gRPC、thrift	 </li>
<li>服务熔断器	Hystrix、Envoy等	 </li>
<li>负载均衡	Nginx、Ribbon	 </li>
<li>服务接口调用（客户端调用服务的简化工具）	Feign等	 </li>
<li>消息队列	Kafka、RabbitMQ、ActiveMQ等	 </li>
<li>服务配置中心管理	SpringCloudConfig、Chef等	 </li>
<li>服务路由（API网关）	Zuul等	 </li>
<li>服务监控	Zabbix、Naggios、Metrics、Spectator等	 </li>
<li>全链路追踪	Zipkin、Brave、Dapper等	 </li>
<li>服务部署	Docker、OpenStack、Kubernetes等	 </li>
<li>数据流操作开发包	SpringCloud Stream	 </li>
<li>事件消息总线	Spring Cloud Bus</li>
</ul>
<h1><a class="header" href="#垃圾回收机制" id="垃圾回收机制">垃圾回收机制：</a></h1>
<p>Python的垃圾回收机制以引用计数为主， 标记清除、分代回收为辅。引用计数指：Python在内部维护了针对每一个对象的引用计数， 当一个对象创建或者被引用时，其引用计数将加1，当一个对象被销毁或作用域失效时， 其引用计数将减1。只有对象的引用计数为0时，这个对象将会被回收。引用计数的优点：简单、具有实时性。缺点：对象循环引用时将永远不会被销毁。对于对象循环引用的状况Python使用标记清除来解决，Python在内部实现了一个循环检测器， 不停的检测对象是否存在循环引用，如果两个对象互相循环引用并且不包含其他第三者对象时， 其将会被收回。在Python参考手册中有写道：
当一个对象无法获取时， 那么这个对象有可能被当成垃圾销毁了。Python将所有对象分成了三代， 对象存活时间越长就越晚被回收， 反之则越早被回收。
内存管理：
Python使用了内存池机制来管理内存，其内存以金字塔的形式对内存功能进行划分，-1、-2层主要用于对操作系统进行操作， 0层中是C的malloc,、free等等内存分配和释放函数。1、2层是一个内存池， 当对象小于265K时将直接由这片内存池进行分配内存，否则将调用第0层中的C函数来分配内存，当小于265K的对象被销毁时， 其内存也不会被销毁， 只是返回给了内存池以便二次利用。2层是对Python对象进行操作。</p>
<h1><a class="header" href="#十六分布式理论" id="十六分布式理论">十六、分布式理论</a></h1>
<ul>
<li>谈一下你对 CAP 的认识？</li>
<li>什么是 Base 理论？</li>
<li>两阶段提交和三阶段提交的过程？两阶段提交有什么问题？三阶段提交有什么问题？</li>
<li>分布式事务常用的解决方案有哪些？</li>
<li>说一下你对 TCC 模式的理解？</li>
<li>多系统之间怎么实现通信的？A系统→B系统的服务</li>
<li>Solr集群的搭建</li>
<li>请你谈谈对MQ的理解？以及你们在项目中是怎么用的？</li>
<li>请你谈谈单点登录的实现方案？你们怎么包括cookie的安全性？跨域取* cookie的问题，你们怎么解决的？</li>
<li>请你谈谈购物车的实现方案？当商品信息发生变更，购物车中的商品信息是否可以同步到变化？</li>
<li>谈谈你对ThreadLocal的理解，以及他的作用</li>
<li>什么是幂等性？</li>
<li>分布式锁的实现形式？</li>
<li>分布式锁应该具备哪些条件？</li>
<li>分布式Session的几种实现方式</li>
</ul>
<h2><a class="header" href="#paxos-算法" id="paxos-算法">Paxos 算法</a></h2>
<ul>
<li>说一下你对 ZAB 协议的理解？</li>
<li>什么是分布式锁？</li>
<li>分布式锁应该具备哪些功能？</li>
<li>分布式锁的实现方式有哪些？</li>
</ul>
<h1><a class="header" href="#算法" id="算法">算法</a></h1>
<ul>
<li>100亿数字，怎么统计前100大的？</li>
<li>10亿个url，每个url大小小于56B，要求去重，内存4G。</li>
<li>1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。</li>
<li>Q1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何统计词频？</li>
<li>Q2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？</li>
<li>Q3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）</li>
<li>一个大文件A和一个小文件B，里面存的是单词，要求出在文件B中但不在文件A中的单词。然后大文件A是无法直接存到内存中的。</li>
<li>一道题目是如果有一个人注册一个qq，如何保证这个qq号码和之前已存在的qq号码不重复呢？</li>
<li>扔硬币，连续出现两次正面即结束，问扔的次数期望</li>
<li>有100W个集合，每个集合中的word是同义词，同义词具有传递性， 比如集合1中有word a, 集合2中也有word a, 则集合1，2中所有词都是同义词，对这100W个集合进行归并，同义词都在一个集合当中。</li>
<li>有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决；</li>
<li>海量数据的topk问题。</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E4%BA%8C%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6">二、匹配单个字符</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E4%B8%89%E5%8C%B9%E9%85%8D%E4%B8%80%E7%BB%84%E5%AD%97%E7%AC%A6">三、匹配一组字符</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6">四、使用元字符</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E4%BA%94%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D">五、重复匹配</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E5%85%AD%E4%BD%8D%E7%BD%AE%E5%8C%B9%E9%85%8D">六、位置匹配</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E4%B8%83%E4%BD%BF%E7%94%A8%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">七、使用子表达式</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E5%85%AB%E5%9B%9E%E6%BA%AF%E5%BC%95%E7%94%A8">八、回溯引用</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E4%B9%9D%E5%89%8D%E5%90%8E%E6%9F%A5%E6%89%BE">九、前后查找</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E5%8D%81%E5%B5%8C%E5%85%A5%E6%9D%A1%E4%BB%B6">十、嵌入条件</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一概述-1" id="一概述-1">一、概述</a></h1>
<p>正则表达式用于文本内容的查找和替换。</p>
<p>正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。</p>
<p><a href="https://regexr.com/">正则表达式在线工具</a></p>
<h1><a class="header" href="#二匹配单个字符" id="二匹配单个字符">二、匹配单个字符</a></h1>
<p><strong>.</strong>   可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；</p>
<p><strong>.</strong>   是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。</p>
<p>正则表达式一般是区分大小写的，但也有些实现不区分。</p>
<p><strong>正则表达式</strong></p>
<pre><code>C.C2018
</code></pre>
<p><strong>匹配结果</strong></p>
<p>My name is   <strong>CyC2018</strong>  .</p>
<h1><a class="header" href="#三匹配一组字符" id="三匹配一组字符">三、匹配一组字符</a></h1>
<p><strong>[ ]</strong>   定义一个字符集合；</p>
<p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。</p>
<p><strong>-</strong>   只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p>
<p><strong>^</strong>   在 [ ] 中是取非操作。</p>
<p><strong>应用</strong></p>
<p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串：</p>
<p><strong>正则表达式</strong></p>
<pre><code>abc[^0-9]
</code></pre>
<p><strong>匹配结果</strong></p>
<ol>
<li><strong>abcd</strong></li>
<li>abc1</li>
<li>abc2</li>
</ol>
<h1><a class="header" href="#四使用元字符" id="四使用元字符">四、使用元字符</a></h1>
<h2><a class="header" href="#匹配空白字符" id="匹配空白字符">匹配空白字符</a></h2>
<table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">[\b]</td><td align="center">回退（删除）一个字符</td></tr>
<tr><td align="center">\f</td><td align="center">换页符</td></tr>
<tr><td align="center">\n</td><td align="center">换行符</td></tr>
<tr><td align="center">\r</td><td align="center">回车符</td></tr>
<tr><td align="center">\t</td><td align="center">制表符</td></tr>
<tr><td align="center">\v</td><td align="center">垂直制表符</td></tr>
</tbody></table>
<p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。</p>
<p>\r\n\r\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行；</p>
<h2><a class="header" href="#匹配特定的字符" id="匹配特定的字符">匹配特定的字符</a></h2>
<h3><a class="header" href="#1-数字元字符" id="1-数字元字符">1. 数字元字符</a></h3>
<table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">\d</td><td align="center">数字字符，等价于 [0-9]</td></tr>
<tr><td align="center">\D</td><td align="center">非数字字符，等价于 <sup class="footnote-reference"><a href="#0-9">1</a></sup></td></tr>
</tbody></table>
<h3><a class="header" href="#2-字母数字元字符" id="2-字母数字元字符">2. 字母数字元字符</a></h3>
<table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">\w</td><td align="center">大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td></tr>
<tr><td align="center">\W</td><td align="center">对 \w 取非</td></tr>
</tbody></table>
<h3><a class="header" href="#3-空白字符元字符" id="3-空白字符元字符">3. 空白字符元字符</a></h3>
<table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">\s</td><td align="center">任何一个空白字符，等价于 [\f\n\r\t\v]</td></tr>
<tr><td align="center">\S</td><td align="center">对 \s 取非</td></tr>
</tbody></table>
<p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n。</p>
<h1><a class="header" href="#五重复匹配" id="五重复匹配">五、重复匹配</a></h1>
<ul>
<li><strong>+</strong>   匹配 1 个或者多个字符</li>
<li>*<em>*</em>  * 匹配 0 个或者多个字符</li>
<li><strong>?</strong>   匹配 0 个或者 1 个字符</li>
</ul>
<p><strong>应用</strong></p>
<p>匹配邮箱地址。</p>
<p><strong>正则表达式</strong></p>
<pre><code>[\w.]+@\w+\.\w+
</code></pre>
<p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p>
<p><strong>匹配结果</strong></p>
<p><strong>abc.def<span>@</span>qq.com</strong></p>
<ul>
<li><strong>{n}</strong>   匹配 n 个字符</li>
<li><strong>{m,n}</strong>   匹配 m~n 个字符</li>
<li><strong>{m,}</strong>   至少匹配 m 个字符</li>
</ul>
<p>* 和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m,n}? 。</p>
<p><strong>正则表达式</strong></p>
<pre><code>a.+c
</code></pre>
<p><strong>匹配结果</strong></p>
<p><strong>abcabcabc</strong></p>
<p>由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。</p>
<h1><a class="header" href="#六位置匹配" id="六位置匹配">六、位置匹配</a></h1>
<h2><a class="header" href="#单词边界" id="单词边界">单词边界</a></h2>
<p><strong>\b</strong>   可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。</p>
<p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p>
<h2><a class="header" href="#字符串边界" id="字符串边界">字符串边界</a></h2>
<p><strong>^</strong>   匹配整个字符串的开头，<strong>$</strong> 匹配结尾。</p>
<p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p>
<p>分行匹配模式（multiline）下，换行被当做字符串的边界。</p>
<p><strong>应用</strong></p>
<p>匹配代码中以 // 开始的注释行</p>
<p><strong>正则表达式</strong></p>
<pre><code>^\s*\/\/.*$
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/600e9c75-5033-4dad-ae2b-930957db638e.png"/> </div><br>
<p><strong>匹配结果</strong></p>
<ol>
<li>public void fun() {</li>
<li>          <strong>// 注释 1</strong></li>
<li>        int a = 1;</li>
<li>        int b = 2;</li>
<li>          <strong>// 注释 2</strong></li>
<li>        int c = a + b;</li>
<li>}</li>
</ol>
<h1><a class="header" href="#七使用子表达式" id="七使用子表达式">七、使用子表达式</a></h1>
<p>使用   <strong>( )</strong>   定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p>
<p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p>
<p><strong>正则表达式</strong></p>
<pre><code>(ab){2,}
</code></pre>
<p><strong>匹配结果</strong></p>
<p><strong>ababab</strong></p>
<p><strong>|</strong>   是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。</p>
<p><strong>正则表达式</strong></p>
<pre><code>(19|20)\d{2}
</code></pre>
<p><strong>匹配结果</strong></p>
<ol>
<li><strong>1900</strong></li>
<li><strong>2010</strong></li>
<li>1020</li>
</ol>
<p><strong>应用</strong></p>
<p>匹配 IP 地址。</p>
<p>IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：</p>
<ul>
<li>一位数字</li>
<li>不以 0 开头的两位数字</li>
<li>1 开头的三位数</li>
<li>2 开头，第 2 位是 0-4 的三位数</li>
<li>25 开头，第 3 位是 0-5 的三位数</li>
</ul>
<p><strong>正则表达式</strong></p>
<pre><code>((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
</code></pre>
<p><strong>匹配结果</strong></p>
<ol>
<li><strong>192.168.0.1</strong></li>
<li>00.00.00.00</li>
<li>555.555.555.555</li>
</ol>
<h1><a class="header" href="#八回溯引用" id="八回溯引用">八、回溯引用</a></h1>
<p>回溯引用使用   <strong>\n</strong>   来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p>
<p><strong>应用</strong></p>
<p>匹配 HTML 中合法的标题元素。</p>
<p><strong>正则表达式</strong></p>
<p>\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。</p>
<pre><code>&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;
</code></pre>
<p><strong>匹配结果</strong></p>
<ol>
<li><strong>&lt;h1&gt;x&lt;/h1&gt;</strong></li>
<li><strong>&lt;h2&gt;x&lt;/h2&gt;</strong></li>
<li>&lt;h3&gt;x&lt;/h1&gt;</li>
</ol>
<h2><a class="header" href="#替换" id="替换">替换</a></h2>
<p>需要用到两个正则表达式。</p>
<p><strong>应用</strong></p>
<p>修改电话号码格式。</p>
<p><strong>文本</strong></p>
<p>313-555-1234</p>
<p><strong>查找正则表达式</strong></p>
<pre><code>(\d{3})(-)(\d{3})(-)(\d{4})
</code></pre>
<p><strong>替换正则表达式</strong></p>
<p>在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p>
<pre><code>($1) $3-$5
</code></pre>
<p><strong>结果</strong></p>
<p>(313) 555-1234</p>
<h2><a class="header" href="#大小写转换" id="大小写转换">大小写转换</a></h2>
<table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody>
<tr><td align="center">\l</td><td align="center">把下个字符转换为小写</td></tr>
<tr><td align="center">\u</td><td align="center">把下个字符转换为大写</td></tr>
<tr><td align="center">\L</td><td align="center">把\L 和\E 之间的字符全部转换为小写</td></tr>
<tr><td align="center">\U</td><td align="center">把\U 和\E 之间的字符全部转换为大写</td></tr>
<tr><td align="center">\E</td><td align="center">结束\L 或者\U</td></tr>
</tbody></table>
<p><strong>应用</strong></p>
<p>把文本的第二个和第三个字符转换为大写。</p>
<p><strong>文本</strong></p>
<p>abcd</p>
<p><strong>查找</strong></p>
<pre><code>(\w)(\w{2})(\w)
</code></pre>
<p><strong>替换</strong></p>
<pre><code>$1\U$2\E$3
</code></pre>
<p><strong>结果</strong></p>
<p>aBCd</p>
<h1><a class="header" href="#九前后查找" id="九前后查找">九、前后查找</a></h1>
<p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。</p>
<p>向前查找使用   <strong>?=</strong>   定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。</p>
<p><strong>应用</strong></p>
<p>查找出邮件地址 @ 字符前面的部分。</p>
<p><strong>正则表达式</strong></p>
<pre><code>\w+(?=@)
</code></pre>
<p><strong>结果</strong></p>
<p><strong>abc</strong>  @qq.com</p>
<p>对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。</p>
<h1><a class="header" href="#十嵌入条件" id="十嵌入条件">十、嵌入条件</a></h1>
<h2><a class="header" href="#回溯引用条件" id="回溯引用条件">回溯引用条件</a></h2>
<p>条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p>
<p><strong>正则表达式</strong></p>
<p>子表达式 (\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。</p>
<pre><code>(\()?abc(?(1)\))
</code></pre>
<p><strong>结果</strong></p>
<ol>
<li><strong>(abc)</strong></li>
<li><strong>abc</strong></li>
<li>(abc</li>
</ol>
<h2><a class="header" href="#前后查找条件" id="前后查找条件">前后查找条件</a></h2>
<p>条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。</p>
<p><strong>正则表达式</strong></p>
<p>?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。</p>
<pre><code>\d{5}(?(?=-)-\d{4})
</code></pre>
<p><strong>结果</strong></p>
<ol>
<li><strong>11111</strong></li>
<li>22222-</li>
<li><strong>33333-4444</strong></li>
</ol>
<h1><a class="header" href="#参考资料-9" id="参考资料-9">参考资料</a></h1>
<ul>
<li>BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html#%E4%B8%80%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%9C%E7%94%A8">一、构建工具的作用</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html#%E4%BA%8Cjava-%E4%B8%BB%E6%B5%81%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7">二、Java 主流构建工具</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html#%E4%B8%89maven">三、Maven</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一构建工具的作用" id="一构建工具的作用">一、构建工具的作用</a></h1>
<p>构建一个项目通常包含了依赖管理、测试、编译、打包、发布等流程，构建工具可以自动化进行这些操作，从而为我们减少这些繁琐的工作。</p>
<p>其中构建工具提供的依赖管理能够可以自动处理依赖关系。例如一个项目需要用到依赖 A，A 又依赖于 B，那么构建工具就能帮我们导入 B，而不需要我们手动去寻找并导入。</p>
<p>在 Java 项目中，打包流程通常是将项目打包成 Jar 包。在没有构建工具的情况下，我们需要使用命令行工具或者 IDE 手动打包。而发布流程通常是将 Jar 包上传到服务器上。</p>
<h1><a class="header" href="#二java-主流构建工具" id="二java-主流构建工具">二、Java 主流构建工具</a></h1>
<p>Ant 具有编译、测试和打包功能，其后出现的 Maven 在 Ant 的功能基础上又新增了依赖管理功能，而最新的 Gradle 又在 Maven 的功能基础上新增了对 Groovy 语言的支持。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208204118932.png"/> </div><br>
<p>Gradle 和 Maven 的区别是，它使用 Groovy 这种特定领域语言（DSL）来管理构建脚本，而不再使用 XML 这种标记性语言。因为项目如果庞大的话，XML 很容易就变得臃肿。</p>
<p>例如要在项目中引入 Junit，Maven 的代码如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
   &lt;groupId&gt;jizg.study.maven.hello&lt;/groupId&gt;
   &lt;artifactId&gt;hello-first&lt;/artifactId&gt;
   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

   &lt;dependencies&gt;
          &lt;dependency&gt;
               &lt;groupId&gt;junit&lt;/groupId&gt;
               &lt;artifactId&gt;junit&lt;/artifactId&gt;
               &lt;version&gt;4.10&lt;/version&gt;
               &lt;scope&gt;test&lt;/scope&gt;
          &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>而 Gradle 只需要几行代码：</p>
<pre><code class="language-java">dependencies {
    testCompile &quot;junit:junit:4.10&quot;
}
</code></pre>
<h1><a class="header" href="#三maven" id="三maven">三、Maven</a></h1>
<h2><a class="header" href="#概述-1" id="概述-1">概述</a></h2>
<p>提供了项目对象模型（POM）文件来管理项目的构建。</p>
<h2><a class="header" href="#仓库" id="仓库">仓库</a></h2>
<p>仓库的搜索顺序为：本地仓库、中央仓库、远程仓库。</p>
<ul>
<li>本地仓库用来存储项目的依赖库；</li>
<li>中央仓库是下载依赖库的默认位置；</li>
<li>远程仓库，因为并非所有的依赖库都在中央仓库，或者中央仓库访问速度很慢，远程仓库是中央仓库的补充。</li>
</ul>
<h2><a class="header" href="#pom" id="pom">POM</a></h2>
<p>POM 代表项目对象模型，它是一个 XML 文件，保存在项目根目录的 pom.xml 文件中。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>[groupId, artifactId, version, packaging, classifier] 称为一个项目的坐标，其中 groupId、artifactId、version 必须定义，packaging 可选（默认为 Jar），classifier 不能直接定义的，需要结合插件使用。</p>
<ul>
<li>groupId：项目组 Id，必须全球唯一；</li>
<li>artifactId：项目 Id，即项目名；</li>
<li>version：项目版本；</li>
<li>packaging：项目打包方式。</li>
</ul>
<h2><a class="header" href="#依赖原则" id="依赖原则">依赖原则</a></h2>
<h3><a class="header" href="#1-依赖路径最短优先原则" id="1-依赖路径最短优先原则">1. 依赖路径最短优先原则</a></h3>
<pre><code class="language-html">A -&gt; B -&gt; C -&gt; X(1.0)
A -&gt; D -&gt; X(2.0)
</code></pre>
<p>由于 X(2.0) 路径最短，所以使用 X(2.0)。</p>
<h3><a class="header" href="#2-声明顺序优先原则" id="2-声明顺序优先原则">2. 声明顺序优先原则</a></h3>
<pre><code class="language-html">A -&gt; B -&gt; X(1.0)
A -&gt; C -&gt; X(2.0)
</code></pre>
<p>在 POM 中最先声明的优先，上面的两个依赖如果先声明 B，那么最后使用 X(1.0)。</p>
<h3><a class="header" href="#3-覆写优先原则" id="3-覆写优先原则">3. 覆写优先原则</a></h3>
<p>子 POM 内声明的依赖优先于父 POM 中声明的依赖。</p>
<h2><a class="header" href="#解决依赖冲突" id="解决依赖冲突">解决依赖冲突</a></h2>
<p>找到 Maven 加载的 Jar 包版本，使用 <code>mvn dependency:tree</code> 查看依赖树，根据依赖原则来调整依赖在 POM 文件的声明顺序。</p>
<h1><a class="header" href="#参考资料-10" id="参考资料-10">参考资料</a></h1>
<ul>
<li><a href="http://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification">POM Reference</a></li>
<li><a href="https://stackoverflow.com/questions/7249871/what-is-a-build-tool">What is a build tool?</a></li>
<li><a href="https://programmingmitra.blogspot.com/2016/05/java-build-tools-comparisons-ant-vs.html">Java Build Tools Comparisons: Ant vs Maven vs Gradle</a></li>
<li><a href="http://sagioto.github.io/maven2gradle/">maven 2 gradle</a></li>
<li><a href="https://www.imooc.com/learn/833">新一代构建工具 gradle</a></li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E4%B8%80%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">一、三大特性</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E5%A4%9A%E6%80%81">多态</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E4%BA%8C%E7%B1%BB%E5%9B%BE">二、类图</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization">泛化关系 (Generalization)</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB-realization">实现关系 (Realization)</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB-aggregation">聚合关系 (Aggregation)</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-composition">组合关系 (Composition)</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-association">关联关系 (Association)</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB-dependency">依赖关系 (Dependency)</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E4%B8%89%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">三、设计原则</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#solid">S.O.L.I.D</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%88%99">其他常见原则</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一三大特性" id="一三大特性">一、三大特性</a></h1>
<h2><a class="header" href="#封装" id="封装">封装</a></h2>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<pre><code class="language-java">public class Person {

    private String name;
    private int gender;
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;
    }

    public void work() {
        if (18 &lt;= age &amp;&amp; age &lt;= 50) {
            System.out.println(name + &quot; is working very hard!&quot;);
        } else {
            System.out.println(name + &quot; can't work any more!&quot;);
        }
    }
}
</code></pre>
<h2><a class="header" href="#继承" id="继承">继承</a></h2>
<p>继承实现了   <strong>IS-A</strong>   关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为   <strong>向上转型</strong>  。</p>
<pre><code class="language-java">Animal animal = new Cat();
</code></pre>
<h2><a class="header" href="#多态" id="多态">多态</a></h2>
<p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<pre><code class="language-java">public class Instrument {

    public void play() {
        System.out.println(&quot;Instument is playing...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Wind extends Instrument {

    public void play() {
        System.out.println(&quot;Wind is playing...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Percussion extends Instrument {

    public void play() {
        System.out.println(&quot;Percussion is playing...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Music {

    public static void main(String[] args) {
        List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}
</code></pre>
<pre><code>Wind is playing...
Percussion is playing...
</code></pre>
<h1><a class="header" href="#二类图" id="二类图">二、类图</a></h1>
<p>以下类图使用 <a href="https://www.planttext.com/">PlantUML</a> 绘制，更多语法及使用请参考：http://plantuml.com/ 。</p>
<h2><a class="header" href="#泛化关系-generalization" id="泛化关系-generalization">泛化关系 (Generalization)</a></h2>
<p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" width="180px"> </div><br>
<pre><code class="language-text">@startuml

title Generalization

class Vihical
class Car
class Trunck

Vihical &lt;|-- Car
Vihical &lt;|-- Trunck

@enduml
</code></pre>
<h2><a class="header" href="#实现关系-realization" id="实现关系-realization">实现关系 (Realization)</a></h2>
<p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" width="170px"> </div><br>
<pre><code class="language-text">@startuml

title Realization

interface MoveBehavior
class Fly
class Run

MoveBehavior &lt;|.. Fly
MoveBehavior &lt;|.. Run

@enduml
</code></pre>
<h2><a class="header" href="#聚合关系-aggregation" id="聚合关系-aggregation">聚合关系 (Aggregation)</a></h2>
<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" width="300px"> </div><br>
<pre><code class="language-text">@startuml

title Aggregation

class Computer
class Keyboard
class Mouse
class Screen

Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen

@enduml
</code></pre>
<h2><a class="header" href="#组合关系-composition" id="组合关系-composition">组合关系 (Composition)</a></h2>
<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" width="280px"> </div><br>
<pre><code class="language-text">@startuml

title Composition

class Company
class DepartmentA
class DepartmentB

Company *-- DepartmentA
Company *-- DepartmentB

@enduml
</code></pre>
<h2><a class="header" href="#关联关系-association" id="关联关系-association">关联关系 (Association)</a></h2>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" width="200px"> </div><br>
<pre><code class="language-text">@startuml

title Association

class School
class Student

School &quot;1&quot; - &quot;n&quot; Student

@enduml
</code></pre>
<h2><a class="header" href="#依赖关系-dependency" id="依赖关系-dependency">依赖关系 (Dependency)</a></h2>
<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法的参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" width="330px"> </div><br>
<pre><code class="language-text">@startuml

title Dependency

class Vihicle {
    move(MoveBehavior)
}

interface MoveBehavior {
    move()
}

note &quot;MoveBehavior.move()&quot; as N

Vihicle ..&gt; MoveBehavior

Vihicle .. N

@enduml
</code></pre>
<h1><a class="header" href="#三设计原则" id="三设计原则">三、设计原则</a></h1>
<h2><a class="header" href="#solid" id="solid">S.O.L.I.D</a></h2>
<table><thead><tr><th align="center">简写</th><th align="center">全拼</th><th align="center">中文翻译</th></tr></thead><tbody>
<tr><td align="center">SRP</td><td align="center">The Single Responsibility Principle</td><td align="center">单一责任原则</td></tr>
<tr><td align="center">OCP</td><td align="center">The Open Closed Principle</td><td align="center">开放封闭原则</td></tr>
<tr><td align="center">LSP</td><td align="center">The Liskov Substitution Principle</td><td align="center">里氏替换原则</td></tr>
<tr><td align="center">ISP</td><td align="center">The Interface Segregation Principle</td><td align="center">接口分离原则</td></tr>
<tr><td align="center">DIP</td><td align="center">The Dependency Inversion Principle</td><td align="center">依赖倒置原则</td></tr>
</tbody></table>
<h3><a class="header" href="#1-单一责任原则" id="1-单一责任原则">1. 单一责任原则</a></h3>
<blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h3><a class="header" href="#2-开放封闭原则" id="2-开放封闭原则">2. 开放封闭原则</a></h3>
<blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3><a class="header" href="#3-里氏替换原则" id="3-里氏替换原则">3. 里氏替换原则</a></h3>
<blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3><a class="header" href="#4-接口分离原则" id="4-接口分离原则">4. 接口分离原则</a></h3>
<blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3><a class="header" href="#5-依赖倒置原则" id="5-依赖倒置原则">5. 依赖倒置原则</a></h3>
<blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</br>抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li>
</ul>
<h2><a class="header" href="#其他常见原则" id="其他常见原则">其他常见原则</a></h2>
<p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<table><thead><tr><th align="center">简写</th><th align="center">全拼</th><th align="center">中文翻译</th></tr></thead><tbody>
<tr><td align="center">LOD</td><td align="center">The Law of Demeter</td><td align="center">迪米特法则</td></tr>
<tr><td align="center">CRP</td><td align="center">The Composite Reuse Principle</td><td align="center">合成复用原则</td></tr>
<tr><td align="center">CCP</td><td align="center">The Common Closure Principle</td><td align="center">共同封闭原则</td></tr>
<tr><td align="center">SAP</td><td align="center">The Stable Abstractions Principle</td><td align="center">稳定抽象原则</td></tr>
<tr><td align="center">SDP</td><td align="center">The Stable Dependencies Principle</td><td align="center">稳定依赖原则</td></tr>
</tbody></table>
<h3><a class="header" href="#1-迪米特法则" id="1-迪米特法则">1. 迪米特法则</a></h3>
<p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p>
<h3><a class="header" href="#2-合成复用原则" id="2-合成复用原则">2. 合成复用原则</a></h3>
<p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<h3><a class="header" href="#3-共同封闭原则" id="3-共同封闭原则">3. 共同封闭原则</a></h3>
<p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p>
<h3><a class="header" href="#4-稳定抽象原则" id="4-稳定抽象原则">4. 稳定抽象原则</a></h3>
<p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p>
<h3><a class="header" href="#5-稳定依赖原则" id="5-稳定依赖原则">5. 稳定依赖原则</a></h3>
<p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h1><a class="header" href="#参考资料-11" id="参考资料-11">参考资料</a></h1>
<ul>
<li>Java 编程思想</li>
<li>敏捷软件开发：原则、模式与实践</li>
<li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html">面向对象设计的 SOLID 原则</a></li>
<li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization">看懂 UML 类图和时序图</a></li>
<li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html">UML 系列——时序图（顺序图）sequence diagram</a></li>
<li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015">面向对象编程三大特性 ------ 封装、继承、多态</a></li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">一、分布式锁</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95">数据库的唯一索引</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#redis-%E7%9A%84-setnx-%E6%8C%87%E4%BB%A4">Redis 的 SETNX 指令</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#redis-%E7%9A%84-redlock-%E7%AE%97%E6%B3%95">Redis 的 RedLock 算法</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#zookeeper-%E7%9A%84%E6%9C%89%E5%BA%8F%E8%8A%82%E7%82%B9">Zookeeper 的有序节点</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E4%BA%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">二、分布式事务</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#2pc">2PC</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8">本地消息表</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E4%B8%89cap">三、CAP</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%88%86%E5%8C%BA%E5%AE%B9%E5%BF%8D%E6%80%A7">分区容忍性</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E6%9D%83%E8%A1%A1">权衡</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%9B%9Bbase">四、BASE</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%94%A8">基本可用</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E8%BD%AF%E7%8A%B6%E6%80%81">软状态</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E4%BA%94paxos">五、Paxos</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">执行过程</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6">约束条件</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%85%ADraft">六、Raft</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%8D%95%E4%B8%AA-candidate-%E7%9A%84%E7%AB%9E%E9%80%89">单个 Candidate 的竞选</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%A4%9A%E4%B8%AA-candidate-%E7%AB%9E%E9%80%89">多个 Candidate 竞选</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">数据同步</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一分布式锁" id="一分布式锁">一、分布式锁</a></h1>
<p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p>
<p>阻塞锁通常使用互斥量来实现：</p>
<ul>
<li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li>
<li>互斥量为 1 表示未锁定状态。</li>
</ul>
<p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p>
<h2><a class="header" href="#数据库的唯一索引" id="数据库的唯一索引">数据库的唯一索引</a></h2>
<p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p>
<p>存在以下几个问题：</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<h2><a class="header" href="#redis-的-setnx-指令" id="redis-的-setnx-指令">Redis 的 SETNX 指令</a></h2>
<p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
<p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
<p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
<h2><a class="header" href="#redis-的-redlock-算法" id="redis-的-redlock-算法">Redis 的 RedLock 算法</a></h2>
<p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p>
<ul>
<li>尝试从 N 个互相独立 Redis 实例获取锁；</li>
<li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li>
<li>如果获取锁失败，就到每个实例上释放锁。</li>
</ul>
<h2><a class="header" href="#zookeeper-的有序节点" id="zookeeper-的有序节点">Zookeeper 的有序节点</a></h2>
<h3><a class="header" href="#1-zookeeper-抽象模型" id="1-zookeeper-抽象模型">1. Zookeeper 抽象模型</a></h3>
<p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aefa8042-15fa-4e8b-9f50-20b282a2c624.png" width="320px"> </div><br>
<h3><a class="header" href="#2-节点类型" id="2-节点类型">2. 节点类型</a></h3>
<ul>
<li>永久节点：不会因为会话结束或者超时而消失；</li>
<li>临时节点：如果会话结束或者超时就会消失；</li>
<li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li>
</ul>
<h3><a class="header" href="#3-监听器" id="3-监听器">3. 监听器</a></h3>
<p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p>
<h3><a class="header" href="#4-分布式锁实现" id="4-分布式锁实现">4. 分布式锁实现</a></h3>
<ul>
<li>创建一个锁目录 /lock；</li>
<li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li>
<li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码，完成后，删除对应的子节点。</li>
</ul>
<h3><a class="header" href="#5-会话超时" id="5-会话超时">5. 会话超时</a></h3>
<p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。</p>
<h3><a class="header" href="#6-羊群效应" id="6-羊群效应">6. 羊群效应</a></h3>
<p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。</p>
<h1><a class="header" href="#二分布式事务" id="二分布式事务">二、分布式事务</a></h1>
<p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p>
<p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p>
<p>分布式锁和分布式事务区别：</p>
<ul>
<li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li>
<li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li>
</ul>
<h2><a class="header" href="#2pc" id="2pc">2PC</a></h2>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<h3><a class="header" href="#1-运行过程" id="1-运行过程">1. 运行过程</a></h3>
<h4><a class="header" href="#11-准备阶段" id="11-准备阶段">1.1 准备阶段</a></h4>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/44d33643-1004-43a3-b99a-4d688a08d0a1.png" width="550px"> </div><br>
<h4><a class="header" href="#12-提交阶段" id="12-提交阶段">1.2 提交阶段</a></h4>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png" width="550px"> </div><br>
<h3><a class="header" href="#2-存在的问题" id="2-存在的问题">2. 存在的问题</a></h3>
<h4><a class="header" href="#21-同步阻塞" id="21-同步阻塞">2.1 同步阻塞</a></h4>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。</p>
<h4><a class="header" href="#22-单点问题" id="22-单点问题">2.2 单点问题</a></h4>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。</p>
<h4><a class="header" href="#23-数据不一致" id="23-数据不一致">2.3 数据不一致</a></h4>
<p>在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
<h4><a class="header" href="#24-太过保守" id="24-太过保守">2.4 太过保守</a></h4>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<h2><a class="header" href="#本地消息表" id="本地消息表">本地消息表</a></h2>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png" width="740px"> </div><br>
<h1><a class="header" href="#三cap" id="三cap">三、CAP</a></h1>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg" width="450px"> </div><br>
<h2><a class="header" href="#一致性" id="一致性">一致性</a></h2>
<p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<h2><a class="header" href="#可用性" id="可用性">可用性</a></h2>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h2><a class="header" href="#分区容忍性" id="分区容忍性">分区容忍性</a></h2>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h2><a class="header" href="#权衡" id="权衡">权衡</a></h2>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h1><a class="header" href="#四base" id="四base">四、BASE</a></h1>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<h2><a class="header" href="#基本可用" id="基本可用">基本可用</a></h2>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h2><a class="header" href="#软状态" id="软状态">软状态</a></h2>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
<h2><a class="header" href="#最终一致性" id="最终一致性">最终一致性</a></h2>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h1><a class="header" href="#五paxos" id="五paxos">五、Paxos</a></h1>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b988877c-0f0a-4593-916d-de2081320628.jpg"/> </div><br>
<h2><a class="header" href="#执行过程" id="执行过程">执行过程</a></h2>
<p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p>
<h3><a class="header" href="#1-prepare-阶段" id="1-prepare-阶段">1. Prepare 阶段</a></h3>
<p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png"/> </div><br>
<p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p>
<p>如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg"/> </div><br>
<p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p>
<p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg"/> </div><br>
<h3><a class="header" href="#2-accept-阶段" id="2-accept-阶段">2. Accept 阶段</a></h3>
<p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p>
<p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p>
<p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png"/> </div><br>
<h3><a class="header" href="#3-learn-阶段" id="3-learn-阶段">3. Learn 阶段</a></h3>
<p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg"/> </div><br>
<h2><a class="header" href="#约束条件" id="约束条件">约束条件</a></h2>
<h3><a class="header" href="#1-正确性" id="1-正确性">1. 正确性</a></h3>
<p>指只有一个提议值会生效。</p>
<p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p>
<h3><a class="header" href="#2-可终止性" id="2-可终止性">2. 可终止性</a></h3>
<p>指最后总会有一个提议生效。</p>
<p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p>
<h1><a class="header" href="#六raft" id="六raft">六、Raft</a></h1>
<p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p>
<ul>
<li><a href="http://thesecretlivesofdata.com/raft">Raft: Understandable Distributed Consensus</a></li>
</ul>
<h2><a class="header" href="#单个-candidate-的竞选" id="单个-candidate-的竞选">单个 Candidate 的竞选</a></h2>
<p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118015898.gif"/> </div><br>
<ul>
<li>此时 Node A 发送投票请求给其它所有节点。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118445538.gif"/> </div><br>
<ul>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118483039.gif"/> </div><br>
<ul>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118640738.gif"/> </div><br>
<h2><a class="header" href="#多个-candidate-竞选" id="多个-candidate-竞选">多个 Candidate 竞选</a></h2>
<ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119203347.gif"/> </div><br>
<ul>
<li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119368714.gif"/> </div><br>
<h2><a class="header" href="#数据同步" id="数据同步">数据同步</a></h2>
<ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/71550414107576.gif"/> </div><br>
<ul>
<li>Leader 会把修改复制到所有 Follower。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/91550414131331.gif"/> </div><br>
<ul>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/101550414151983.gif"/> </div><br>
<ul>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111550414182638.gif"/> </div><br>
<h1><a class="header" href="#参考" id="参考">参考</a></h1>
<ul>
<li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li>
<li><a href="https://redis.io/topics/distlock">Distributed locks with Redis</a></li>
<li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1023">浅谈分布式锁</a></li>
<li><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html">基于 Zookeeper 的分布式锁</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">聊聊分布式事务，再说说解决方案</a></li>
<li><a href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理</a></li>
<li><a href="https://juejin.im/entry/577c6f220a2b5800573492be">深入理解分布式事务</a></li>
<li><a href="http://www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/">What is CAP theorem in distributed database system?</a></li>
<li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/">NEAT ALGORITHMS - PAXOS</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/">Paxos By Example</a></li>
</ul>
<p>后端面试题整理
​1. mongodb分块是如何做的
2. 聚簇索引和非聚簇索引的区别
3. TCP中的序列号的作用
4. TCP client端宕机之后会发生什么，server宕机之后会发生什么。
5. mysql分布式如何保证一致性，一主多从如何保证写同步，半同步是怎么做的
6. mysql引擎有哪些，它们的特点和区别是什么
7. mysql行锁和表锁的触发条件是什么，什么情况下会触发行锁和表锁
8. redis有几种部署形式，哨兵形式是怎么做的
9. redis有几种数据结构，它的有序集合是怎么实现的，跳表的结构，跳表如何插入。
10. 四岔堆的插入和删除
11. redis实现分布式锁
12. 悲观锁和乐观锁。
13. 秒杀系统如何设计，后端怎么搞
14. mysql主从，主挂了怎么办</p>
<ul>
<li><a href="https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/styleguide.md">Twitter Java Style Guide</a></li>
<li><a href="http://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a></li>
<li><a href="https://github.com/alibaba/p3c">阿里巴巴Java开发手册</a></li>
</ul>
<h1><a class="header" href="#简历的重要性" id="简历的重要性">简历的重要性</a></h1>
<ul>
<li>各大公司每年都要接收成千上万份简历，但是考虑到招聘成本，简历要先经过系统和 HR 筛选，简历筛选决定了你是否有笔试和面试资格。HR 需要从这么多的简历中筛选出合适的简历，那么一份简历通常不会花特别多的时间进行筛选，所以就需要让 HR 在很短的筛选时间中认可你的简历。</li>
<li>简历通过筛选之后就被放入人才库中，等待发起笔试和面试。如果简历足够优秀，可以在提前批阶段免笔试直接获得面试机会，或者笔试成绩不理想但也有面试机会，这主要看有没有面试官从人才库中把你的简历捞起来。</li>
<li>面试过程通常会按照简历上的内容进行提问，所以简历也可以当成是面试大纲。如果你希望某些内容被面试官问到，那么最好把这些内容放在面试官比较能注意到的位置。</li>
</ul>
<h1><a class="header" href="#简历的本质" id="简历的本质">简历的本质</a></h1>
<p>简历相当于向企业推销自己的工具，在简历上你需要尽可能展现自己能给企业带来的价值，这种价值从两方面去评估：</p>
<p>技能的匹配程度。除了判断技能栈是否和岗位所要求的技能栈匹配之外，还要看是否具备公司目前业务相关的项目经历。
能力证明。即使技能匹配了，但是如果能力不足的话依然不能胜任工作任务。可以通过学历、大赛奖项、工作和实习经历、项目中解决的问题等方面去证明自己的能力。应该分清哪个是你的优势和劣势，突出优势并弱化劣势，比如学历不好的话就把教育经历放后面一些。</p>
<h1><a class="header" href="#简历的内容" id="简历的内容">简历的内容</a></h1>
<ul>
<li>姓名相当于你的 ID，应该把姓名放在最显眼的地方。</li>
<li>为了方便 HR 联系你，也要把联系信息也放在和姓名一样显眼的位置。</li>
<li>个人博客和 Github 等技术社区账号可以作为加分项。</li>
<li>教育经历和工作经历按年份逆序来写。</li>
<li>项目经历可以写科研项目、个人项目、实习和工作项目。</li>
<li>技能清单最好可以让人一眼就看出你的熟练度，可以使用精通、熟悉、了解等词语，也可以使用 ★★☆ 这种图标。</li>
</ul>
<p>需要谨慎考虑的内容：</p>
<ul>
<li>有些企业会根据性别、年龄等信息筛选人，最好写上，不写也没什么关系。</li>
<li>工作经验和期望薪资对于校招生来说不需要写，但是社招生就一定要写。</li>
<li>只写可以给企业带来价值的兴趣爱好，其它的无关兴趣爱好不要写。</li>
<li>和技术相关的大赛获奖经历可以写，但是其它一些比赛获奖就不要写。</li>
<li>三好学生、奖学金、四六级成绩、绩点可以写，以证明你的学习能力，但是尽量不要占太多行，如果不是特别好的话也可以不写。</li>
<li>个人评价如果要写的话不要太空泛，什么热爱学习吃苦耐劳等就不要写了，要写得话可以写在最后当做是简历其它内容的总结。</li>
<li>不要在简历上写自己不熟悉的东西。如果你说必用过mongoDB，仅仅停留在使用的层面，面试时就会一问三不知。</li>
</ul>
<h1><a class="header" href="#一消息模型" id="一消息模型">一、消息模型</a></h1>
<h2><a class="header" href="#点对点" id="点对点">点对点</a></h2>
<p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011250613.png"/> </div><br>
<h2><a class="header" href="#发布订阅" id="发布订阅">发布/订阅</a></h2>
<p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011410374.png"/> </div><br>
<p>发布与订阅模式和观察者模式有以下不同：</p>
<ul>
<li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。</li>
<li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011747967.png"/> </div><br>
<h1><a class="header" href="#二使用场景" id="二使用场景">二、使用场景</a></h1>
<p>消息队列的三个主要作用：</p>
<ul>
<li>异步</li>
<li>解耦</li>
<li>削峰</li>
</ul>
<h2><a class="header" href="#异步处理" id="异步处理">异步处理</a></h2>
<p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p>
<p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p>
<p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p>
<h2><a class="header" href="#流量削锋" id="流量削锋">流量削锋</a></h2>
<p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p>
<p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
<h2><a class="header" href="#应用解耦" id="应用解耦">应用解耦</a></h2>
<p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p>
<p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p>
<h1><a class="header" href="#三可靠性" id="三可靠性">三、可靠性</a></h1>
<h2><a class="header" href="#发送端的可靠性" id="发送端的可靠性">发送端的可靠性</a></h2>
<p>发送端完成操作后一定能将消息成功发送到消息队列中。</p>
<p>实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</p>
<h2><a class="header" href="#接收端的可靠性" id="接收端的可靠性">接收端的可靠性</a></h2>
<p>接收端能够从消息队列成功消费一次消息。</p>
<p>两种实现方法：</p>
<ul>
<li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li>
<li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li>
</ul>
<h1><a class="header" href="#常见的消息队列" id="常见的消息队列">常见的消息队列</a></h1>
<ul>
<li>kafka：java语言，使用最为广泛</li>
<li>RocketMQ：阿里巴巴出品</li>
<li>RabbitMQ：erlang语言开发</li>
<li>ActiveMQ：即将被淘汰</li>
</ul>
<h1><a class="header" href="#用消息队列处理日志" id="用消息队列处理日志">用消息队列处理日志</a></h1>
<ul>
<li>Kafka ：接收用户日志的消息队列。</li>
<li>Logstash ：对接 Kafka 写入的日志，做日志解析，统一成 JSON 输出给 Elasticsearch 中。</li>
<li>Elasticsearch ：实时日志分析服务的核心技术，一个 schemaless ，实时的数据存储服务，通过 index 组织数据，兼具强大的搜索和统计功能。</li>
<li>Kibana ：基于 Elasticsearch 的数据可视化组件，超强的数据可视化能力是众多公司选择 ELK stack 的重要原因。</li>
</ul>
<h1><a class="header" href="#消息队列的缺点" id="消息队列的缺点">消息队列的缺点</a></h1>
<ul>
<li>系统可用性降低。
系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，本来 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？所以，消息队列一定要做好高可用。</li>
<li>系统复杂度提高。
主要需要多考虑，1）消息怎么不重复消息。2）消息怎么保证不丢失。3）需要消息顺序的业务场景，怎么处理。</li>
<li>一致性问题。
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了。但是问题是，要是 B、C。D 三个系统那里，B、D 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。
当然，这不仅仅是 MQ 的问题，引入 RPC 之后本身就存在这样的问题。如果我们在使用 MQ 时，一定要达到数据的最终一致性。即，C 系统最终执行完成。</li>
</ul>
<h1><a class="header" href="#消息队列如何保证消息不被重复消费" id="消息队列如何保证消息不被重复消费">消息队列如何保证消息不被重复消费</a></h1>
<p>首先评估是否允许重复消费，如果可以重复消费，那就不用做额外处理了。<br />
首先确定消息队列中每条消息的最多存活时间，以此来决定redis的过期时间，当消费一条消息之后，向redis中插入这条消息的id。只需要保证最近若干天内没有重复消费即可，因为消息存活时间有限。</p>
<h1><a class="header" href="#消息队列如何保证数据可靠性传输如何防止数据丢失" id="消息队列如何保证数据可靠性传输如何防止数据丢失">消息队列如何保证数据可靠性传输（如何防止数据丢失）</a></h1>
<p>消息队列有三个组成部分：生产者、消费者、消息队列。数据丢失的三个来源：</p>
<ul>
<li>如果生产者丢失数据：发送消息失败，重发消息即可。</li>
<li>如果消息队列丢失数据：开启消息队列持久化，防止消息队列崩溃之后的数据丢失。</li>
<li>如果消费者丢失数据：如果消费者成功消费，需要告知消息队列，否则表示没能成功消费。</li>
</ul>
<h1><a class="header" href="#消息队列如何保证消息的顺序性" id="消息队列如何保证消息的顺序性">消息队列如何保证消息的顺序性</a></h1>
<p>把需要保持顺序的消息放到同一个分区中，不同分区之间一定是并行的。  </p>
<h1><a class="header" href="#cc" id="cc">C/C++</a></h1>
<p>const
多态
什么类不能被继承（这个题目非常经典，我当时答出了private但是他说不好，我就没想到final我以为那个是java的）</p>
<h1><a class="header" href="#网络" id="网络">网络</a></h1>
<p>网络的字节序
网络知识 tcp三次握手 各种细节 timewait状态
tcp 与 udp 区别 概念 适用范围
TCP四次挥手讲一下过程，最后一次ack如果客户端没收到怎么办，为什么挥手不能只有三次，为什么time_wait。
对于socket编程，accept方法是干什么的，在三次握手中属于第几次，可以猜一下，为什么这么觉得。
tcp怎么保证有序传输的，讲下tcp的快速重传和拥塞机制，知不知道time_wait状态，这个状态出现在什么地方，有什么用？
知道udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？
http与https有啥区别？说下https解决了什么问题，怎么解决的？说下https的握手过程。
tcp 粘包半包问题怎么处理？
keepalive 是什么东东？如何使用？
列举你所知道的tcp选项，并说明其作用。
socket什么情况下可读？
nginx的epoll模型的介绍以及io多路复用模型
SYN Flood攻击
流量控制，拥塞控制
TCP和UDP区别，TCP如何保证可靠性，对方是否存活(心跳检测)
tcpdump抓包，如何分析数据包
tcp如何设定超时时间
基于socket网络编程和tcp/ip协议栈，讲讲从客户端send()开始，到服务端recv()结束的过程，越细越好
http报文格式
http1.1与http1.0区别，http2.0特性
http3了解吗
http1.1长连接时，发送一个请求阻塞了，返回什么状态码？
udp调用connect有什么作用？</p>
<h1><a class="header" href="#操作系统" id="操作系统">操作系统</a></h1>
<p>进程和线程-分别的概念 区别 适用范围 它们分别的通讯方式 不同通讯方式的区别优缺点
僵尸进程
死锁是怎么产生的
CPU的执行方式
代码中遇到进程阻塞，进程僵死，内存泄漏等情况怎么排查。
有没有了解过协程？说下协程和线程的区别？
堆是线程共有还是私有，堆是进程共有还是私有，栈呢
了解过协程吗（我：携程？？？不了解呜呜呜）
共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）
c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）
ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）
使用过哪些进程间通讯机制，并详细说明（重点）
多线程和多进程的区别（重点 面试官最最关心的一个问题，必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）
信号：列出常见的信号，信号怎么处理？
i++是否原子操作？并解释为什么？？？？？？？
说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）
列举说明linux系统的各类异步机制
exit() _exit()的区别？
如何实现守护进程？
linux的内存管理机制是什么？
linux的任务调度机制是什么？
标准库函数和系统调用的区别？
补充一个坑爹坑爹坑爹坑爹的问题：系统如何将一个信号通知到进程？（这一题哥没有答出来）</p>
<h1><a class="header" href="#linux系统" id="linux系统">Linux系统</a></h1>
<p>linux的各种命令 给你场景让你解决
Linux了解么，查看进程状态ps，查看cpu状态 top。查看占用端口的进程号netstat grep
Linux的cpu 100怎么排查，top jstack，日志，gui工具
Linux操作系统了解么
怎么查看CPU负载，怎么查看一个客户下有多少进程
Linux内核是怎么实现定时器的
gdb怎么查看某个线程
core dump有没有遇到过，gdb怎么调试
linux如何设置core文件生成
linux如何设置开机自启动
linux用过哪些命令、工具
用过哪些工具检测程序性能，如何定位性能瓶颈的地方
netstat tcpdump ipcs ipcrm （如果这四个命令没听说过或者不能熟练使用，基本上可以回家，通过的概率较小 ^_^ ，这四个命令的熟练掌握程度基本上能体现面试者实际开发和调试程序的经验)
cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握
awk sed需掌握
gdb调试相关的经验，会被问到</p>
<h1><a class="header" href="#mongodb" id="mongodb">MongoDB</a></h1>
<p>关于大数据存储的（mongodb hadoop）各种原理 mongodb又问的深入很多</p>
<h1><a class="header" href="#redis" id="redis">Redis</a></h1>
<p>Redis内存数据库的内存指的是共享内存么
Redis的持久化方式
Redis和MySQL有什么区别，用于什么场景。
redis有没有用过，常用的数据结构以及在业务中使用的场景，redis的hash怎么实现的
问了下缓存更新的模式，以及会出现的问题和应对思路？
redis的sentinel上投票选举的问题 raft算法
redis单线程结构有什么优势？有什么问题？ 主要优势单线程，避免线程切换产生静态消耗，缺点是容易阻塞，虽然redis使用io复用epoll和输入缓冲区把命令按照队列先进先出输入等等
你觉得针对redis这些缺点那些命令在redis上不可使用？ 比如keys、hgetall等等这些命令 建议用scan等等 这方面阐述
你觉得为什么项目中没有用mysql而用了es，redis在这里到底起到了什么作用？因为架构上这里理解不清楚，最后回答自己都觉得有漏洞了
你觉得redis什么算有用？ 有用？ 是说存进去了还是说命中缓存？最后把缓存命中率是什么说了一遍
你们这边redis集群是怎么样子的
平常redis用的多的数据结构是什么，跳表实现，怎么维护索引，当时我说是一个简单的二分，手写二分算法，并且时间复杂度是怎么计算出来的 （2的k次方等于n k等于logn）</p>
<h1><a class="header" href="#mysql" id="mysql">MySQL</a></h1>
<p>你们后端用什么数据库做持久化的？有没有用到分库分表，怎么做的？
索引的常见实现方式有哪些，有哪些区别?MySQL的存储引擎有哪些，有哪些区别？InnoDB使用的是什么方式实现索引，怎么实现的？说下聚簇索引和非聚簇索引的区别?
mysql查询优化
MySQL的索引，B+树性质。
B+树和B树，联合索引等原理
mysql的悲观锁和乐观锁区别和应用，ABA问题的解决
项目性能瓶颈在哪，数据库表怎么设计
假设项目的性能瓶颈出现在写数据库上，应该怎么解决峰值时写速度慢的问题
假设数据库需要保存一年的数据，每天一百万条数据，一张表最多存一千万条数据，应该怎么设计表
数据库自增索引。100台服务器，每台服务器有若干个用户，用户有id，同时会有新用户加入。实现id自增，统计用户个数？不能重复，好像是这样的。
mysql，会考sql语言，服务器数据库大规模数据怎么设计，db各种性能指标</p>
<h1><a class="header" href="#算法-1" id="算法-1">算法</a></h1>
<p>堆栈
有序数组排序，二分，复杂度
常见排序算法，说下快排过程，时间复杂度
有N个节点的满二叉树的高度。1+logN
如何实现关键字输入提示，使用字典树，复杂度多少，有没有其他方案，答哈希，如果是中文呢，分词后建立字典树？
hashmap的实现讲一下吧，讲的很详细了。讲一下红黑树的结构，查询性能等。
快排的时间复杂度，冒泡时间复杂度，快排是否稳定，快排的过程
100w个数，怎么找到前1000个最大的，堆排序，怎么构造，怎么调整，时间复杂度。
一个矩阵，从左上角到右下角，每个位置有一个权值。可以上下左右走，到达右下角的路径权值最小怎么走。
四辆小车，每辆车加满油可以走一公里，问怎么能让一辆小车走最远。说了好几种方案，面试官引导我优化了一下，但是还是不满意，最后他说跳过。
MySQL的索引，B+树性质。
十亿和数找到前100个最大的，堆排序，怎么实现，怎么调整。
布隆过滤器
hash表解决冲突的方法
跳表插入删除过程
让你实现一个哈希表，怎么做（当时按照Redis中哈希表的实现原理回答）</p>
<h1><a class="header" href="#设计模式" id="设计模式">设计模式</a></h1>
<p>对于单例模式，有什么使用场景了，讲了全局id生成器，他问我分布式id生成器怎么实现，说了zk，问我zk了解原理不，讲了zab，然后就没问啦。
除了单例模式，知道适配器模式怎么实现么，有什么用</p>
<h1><a class="header" href="#分布式架构" id="分布式架构">分布式架构</a></h1>
<p>CAP BASE理论
看你项目里面用了etcd，讲解下etcd干什么用的，怎么保证高可用和一致性？
既然你提到了raft算法，讲下raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？有没有了解过paxos和zookeeper的zab算法，他们之前有啥区别？
rpc有没有了解</p>
<h1><a class="header" href="#系统设计" id="系统设计">系统设计</a></h1>
<p>朋友之间的点对点关系用图维护，怎么判断两人是否是朋友，并查集，时间复杂度，过程。
10g文件，只有2g内存，怎么查找文件中指定的字符串出现位置。
Linux大文件怎么查某一行的内容。
秒杀系统的架构设计
十亿个数的集合和10w个数的集合，如何求它们的交集。
回到网络，刚才你说到直播场景，知道直播的架构怎么设计么，要点是什么，说了几个不太对，他说要避免广播风暴，答不会。
针对自己最熟悉的项目，画出项目的架构图，主要的数据表结构，项目中使用到的技术点，项目的总峰值qps，时延，以及有没有分析过时延出现的耗时分别出现在什么地方，项目有啥改进的地方没有？
如果请求出现问题没有响应，如何定位问题，说下思路？
除了公司项目之外，业务有没有研究过知名项目或做出过贡献？
go程和线程有什么区别？ 答：1 起一个go程大概只需要4kb的内存，起一个Java线程需要1.5MB的内存；go程的调度在用户态非常轻量，Java线程的切换成本比较高。接着问为啥成本比较高？因为Java线程的调度需要在用户态和内核态切换所以成本高？为啥在用户态和内核态之间切换调度成本比较高？简单说了下内核态和用户态的定义。接着问，还是没有明白为啥成本高？心里瞬间崩溃，没完没了了呀，OS这块依旧是痛呀，支支吾吾半天放弃了。
服务器CPU 100%怎么定位？可能是由于平时定位业务问题的思维定势，加之处于蒙蔽状态，随口就是：先查看监控面板看有无突发流量异常，接着查看业务日志是否有异常，针对CPU100%那个时间段，取一个典型业务流程的日志查看。最后才提到使用top命令来监控看是哪个进程占用到100%。果然阵脚大乱，张口就来，捂脸。。。 本来正确的思路应该是先用top定位出问题的进程，再用top定位到出问题的线程，再打印线程堆栈查看运行情况，这个流程换平时肯定能答出来，但是，但是没有但是。还是得好好总结。
最后问了一个系统设计题目（朋友圈的设计），白板上面画出系统的架构图，主要的表结构和讲解主要的业务流程，如果用户变多流量变大，架构将怎么扩展，怎样应对？ 这个答的也有点乱，直接上来自顾自的用了一个通用的架构，感觉毫无亮点。后面反思应该先定位业务的特点，这个业务明显是读多写少，然后和面试官沟通一期刚开始的方案的用户量，性能要求，单机目标qps是什么等等？在明确系统的特点和约束之后再来设计，而不是一开始就是用典型互联网的那种通用架构自顾自己搞自己的方案。
设计一个限流的算法
定时器除了小根堆，还可以怎么做
项目性能瓶颈在哪，数据库表怎么设计
.在高并发的生产环境中（非调试场景下），如果出现数据包的丢失，如何定位问题
补充一个最最重要，最最坑爹，最最有难度的一个题目：一个每秒百万级访问量的互联网服务器，每个访问都有数据计算和I/O操作，如果让你设计，你怎么设计？</p>
<h1><a class="header" href="#道友总结" id="道友总结">道友总结</a></h1>
<p>tcp/udp，http和https还有网络这块（各种网络模型，已经select，poll和epoll）一定要非常熟悉
一定要有拿的出手的项目经验，而且要能够讲清楚，讲清楚项目中取舍，设计模型和数据表
分布式要非常熟悉
常见问题定位一定要有思路
操作系统，还是操作系统，重要的事情说三遍
系统设计，思路，思路，思路，一定要思路清晰，一定要总结下系统设计的流程
一点很重要的心得，平时blog和专栏看的再多，如果没有自己的思考不过是过眼云烟，根本不会成为自己的东西，就像内核态和用户态，平常也看过，但是没细想，突然要自己说，还真说不出来，这就很尴尬了。勿以浮沙筑高台，基础这种东西还是需要时间去慢慢打牢，多去思考和总结。</p>
<h1><a class="header" href="#存储系统" id="存储系统">存储系统</a></h1>
<ul>
<li>mysql</li>
<li>redis</li>
<li>mongodb</li>
<li>hive</li>
<li>kafka</li>
</ul>
<h1><a class="header" href="#八mysql" id="八mysql">八、MySQL</a></h1>
<ul>
<li>手写/口述场景题的 SQL 语句</li>
<li>一条 SQL 语句在数据库框架中的执行流程？</li>
<li>数据库的三范式是什么？</li>
<li>MySQL 中的数据类型有哪些？</li>
<li>char 和 varchar 的区别？</li>
<li>谈谈你对索引的理解？底层数据结构？</li>
<li>为什么要使用索引？一定要使用索引吗？</li>
<li>为什么索引的底层数据结构采用 B+ 树而不是红黑树？</li>
<li>索引的类型？</li>
<li>什么叫聚簇索引？什么叫联合索引？</li>
<li>谈下什么是前缀索引？</li>
<li>谈下什么是覆盖索引？</li>
<li>什么情况下索引会失效？即查询不走索引？</li>
<li>查询性能的优化方法？</li>
<li>InnoDB 和 MyISAM 的比较？</li>
<li>为什么要分库分表？分库分表后，主键 ID 怎么设置？</li>
<li>水平切分和垂直切分该如何选择？存在什么问题？</li>
<li>主从复制中涉及到哪三个线程？</li>
<li>如何实现 MySQL 的读写分离？</li>
<li>MySQL 的主从复制原理是什么？如何解决 MySQL 主从同步延迟问题？</li>
<li>谈下你对读写分离的理解？</li>
<li>谈下你对数据库事务的理解？不同隔离级别下会产生什么问题？怎么解决？</li>
<li>MySQL 默认的隔离级别是什么？</li>
<li>MVCC 的实现原理是什么？</li>
<li>数据库中常用的锁有哪些？</li>
<li>表锁和行锁有什么区别？</li>
<li>InnoDB 什么时候使用行级锁？什么时候使用表级锁？</li>
<li>InnoDB 存储引擎的锁的 3 种算法？</li>
<li>MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？</li>
</ul>
<ol>
<li>数据库三范式是什么?</li>
<li>有哪些数据库优化方面的经验?</li>
<li>请简述常用的索引有哪些种类?</li>
<li>以及在MySQL数据库中索引的工作机制是什么?</li>
<li>MySQL的基础操作命令:</li>
<li>MySQL的复制原理以及流程。</li>
<li>MySQL支持的复制类型?</li>
<li>MySQL中Myisam与Innodb的区别?</li>
<li>MySQL中Varchar与Char的区别以及Varchar( 50)中的50代表的涵义?</li>
<li>MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别?</li>
<li>表中有大字段X (例如: text类型)，且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么?</li>
<li>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的?</li>
<li>MySQL中控制内存分配的全局参数，有哪些?</li>
<li>若一张表中只有-一个字段VARCHAR(N)类型，utf8 编码，则N最大值.为多少(精确到数量级即可)?</li>
<li>[SELECT *]和[SELECT全部字段]的2种写法有何优缺点?</li>
<li>HAVNG子句和WHERE的异同点?</li>
<li>MySQL当记录不存在时insert,当记录存在时update,语句怎么写?</li>
<li>MySQL的insert和update的select语句语法</li>
</ol>
<ul>
<li>MySQL的复制原理以及流程</li>
<li>MySQL中myisam与innodb的区别，至少5点</li>
<li>MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</li>
<li>MySQL binlog的几种日志录入格式以及区别</li>
<li>MySQL数据库cpu飙升到500%的话怎么处理</li>
<li>备份计划，mysqldump以及xtranbackup的实现原理</li>
<li>MySQL 单表量级达到 5 千万以上，如何添加修改字段而不产生锁表？</li>
<li>生产环境下，变更 MySQL 的表结构步骤是什么？</li>
<li>MySQL 建表的最佳实践是什么？</li>
<li>MySQL 的表空间设置个和优化策略主要有哪些？</li>
</ul>
<h1><a class="header" href="#十二redis" id="十二redis">十二、Redis</a></h1>
<ul>
<li>Redis 是什么？Redis 有哪些功能？都有哪些使用场景？</li>
<li>Redis 为什么是单线程的？</li>
<li>Redis 支持的数据类型有哪些？</li>
<li>什么是缓存雪崩？该如何解决？</li>
<li>什么是缓存穿透？怎么解决？</li>
<li>怎么保证缓存和数据库数据的一致性？</li>
<li>Redis 持久化有几种方式？</li>
<li>Redis 怎么实现分布式锁？Redis 分布式锁有什么缺陷？</li>
<li>Redis 淘汰策略有哪些？</li>
<li>redis 常见的性能问题有哪些？该如何解决？</li>
<li>什么是Redis？</li>
<li>Redis集群方案应该怎么做？都有哪些方案？</li>
<li>Redis集群方案什么情况下会导致整个集群不可用？</li>
<li>怎么理解Redis事务？</li>
<li>Redis key的过期时间和永久有效分别怎么设置？</li>
<li>Redis如何做内存优化？</li>
<li>Redis回收使用的是什么算法？</li>
<li>Redis持久化数据和缓存怎么做扩容？</li>
<li>Redis与其他key-value存储有什么不同？</li>
<li>Redis是单线程的，如何提高多核CPU的利用率？
谈谈对于Redis的底层数据结构的理解。
跳表了解吗？Redis的zset实现原理以及为什么不用红黑树。
Redis哨兵原理以及集群版故障转移过程。
基于Redis实现分布式锁。
Redis渐进式Rehash的实现原理。
Redis和LevelDB的区别以及LevelDB的LSM树和WAL原理。
Redis主从同步的实现原理和过程、产生数据丢失的原因。
MyISAM和InnoDB的区别。
MySQL索引原理和优化。
Redis集群版如何实现一致性Hash算法的。
Redis的单线程网络框架原理和混合持久化机制。
类Redis数据库Pika了解吗？基本设计架构是什么？
如何设计一个缓存系统以及缓存击穿的解决方案？
一致性协议raft/paxos/2pc/3pc基本原理。
Redis的Gossip协议原理。
Redis4.0+版本的BIO线程原理和使用。
简述如何自己实现一个NoSQL，需要考虑什么。</li>
</ul>
<h1><a class="header" href="#十三消息队列" id="十三消息队列">十三、消息队列</a></h1>
<ul>
<li>消息队列的主要作用？</li>
<li>消息队列的优缺点？</li>
<li>如何保证消息队列的高可用？</li>
<li>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</li>
<li>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</li>
<li>如何保证消息的顺序性？</li>
<li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</li>
<li>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</li>
<li>RabbitMQ 有哪些重要的角色？有哪些重要的组件？</li>
<li>RabbitMQ 怎么避免消息丢失？</li>
<li>要保证消息持久化成功的条件有哪些？</li>
<li>RabbitMQ 有几种广播类型？</li>
<li>RabbitMQ 怎么实现延迟消息队列？</li>
<li>Kafka 可以脱离 zookeeper 单独使用吗？为什么？</li>
<li>Kafka 有几种数据保留的策略？</li>
</ul>
<h1><a class="header" href="#十四zookeeper" id="十四zookeeper">十四、Zookeeper</a></h1>
<ul>
<li>zookeeper是什么框架？</li>
<li>有哪些应用场景？</li>
<li>使用什么协议？</li>
<li>说说分布式一致性算法Paxos</li>
<li>说一说选举算法及流程</li>
<li>zookeeper有哪几种节点类型？</li>
<li>zookeeper对节点的watch监听通知是永久的吗？</li>
<li>有哪几种部署模式？</li>
<li>集群中的机器角色都有哪些？</li>
<li>集群最少要几台机器，集群规则是怎样的</li>
<li>zookeeper 都有哪些功能？</li>
<li>zookeeper 有几种部署模式？</li>
<li>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</li>
<li>zookeeper 怎么保证主从节点的状态同步？</li>
<li>集群中为什么要有主节点？</li>
<li>说一下 zookeeper 的通知机制？</li>
<li>说一下两阶段提交和三阶段提交的过程？分别有什么问题？</li>
<li>你认为几阶段提交可以实现可靠事务？</li>
<li>如何使用 zookeeper 实现分布式锁？</li>
</ul>
<h1><a class="header" href="#十五dubbo" id="十五dubbo">十五、Dubbo</a></h1>
<ul>
<li>Dubbo 的组件有哪些？作用是什么？</li>
<li>Dubbo 的集群容错模式有哪些？</li>
<li>Dubbo 中 zookeeper 做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？</li>
<li>Dubbo 连接注册中心和直连的区别？</li>
<li>Dubbo 协议为什么要消费者比提供者个数多？</li>
<li>Dubbo 协议为什么不能传大包？</li>
<li>Dubbo 协议为什么采用异步单一长连接？</li>
<li>Dubbo 支持哪些序列化协议？说一下 Hession 的数据结构？</li>
<li>分布式服务接口的幂等性如何设计？</li>
<li>分布式服务接口请求的顺序性如何保证？</li>
</ul>
<h2><a class="header" href="#二tomcat部分" id="二tomcat部分">二、Tomcat部分</a></h2>
<ol>
<li>Tomcat的缺省端口是多少，怎么修改?</li>
<li>Tomcat有哪几种Connector运行模式(优化)?</li>
<li>Tomcat有几种部署方式?</li>
<li>Tomcat容器是如何创建servlet类实例?用到了什么原理?</li>
<li>Tomcat如何优化?</li>
<li>内存调优</li>
<li>垃圾回收策略调优</li>
<li>共享session处理</li>
<li>添加JMS远程监控</li>
<li>专业点的分析工具有</li>
<li>关于Tomcat的session数目</li>
<li>监视Tomcat的内存使用情况</li>
<li>打印类的加载情况及对象的回收情况</li>
<li>Tomcat一个请求的完整过程</li>
<li>Tomcat工作模式?</li>
</ol>
<h1><a class="header" href="#docker" id="docker">docker</a></h1>
<p>如何临时退出一个正在交互的容器的终端，而不终止它？
可以在一个容器中同时运行多个应用进程吗？
如何控制容器占用系统资源（CPU，内存）的份额？
仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？
Docker的配置文件放在那里。如何修改配置？
Docker与LXC（Linux Container）有何不同？
开发环境中Docker与Vagrant该如何选择？
使用docker build命令有几种方法构建镜像？（
overlay文件系统里有个目录是upperdir，它里面装的是什么？
swarm的调度模块的第一阶段，过滤器有几种？</p>
<h1><a class="header" href="#十七数据结构与算法" id="十七数据结构与算法">十七、数据结构与算法</a></h1>
<h2><a class="header" href="#1数组" id="1数组">1、数组</a></h2>
<ul>
<li>找出数组中出现次数大于数组长度一半和 N / K 的数</li>
<li>数组的奇偶位置问题：给定一个整型数组，请在原地调整这个数组，保证要么偶数位置上都是偶数，或者奇数位置上都是奇数。</li>
<li>调整数组顺序使奇数位于偶数前面</li>
<li>数组的度</li>
<li>求一个数组中的第 K 小 / 大的数</li>
<li>将一个整数数组划分为 K 个相等的子集问题</li>
<li>旋转数组中的最小数字</li>
<li>在二维数组中查找一个数</li>
<li>找出数组中重复的数字</li>
<li>找出数组中只出现一次的那个数，其他都出现两次</li>
<li>子数组最大累乘积：给定一个 double 类型的数组 arr，其中的元素可正、可负、可 0，返回子数组累乘的最大乘积。</li>
<li>需要排序的最短子数组长度</li>
<li>最长的可整合子数组的长度</li>
<li>最短无序连续子数组</li>
<li>连续子数组的最大和</li>
</ul>
<h2><a class="header" href="#2字符串" id="2字符串">2、字符串</a></h2>
<ul>
<li>字符串的排列与组合</li>
<li>最长回文子串</li>
<li>正则表达式匹配：实现一个函数用来匹配包括'.'和'*'的正则表达式</li>
<li>替换空格</li>
<li>字符串的翻转和旋转及其应用</li>
<li>字符串解码</li>
<li>无重复字符的最长子串</li>
<li>字符串的最长公共子串和最长公共子序列</li>
<li>请实现一个函数用来判断字符串是否表示数值</li>
<li>判断一个字符串是否是一个合法的</li>
</ul>
<h2><a class="header" href="#3哈希表" id="3哈希表">3、哈希表</a></h2>
<ul>
<li>手写一个简单的 HashMap</li>
<li>和为 K 的子数组：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数</li>
<li>一种接收消息并按顺序打印的结构设计</li>
<li>哈希表增加 setAll 功能</li>
</ul>
<h2><a class="header" href="#4栈" id="4栈">4、栈</a></h2>
<ul>
<li>用固定大小的数组实现栈</li>
<li>如何仅用队列实现栈</li>
<li>最小值栈：能够返回栈中最小元素的栈</li>
<li>栈的压入、弹出序列：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序</li>
<li>单调栈结构的实现</li>
<li>直方图中的最大矩形面积</li>
<li>求最大子矩阵的大小</li>
<li>可见山峰问题</li>
</ul>
<h2><a class="header" href="#5队列" id="5队列">5、队列</a></h2>
<ul>
<li>用固定大小的数组实现队列</li>
<li>如何仅用栈结构实现队列</li>
</ul>
<h2><a class="header" href="#6链表" id="6链表">6、链表</a></h2>
<ul>
<li>反转单向链表</li>
<li>反转双向链表</li>
<li>K 个一组翻转链表</li>
<li>合并两个排序的链表</li>
<li>链表中倒数第 K 个节点</li>
<li>O(1) 时间内删除一个节点</li>
<li>删除链表中重复的节点</li>
<li>从尾到头打印链表</li>
<li>判断一个链表是否为回文结构</li>
<li>给出两个有序链表的头结点，打印出两个链表中相同的元素</li>
<li>将单向链表按某值划分成左边小、中间相等、右边大的形式</li>
<li>复制含有随机指针节点的链表</li>
<li>两个单链表相交的一系列问题</li>
<li>链表中环的入口节点</li>
<li>复杂链表的复制</li>
</ul>
<h2><a class="header" href="#7树" id="7树">7、树</a></h2>
<ul>
<li>二叉树的前序、中序、后序遍历的递归实现</li>
<li>二叉树的前序、中序、后序遍历的非递归实现</li>
<li>二叉树的层序遍历</li>
<li>Morris 遍历二叉树：前序、中序、后序</li>
<li>输入一个数组，判断是不是二叉搜索树的后序遍历序列</li>
<li>二叉树的序列化：前序、层序</li>
<li>反序列化：怎么序列化的就怎么反序列化</li>
<li>在二叉树中找一个节点的后继节点</li>
<li>判断一棵树是否是完全二叉树</li>
<li>判断一棵树是否是搜索二叉树</li>
<li>判断一棵树是否是平衡二叉树</li>
<li>判断一棵树是否是对称的二叉树</li>
<li>二叉树的镜像</li>
<li>树的子结构：输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构</li>
<li>合并二叉树</li>
<li>二叉树中和为某一值的路径</li>
<li>重建二叉树：输入某二叉树的前序遍历和中序遍历的结果，请重新构造出该二叉树</li>
<li>求一棵完全二叉树的节点个数，时间复杂度低于O(N)</li>
<li>找二叉树左下角的值</li>
<li>把二叉搜索树转换为累加树</li>
<li>舞会的最大活跃度</li>
<li>求一棵二叉树中最大二叉搜索子树的节点个数</li>
<li>求一个二叉树的最远距离</li>
<li>二叉树的最大路径和</li>
<li>求二叉树节点和为N的所有路径。</li>
<li>实现二叉树的镜像。</li>
<li>实现两棵二叉树相加生成一棵新的二叉树。</li>
<li>实现单链表的递归逆置和非递归逆置。</li>
<li>二分查找变种问题。</li>
<li>二叉树的后序非递归遍历。</li>
<li>两个无序整型数组交换元素使得两数组和差距最小。</li>
<li>给定整型数组和目标数输出数组所有两数之和为目标数的组合。</li>
<li>找到带权重二叉树中从根到叶子的最大和路径。</li>
<li>最长公共子序列LCS问题。</li>
<li>二叉树中找到指定两个节点最近公共祖先。</li>
<li>实现堆排序求Top10数据。</li>
<li>实现最小栈。</li>
<li>简述并尝试设计一个布隆过滤器。</li>
<li>外排序的基本实现过程。</li>
<li>常见排序算法的性能对比。</li>
<li>快速排序的非递归实现</li>
</ul>
<h1><a class="header" href="#一计算机网络" id="一计算机网络">一、计算机网络</a></h1>
<ul>
<li>谈谈你对五层网络协议的理解？每一层的作用是什么？每一层的数据单元是什么？</li>
<li>简单说下每一层对应的网络协议有哪些？</li>
<li>ARP 协议的工作原理？</li>
<li>谈下你对 IP 地址分类的理解？</li>
<li>TCP 和 UDP 的区别？</li>
<li>TCP 和 UDP 分别对应的常见应用层协议有哪些？</li>
<li>详细说下 TCP 三次握手的过程？</li>
<li>为什么两次握手不可以？为什么不需要四次握手？</li>
<li>为什么要回传 SYN？ 为什么要传 ACK？</li>
<li>详细说下 TCP 四次挥手的过程？</li>
<li>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</li>
<li>为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?</li>
<li>保活计时器的作用？</li>
<li>TCP 协议是如何保证可靠传输的？</li>
<li>谈谈你对停止等待协议的理解？</li>
<li>谈谈你对 ARQ 协议的理解？</li>
<li>滑动窗口有什么作用？</li>
<li>谈下你对 TCP 拥塞控制的理解？四种算法？</li>
<li>TCP 黏包是怎么产生的？怎么解决？</li>
<li>说几个你知道的 HTTP 状态码？</li>
<li>HTTP 状态码 301 和 302 代表的是什么？有什么区别？</li>
<li>forward 和 redirect 的区别？</li>
<li>HTTP 方法有哪些？</li>
<li>说下 GET 和 POST 的区别？</li>
<li>HTTP 的首部字段有哪些？</li>
<li>在浏览器中输入 URL 地址到显示主页的过程？</li>
<li>说下 DNS 解析的过程？</li>
<li>谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</li>
<li>谈下 HTTP1.0 和 1.1、1.2 的主要变化？</li>
<li>HTTPS 的工作过程？</li>
<li>HTTP 和 HTTPS 的区别？</li>
<li>HTTPS 的优缺点？</li>
<li>什么是数字签名？什么是证书？</li>
<li>什么是对称加密和非对称加密？</li>
<li>常用的加密算法有哪些？</li>
<li>Session 和 Cookie 的区别？</li>
<li>什么是 CAS 单点登录？</li>
<li>如何设计一个 CAS 单点登录系统？</li>
<li>Socket 两个典型的接收方式方式？</li>
<li>Socket 在 OSI七 层模型中的哪一层？</li>
<li>Java 如何实现无阻塞方式的 Socket 编程？</li>
<li>说下你知道你知道的攻击手段有哪些？</li>
<li>跨站脚本攻击的原理、危害和防范手段？</li>
<li>跨站请求伪造的原理、危害和防范手段？</li>
<li>SQL 注入攻击的原理、危害和防范手段？</li>
<li>拒绝服务攻击 DOS 的原理、危害和防范手段？</li>
</ul>
<h1><a class="header" href="#二计算机操作系统" id="二计算机操作系统">二、计算机操作系统</a></h1>
<ul>
<li>进程与线程的区别？</li>
<li>进程的状态及其转换？</li>
<li>进程间的通信方式有哪些？</li>
<li>进程（或作业）的调度算法有哪些？</li>
<li>同步和互斥的区别？</li>
<li>同步、异步、阻塞、非阻塞的区别？</li>
<li>线程/进程同步的方式有哪些？</li>
<li>什么是缓冲区溢出，有什么危害，原因是什么？</li>
<li>什么是死锁？</li>
<li>死锁产生的必要条件？</li>
<li>死锁的检测和消除？</li>
<li>怎么处理死锁？</li>
<li>怎么预防死锁？</li>
<li>怎么避免死锁？</li>
<li>固定分区、动态分区、分段式存储管理和分页式存储管理的区别？</li>
<li>页面置换算法有哪些？</li>
<li>什么是虚拟内存技术？</li>
<li>动态链接库和静态链接库的区别？</li>
<li>说下你对磁盘结构的认识？</li>
<li>磁盘调度算法？</li>
<li>中断的类型有哪些？</li>
<li>七、设计模式</li>
<li>简单说下常用的设计模式有哪些？</li>
<li>工厂方法模式和抽象工厂模式有什么区别？</li>
<li>实际开发中用过设计模式吗？怎么用的？</li>
<li>解释器、迭代器、观察者、适配器、组合、外观、代理等模式的原理是什么？</li>
<li>文件目录采用的是哪种设计模式？</li>
<li>JDK 中用到了哪些设计模式？</li>
<li>Spring 中用到了哪些设计模式？</li>
</ul>
<h1><a class="header" href="#三linux系统" id="三linux系统">三、Linux系统</a></h1>
<ul>
<li>LVS实现负载均衡的原理。</li>
<li>简述Linux内存管理原理以及伙伴算法和Slab算法。</li>
<li>select和epoll的对比以及epoll实现的底层原理和数据结构。</li>
<li>epoll的LT模式和ET模式下读写操作，实现一下ET模式的read/write。</li>
<li>使用C++简单实现一个生产者消费者模型。</li>
<li>Linux虚拟内存和物理内存的区别与联系</li>
<li>如何使用gdb调试多进程、多线程程序。</li>
<li>谈谈C10K和C10M问题及大致实现思路。</li>
<li>Linux地址复用和端口复用的使用。</li>
<li>谈谈Reactor和Proactor模式区别与联系。</li>
<li>尝试基于epoll实现一个高并发网络框架。</li>
<li>Nginx的基本原理以及负载均衡实现方法。</li>
<li>谈谈Linux服务器内存/cpu/磁盘/网络带宽的监控命令和问题排查。</li>
<li>谈谈CAP理论以及分布式一致性算法。</li>
<li>了解CpuCache吗，如何据此来优化代码。</li>
<li>读写锁、RCU锁、自旋锁的对比以及设计读优先/写优先的读写锁</li>
<li>自己设计实现一个简单的读写锁。</li>
<li>谈谈grpc的使用以及brpc的对比。</li>
<li>对比协程和进线程，重点说明系统开销差异和各自优缺点。</li>
<li>谈谈对线程同步和多线程安全的理解。</li>
<li>Https的C/S交互过程、http1.0/2.0/3.0的对比。</li>
<li>多进程通信的方法和对比。</li>
<li>多线程同步的实现和线程安全。</li>
<li>实现一个基于LRU的本地缓存。</li>
<li>TCP/IP的拥塞控制原理和缺陷、BBR算法对比。</li>
<li>使用Python实现多进程和多线程以及谈谈对GIL的理解。</li>
<li>网络攻击有哪些？简述DDos、CC攻击。</li>
<li>对比内存分配malloc/tcmalloc/ptmalloc。</li>
<li>Protobuf协议的简单原理和使用。</li>
<li>Coredump的常见原因。</li>
<li>死锁的原理以及写一个死锁。</li>
<li>MapReduce的基本原理、写个简单的map和reduce的程序。</li>
<li>同步异步阻塞非阻塞IO的理解。</li>
<li>git的基本原理以及常用命令。</li>
<li>局部性hash算法simhash的原理。</li>
<li>服务端长短连接的区别、优势和场景。</li>
<li>如何避免多线程的虚假唤醒问题。</li>
<li>实现简单的线程池和连接池。</li>
<li>实现一个可以完成C10K+的TCP网络框架。</li>
<li>尝试多种方法实现一个守护进程，2 magic fork了解吗？</li>
<li>惊群问题知道吗？Nginx是如何解决的？</li>
<li>谈谈对服务治理和服务发现的理解。</li>
<li>微服务接触过吗？谈谈对微服务的理解。</li>
<li>服务异步化编程了解过吗？</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F">集中式与分布式</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E5%99%A8">中心服务器</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#%E5%B7%A5%E4%BD%9C%E6%B5%81">工作流</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#%E5%88%86%E6%94%AF%E5%AE%9E%E7%8E%B0">分支实现</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#%E5%86%B2%E7%AA%81">冲突</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#fast-forward">Fast forward</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#%E5%82%A8%E8%97%8Fstashing">储藏（Stashing）</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#ssh-%E4%BC%A0%E8%BE%93%E8%AE%BE%E7%BD%AE">SSH 传输设置</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#gitignore-%E6%96%87%E4%BB%B6">.gitignore 文件</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#git-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88">Git 命令一览</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Git.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#集中式与分布式" id="集中式与分布式">集中式与分布式</a></h1>
<p>Git 属于分布式版本控制系统，而 SVN 属于集中式。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200656794.png"/> </div><br>
<p>集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。</p>
<p>集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。</p>
<p>集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。</p>
<p>分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。</p>
<h1><a class="header" href="#中心服务器" id="中心服务器">中心服务器</a></h1>
<p>中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。</p>
<p>Github 就是一个中心服务器。</p>
<h1><a class="header" href="#工作流" id="工作流">工作流</a></h1>
<p>新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。</p>
<p>Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208195941661.png"/> </div><br>
<ul>
<li>git add files 把文件的修改添加到暂存区</li>
<li>git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了</li>
<li>git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files</li>
<li>git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200014395.png"/> </div><br>
<p>可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。</p>
<ul>
<li>git commit -a 直接把所有文件的修改添加到暂存区然后执行提交</li>
<li>git checkout HEAD -- files 取出最后一次修改，可以用来进行回滚操作</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200543923.png"/> </div><br>
<h1><a class="header" href="#分支实现" id="分支实现">分支实现</a></h1>
<p>使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203219927.png"/> </div><br>
<p>新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支，表示新分支成为当前分支。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203142527.png"/> </div><br>
<p>每次提交只会让当前分支指针向前移动，而其它分支指针不会移动。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203112400.png"/> </div><br>
<p>合并分支也只需要改变指针即可。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203010540.png"/> </div><br>
<h1><a class="header" href="#冲突" id="冲突">冲突</a></h1>
<p>当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203034705.png"/> </div><br>
<p>Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
</code></pre>
<h1><a class="header" href="#fast-forward" id="fast-forward">Fast forward</a></h1>
<p>&quot;快进式合并&quot;（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。</p>
<p>可以在合并时加上 --no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。</p>
<pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
</code></pre>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203639712.png"/> </div><br>
<h1><a class="header" href="#储藏stashing" id="储藏stashing">储藏（Stashing）</a></h1>
<p>在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。</p>
<p>可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p>
<pre><code>$ git stash
Saved working directory and index state \ &quot;WIP on master: 049d078 added the index file&quot;
HEAD is now at 049d078 added the index file (To restore them type &quot;git stash apply&quot;)
</code></pre>
<p>该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。</p>
<h1><a class="header" href="#ssh-传输设置" id="ssh-传输设置">SSH 传输设置</a></h1>
<p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p>
<p>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
</code></pre>
<p>然后把公钥 id_rsa.pub 的内容复制到 Github &quot;Account settings&quot; 的 SSH Keys 中。</p>
<h1><a class="header" href="#gitignore-文件" id="gitignore-文件">.gitignore 文件</a></h1>
<p>忽略以下文件：</p>
<ul>
<li>操作系统自动生成的文件，比如缩略图；</li>
<li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li>
<li>自己的敏感信息，比如存放口令的配置文件。</li>
</ul>
<p>不需要全部自己编写，可以到 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 中进行查询。</p>
<h1><a class="header" href="#git-命令一览" id="git-命令一览">Git 命令一览</a></h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a29acce-f243-4914-9f00-f2988c528412.jpg" width=""> </div><br>
<p>比较详细的地址：http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf</p>
<h1><a class="header" href="#参考资料-12" id="参考资料-12">参考资料</a></h1>
<ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git - 简明指南</a></li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰 : Git 教程</a></li>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a></li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E4%B8%80%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">一、可读性的重要性</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E4%BA%8C%E7%94%A8%E5%90%8D%E5%AD%97%E8%A1%A8%E8%BE%BE%E4%BB%A3%E7%A0%81%E5%90%AB%E4%B9%89">二、用名字表达代码含义</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E4%B8%89%E5%90%8D%E5%AD%97%E4%B8%8D%E8%83%BD%E5%B8%A6%E6%9D%A5%E6%AD%A7%E4%B9%89">三、名字不能带来歧义</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%9B%9B%E8%89%AF%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC">四、良好的代码风格</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E4%BA%94%E4%B8%BA%E4%BD%95%E7%BC%96%E5%86%99%E6%B3%A8%E9%87%8A">五、为何编写注释</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%85%AD%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B3%A8%E9%87%8A">六、如何编写注释</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E4%B8%83%E6%8F%90%E9%AB%98%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7">七、提高控制流的可读性</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%85%AB%E6%8B%86%E5%88%86%E9%95%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F">八、拆分长表达式</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E4%B9%9D%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E8%AF%BB%E6%80%A7">九、变量与可读性</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%8D%81%E6%8A%BD%E5%8F%96%E5%87%BD%E6%95%B0">十、抽取函数</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%8D%81%E4%B8%80%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B">十一、一次只做一件事</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%8D%81%E4%BA%8C%E7%94%A8%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E8%A1%A8%E8%BF%B0%E4%BB%A3%E7%A0%81">十二、用自然语言表述代码</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%8D%81%E4%B8%89%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8F">十三、减少代码量</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一可读性的重要性" id="一可读性的重要性">一、可读性的重要性</a></h1>
<p>编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。</p>
<p>可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。</p>
<p>只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。</p>
<h1><a class="header" href="#二用名字表达代码含义" id="二用名字表达代码含义">二、用名字表达代码含义</a></h1>
<p>一些比较有表达力的单词：</p>
<table><thead><tr><th align="center">单词</th><th>可替代单词</th></tr></thead><tbody>
<tr><td align="center">send</td><td>deliver、dispatch、announce、distribute、route</td></tr>
<tr><td align="center">find</td><td>search、extract、locate、recover</td></tr>
<tr><td align="center">start</td><td>launch、create、begin、open</td></tr>
<tr><td align="center">make</td><td>create、set up、build、generate、compose、add、new</td></tr>
</tbody></table>
<p>使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。</p>
<p>为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。</p>
<h1><a class="header" href="#三名字不能带来歧义" id="三名字不能带来歧义">三、名字不能带来歧义</a></h1>
<p>起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。</p>
<p>布尔相关的命名加上 is、can、should、has 等前缀。</p>
<ul>
<li>
<p>用 min、max 表示数量范围；</p>
</li>
<li>
<p>用 first、last 表示访问空间的包含范围；</p>
</li>
<li>
<p>begin、end 表示访问空间的排除范围，即 end 不包含尾部。</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209003453268.png"/> </div><br>
<h1><a class="header" href="#四良好的代码风格" id="四良好的代码风格">四、良好的代码风格</a></h1>
<p>适当的空行和缩进。</p>
<p>排列整齐的注释：</p>
<pre><code class="language-java">int a = 1;   // 注释
int b = 11;  // 注释
int c = 111; // 注释
</code></pre>
<p>语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。</p>
<h1><a class="header" href="#五为何编写注释" id="五为何编写注释">五、为何编写注释</a></h1>
<p>阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</p>
<p>不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。</p>
<p>可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。</p>
<p>注释用来提醒一些特殊情况。</p>
<p>用 TODO 等做标记：</p>
<table><thead><tr><th>标记</th><th>用法</th></tr></thead><tbody>
<tr><td>TODO</td><td>待做</td></tr>
<tr><td>FIXME</td><td>待修复</td></tr>
<tr><td>HACK</td><td>粗糙的解决方案</td></tr>
<tr><td>XXX</td><td>危险！这里有重要的问题</td></tr>
</tbody></table>
<h1><a class="header" href="#六如何编写注释" id="六如何编写注释">六、如何编写注释</a></h1>
<p>尽量简洁明了：</p>
<pre><code class="language-java">// The first String is student's name
// The Second Integer is student's score
Map&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;();
</code></pre>
<pre><code class="language-java">// Student's name -&gt; Student's score
Map&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;();
</code></pre>
<p>添加测试用例来说明：</p>
<pre><code class="language-java">// ...
// Example: add(1, 2), return 3
int add(int x, int y) {
    return x + y;
}
</code></pre>
<p>使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。</p>
<h1><a class="header" href="#七提高控制流的可读性" id="七提高控制流的可读性">七、提高控制流的可读性</a></h1>
<p>条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确：</p>
<pre><code class="language-java">if (len &lt; 10)
if (10 &gt; len)
</code></pre>
<p>只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else；</p>
<p>do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。</p>
<p>如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。</p>
<p>在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。</p>
<h1><a class="header" href="#八拆分长表达式" id="八拆分长表达式">八、拆分长表达式</a></h1>
<p>长表达式的可读性很差，可以引入一些解释变量从而拆分表达式：</p>
<pre><code class="language-python">if line.split(':')[0].strip() == &quot;root&quot;:
    ...
</code></pre>
<pre><code class="language-python">username = line.split(':')[0].strip()
if username == &quot;root&quot;:
    ...
</code></pre>
<p>使用摩根定理简化一些逻辑表达式：</p>
<pre><code class="language-java">if (!a &amp;&amp; !b) {
    ...
}
</code></pre>
<pre><code class="language-java">if (!(a || b)) {
    ...
}
</code></pre>
<h1><a class="header" href="#九变量与可读性" id="九变量与可读性">九、变量与可读性</a></h1>
<p><strong>去除控制流变量</strong>  。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。</p>
<pre><code class="language-java">boolean done = false;
while (/* condition */ &amp;&amp; !done) {
    ...
    if ( ... ) {
        done = true;
        continue;
    }
}
</code></pre>
<pre><code class="language-java">while(/* condition */) {
    ...
    if ( ... ) {
        break;
    }
}
</code></pre>
<p><strong>减小变量作用域</strong>  。作用域越小，越容易定位到变量所有使用的地方。</p>
<p>JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。</p>
<pre><code class="language-js">submitted = false;
var submit_form = function(form_name) {
    if (submitted) {
        return;
    }
    submitted = true;
};
</code></pre>
<pre><code class="language-js">var submit_form = (function() {
    var submitted = false;
    return function(form_name) {
        if(submitted) {
            return;
        }
        submitted = true;
    }
}());  // () 使得外层匿名函数立即执行
</code></pre>
<p>JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。</p>
<p>变量定义的位置应当离它使用的位置最近。</p>
<p><strong>实例解析</strong></p>
<p>在一个网页中有以下文本输入字段：</p>
<pre><code class="language-html">&lt;input type = &quot;text&quot; id = &quot;input1&quot; value = &quot;a&quot;&gt;
&lt;input type = &quot;text&quot; id = &quot;input2&quot; value = &quot;b&quot;&gt;
&lt;input type = &quot;text&quot; id = &quot;input3&quot; value = &quot;&quot;&gt;
&lt;input type = &quot;text&quot; id = &quot;input4&quot; value = &quot;d&quot;&gt;
</code></pre>
<p>现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下：</p>
<pre><code class="language-js">var setFirstEmptyInput = function(new_alue) {
    var found = false;
    var i = 1;
    var elem = document.getElementById('input' + i);
    while (elem != null) {
        if (elem.value === '') {
            found = true;
            break;
        }
        i++;
        elem = document.getElementById('input' + i);
    }
    if (found) elem.value = new_value;
    return elem;
}
</code></pre>
<p>以上实现有以下问题：</p>
<ul>
<li>found 可以去除；</li>
<li>elem 作用域过大；</li>
<li>可以用 for 循环代替 while 循环；</li>
</ul>
<pre><code class="language-js">var setFirstEmptyInput = function(new_value) {
    for (var i = 1; true; i++) {
        var elem = document.getElementById('input' + i);
        if (elem === null) {
            return null;
        }
        if (elem.value === '') {
            elem.value = new_value;
            return elem;
        }
    }
};
</code></pre>
<h1><a class="header" href="#十抽取函数" id="十抽取函数">十、抽取函数</a></h1>
<p>工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。</p>
<p>首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。</p>
<p>介绍性的代码：</p>
<pre><code class="language-java">int findClostElement(int[] arr) {
    int clostIdx;
    int clostDist = Interger.MAX_VALUE;
    for (int i = 0; i &lt; arr.length; i++) {
        int x = ...;
        int y = ...;
        int z = ...;
        int value = x * y * z;
        int dist = Math.sqrt(Math.pow(value, 2), Math.pow(arr[i], 2));
        if (dist &lt; clostDist) {
            clostIdx = i;
            clostDist = value;
        }
    }
    return clostIdx;
}
</code></pre>
<p>以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。</p>
<pre><code class="language-java">public int findClostElement(int[] arr) {
    int clostIdx;
    int clostDist = Interger.MAX_VALUE;
    for (int i = 0; i &lt; arr.length; i++) {
        int dist = computDist(arr, i);
        if (dist &lt; clostDist) {
            clostIdx = i;
            clostDist = value;
        }
    }
    return clostIdx;
}
</code></pre>
<p>并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。</p>
<p>函数抽取也用于减小代码的冗余。</p>
<h1><a class="header" href="#十一一次只做一件事" id="十一一次只做一件事">十一、一次只做一件事</a></h1>
<p>只做一件事的代码很容易让人知道其要做的事；</p>
<p>基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。</p>
<h1><a class="header" href="#十二用自然语言表述代码" id="十二用自然语言表述代码">十二、用自然语言表述代码</a></h1>
<p>先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。</p>
<h1><a class="header" href="#十三减少代码量" id="十三减少代码量">十三、减少代码量</a></h1>
<p>不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。</p>
<p>多用标准库实现。</p>
<h1><a class="header" href="#参考资料-13" id="参考资料-13">参考资料</a></h1>
<ul>
<li>Dustin, Boswell, Trevor, 等. 编写可读代码的艺术 [M]. 机械工业出版社, 2012.</li>
</ul>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/Docker.html#%E4%B8%80%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">一、解决的问题</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Docker.html#%E4%BA%8C%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%AF%94%E8%BE%83">二、与虚拟机的比较</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Docker.html#%E4%B8%89%E4%BC%98%E5%8A%BF">三、优势</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Docker.html#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">四、使用场景</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Docker.html#%E4%BA%94%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8">五、镜像与容器</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/Docker.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一解决的问题" id="一解决的问题">一、解决的问题</a></h1>
<p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png" width="400px"/> </div><br>
<h1><a class="header" href="#二与虚拟机的比较" id="二与虚拟机的比较">二、与虚拟机的比较</a></h1>
<p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be608a77-7b7f-4f8e-87cc-f2237270bf69.png" width="500"/> </div><br>
<h2><a class="header" href="#启动速度" id="启动速度">启动速度</a></h2>
<p>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</p>
<p>而启动 Docker 相当于启动宿主操作系统上的一个进程。</p>
<h2><a class="header" href="#占用资源" id="占用资源">占用资源</a></h2>
<p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</p>
<p>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p>
<h1><a class="header" href="#三优势" id="三优势">三、优势</a></h1>
<p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p>
<h2><a class="header" href="#更容易迁移" id="更容易迁移">更容易迁移</a></h2>
<p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p>
<h2><a class="header" href="#更容易维护" id="更容易维护">更容易维护</a></h2>
<p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。</p>
<h2><a class="header" href="#更容易扩展" id="更容易扩展">更容易扩展</a></h2>
<p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p>
<h1><a class="header" href="#四使用场景-1" id="四使用场景-1">四、使用场景</a></h1>
<h2><a class="header" href="#持续集成" id="持续集成">持续集成</a></h2>
<p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。</p>
<p>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p>
<h2><a class="header" href="#提供可伸缩的云服务" id="提供可伸缩的云服务">提供可伸缩的云服务</a></h2>
<p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p>
<h2><a class="header" href="#搭建微服务架构" id="搭建微服务架构">搭建微服务架构</a></h2>
<p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p>
<h1><a class="header" href="#五镜像与容器" id="五镜像与容器">五、镜像与容器</a></h1>
<p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p>
<p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p>
<p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/docker-filesystems-busyboxrw.png"/> </div><br>
<h1><a class="header" href="#参考资料-14" id="参考资料-14">参考资料</a></h1>
<ul>
<li><a href="https://blog.docker.com/2017/08/docker-101-introduction-docker-webinar-recap/">DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></li>
<li><a href="http://www.bogotobogo.com/DevOps/Docker/Docker_Container_vs_Virtual_Machine.php">Docker container vs Virtual machine</a></li>
<li><a href="https://linoxide.com/linux-how-to/dockerfile-create-docker-container/">How to Create Docker Container using Dockerfile</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/5877964.html">理解 Docker（2）：Docker 镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html">为什么要使用 Docker？</a></li>
<li><a href="https://www.docker.com/what-docker">What is Docker</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成是什么？</a></li>
</ul>
<ul>
<li>osi七层网络模型，五层网络模型，每次层分别有哪些协议</li>
<li>死锁产生的条件， 以及如何避免死锁，银行家算法，产生死锁后如何解决</li>
<li>如何判断链表有环</li>
<li>虚拟机类加载机制，双亲委派模型，以及为什么要实现双亲委派模型</li>
<li>虚拟机调优参数</li>
<li>拆箱装箱的原理</li>
<li>JVM垃圾回收算法</li>
<li>CMS G1</li>
<li>hashset和hashmap的区别，haspmap的底层实现put操作，扩容机制，currenthashmap如何解决线程安全,1.7版本以及1.8版本的不同</li>
<li>md5加密的原理</li>
<li>有多少种方法可以让线程阻塞，能说多少说多少</li>
<li>synchronized和reetrantlock锁</li>
<li>AQS同步器框架，countdowmlatch，cyclebarrier，semaphore，读写锁</li>
<li>B-Tree索引，myisam和innodb中索引的区别</li>
<li>BIO和NIO的应用场景</li>
<li>讲讲threadlocal</li>
<li>数据库隔离级别，每层级别分别用什么方法实现，三级封锁协议,共享锁排它锁，mvcc多版本并发控制协议，间隙锁</li>
<li>数据库索引？B+树？为什么要建索引？什么样的字段需要建索引，建索引的时候一般考虑什么？索引会不会使插入、删除作效率变低，怎么解决？</li>
<li>数据库表怎么设计的？数据库范式？设计的过程中需要注意什么？</li>
<li>共享锁与非共享锁、一个事务锁住了一条数据，另一个事务能查吗？</li>
<li>Spring bean的生命周期？默认创建的模式是什么？不想单例怎么办？</li>
<li>高并发时怎么限流</li>
<li>线程池的拒接任务策略</li>
<li>HashMap和Hashtable的区别</li>
<li>实现一个保证迭代顺序的HashMap</li>
<li>说一说排序算法，稳定性，复杂度</li>
<li>说一说GC</li>
<li>JVM如何加载一个类的过程，双亲委派模型中有哪些方法？</li>
<li>TCP如何保证可靠传输？三次握手过程？</li>
<li>springboot的启动流程</li>
<li>集群、负载均衡、分布式、数据一致性的区别与关系</li>
<li>数据库如果让你来垂直和水平拆分，谁先拆分，拆分的原则有哪些(单表数据量多大拆)</li>
<li>最后谈谈Redis、Kafka、 Dubbo，各自的设计原理和应用场景</li>
</ul>
<p>ZooKeeper</p>
<ol>
<li>CAP定理</li>
<li>ZAB协议</li>
<li>Leader选举算法和流程</li>
</ol>
<p>Redis</p>
<ol>
<li>Redis的应用场景</li>
<li>Redis支持的数据类型（必考）</li>
<li>zset跳表的数据结构（必考）</li>
<li>Redis的数据过期策略（必考）</li>
<li>Redis的LRU过期策略的具体实现</li>
<li>如何解决Redis缓存雪崩，缓存穿透问题</li>
<li>Redis的持久化机制（必考）</li>
<li>Redis的管道pipeline</li>
</ol>
<p>Mysql</p>
<ol>
<li>事务的基本要素</li>
<li>事务隔离级别（必考）</li>
<li>如何解决事务的并发问题(脏读，幻读)（必考）</li>
<li>MVCC多版本并发控制（必考）</li>
<li>binlog,redolog,undolog都是什么，起什么作用</li>
<li>InnoDB的行锁/表锁</li>
<li>myisam和innodb的区别，什么时候选择myisam</li>
<li>为什么选择B+树作为索引结构（必考）</li>
<li>索引B+树的叶子节点都可以存哪些东西（必考）</li>
<li>查询在什么时候不走（预期中的）索引（必考）</li>
<li>sql如何优化</li>
<li>explain是如何解析sql的</li>
<li>order by原理</li>
</ol>
<p>JVM</p>
<ol>
<li>运行时数据区域（内存模型）（必考）</li>
<li>垃圾回收机制（必考）</li>
<li>垃圾回收算法（必考）</li>
<li>Minor GC和Full GC触发条件</li>
<li>GC中Stop the world（STW）</li>
<li>各垃圾回收器的特点及区别</li>
<li>双亲委派模型</li>
<li>JDBC和双亲委派模型关系</li>
<li>JVM锁优化和锁膨胀过程</li>
</ol>
<p>Java基础</p>
<ol>
<li>HashMap和ConcurrentHashMap区别（必考）</li>
<li>ConcurrentHashMap的数据结构（必考）</li>
<li>高并发HashMap的环是如何产生的</li>
<li>volatile作用（必考）</li>
<li>Atomic类如何保证原子性（CAS操作）（必考）</li>
<li>synchronized和Lock的区别（必考）</li>
<li>ThreadLocal的原理和实现</li>
<li>为什么要使用线程池（必考）</li>
<li>核心线程池ThreadPoolExecutor的参数（必考）</li>
<li>ThreadPoolExecutor的工作流程（必考）</li>
<li>如何控制线程池线程的优先级</li>
<li>线程之间如何通信</li>
<li>Boolean占几个字节</li>
<li>jdk1.8/jdk1.7都分别新增了哪些特性</li>
<li>Exception和Error</li>
<li>Object类内的方法</li>
</ol>
<p>Spring</p>
<ol>
<li>Spring的IOC/AOP的实现（必考）</li>
<li>动态代理的实现方式（必考）</li>
<li>Spring如何解决循环依赖（三级缓存）（必考）</li>
<li>Spring的后置处理器</li>
<li>Spring的@Transactional如何实现的（必考）</li>
<li>Spring的事务传播级别</li>
<li>BeanFactory和ApplicationContext的联系和区别</li>
</ol>
<p>其他</p>
<ol>
<li>高并发系统的限流如何实现</li>
<li>高并发秒杀系统的设计</li>
<li>负载均衡如何设计</li>
</ol>
<p>一、Java 基础</p>
<p>1.JDK 和 JRE 有什么区别？</p>
<p>2.== 和 equals 的区别是什么？</p>
<p>3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</p>
<p>4.final 在 java 中有什么作用？</p>
<p>5.java 中的 Math.round(-1.5) 等于多少？</p>
<p>6.String 属于基础的数据类型吗？</p>
<p>7.java 中操作字符串都有哪些类？它们之间有什么区别？</p>
<p>8.String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</p>
<p>9.如何将字符串反转？</p>
<p>10.String 类的常用方法都有那些？</p>
<p>11.抽象类必须要有抽象方法吗？</p>
<p>12.普通类和抽象类有哪些区别？</p>
<p>13.抽象类能使用 final 修饰吗？</p>
<p>14.接口和抽象类有什么区别？</p>
<p>15.java 中 IO 流分为几种？</p>
<p>16.BIO、NIO、AIO 有什么区别？</p>
<p>17.Files的常用方法都有哪些？</p>
<p>二、容器</p>
<p>18.java 容器都有哪些？</p>
<p>19.Collection 和 Collections 有什么区别？</p>
<p>20.List、Set、Map 之间的区别是什么？</p>
<p>21.HashMap 和 Hashtable 有什么区别？</p>
<p>22.如何决定使用 HashMap 还是 TreeMap？</p>
<p>23.说一下 HashMap 的实现原理？</p>
<p>24.说一下 HashSet 的实现原理？</p>
<p>25.ArrayList 和 LinkedList 的区别是什么？</p>
<p>26.如何实现数组和 List 之间的转换？</p>
<p>27.ArrayList 和 Vector 的区别是什么？</p>
<p>28.Array 和 ArrayList 有何区别？</p>
<p>29.在 Queue 中 poll()和 remove()有什么区别？</p>
<p>30.哪些集合类是线程安全的？</p>
<p>31.迭代器 Iterator 是什么？</p>
<p>32.Iterator 怎么使用？有什么特点？</p>
<p>33.Iterator 和 ListIterator 有什么区别？</p>
<p>34.怎么确保一个集合不能被修改？</p>
<p>三、多线程</p>
<p>35.并行和并发有什么区别？</p>
<p>36.线程和进程的区别？</p>
<p>37.守护线程是什么？</p>
<p>38.创建线程有哪几种方式？</p>
<p>39.说一下 runnable 和 callable 有什么区别？</p>
<p>40.线程有哪些状态？</p>
<p>41.sleep() 和 wait() 有什么区别？</p>
<p>42.notify()和 notifyAll()有什么区别？</p>
<p>43.线程的 run()和 start()有什么区别？</p>
<p>44.创建线程池有哪几种方式？</p>
<p>45.线程池都有哪些状态？</p>
<p>46.线程池中 submit()和 execute()方法有什么区别？</p>
<p>47.在 java 程序中怎么保证多线程的运行安全？</p>
<p>48.多线程锁的升级原理是什么？</p>
<p>49.什么是死锁？</p>
<p>50.怎么防止死锁？</p>
<p>51.ThreadLocal 是什么？有哪些使用场景？</p>
<p>52.说一下 synchronized 底层实现原理？</p>
<p>53.synchronized 和 volatile 的区别是什么？</p>
<p>54.synchronized 和 Lock 有什么区别？</p>
<p>55.synchronized 和 ReentrantLock 区别是什么？</p>
<p>56.说一下 atomic 的原理？</p>
<p>四、反射</p>
<p>57.什么是反射？</p>
<p>58.什么是 java 序列化？什么情况下需要序列化？</p>
<p>59.动态代理是什么？有哪些应用？</p>
<p>60.怎么实现动态代理？</p>
<p>五、对象拷贝</p>
<p>61.为什么要使用克隆？</p>
<p>62.如何实现对象克隆？</p>
<p>63.深拷贝和浅拷贝区别是什么？</p>
<p>六、Java Web</p>
<p>64.jsp 和 servlet 有什么区别？</p>
<p>65.jsp 有哪些内置对象？作用分别是什么？</p>
<p>66.说一下 jsp 的 4 种作用域？</p>
<p>67.session 和 cookie 有什么区别？</p>
<p>68.说一下 session 的工作原理？</p>
<p>69.如果客户端禁止 cookie 能实现 session 还能用吗？</p>
<p>70.spring mvc 和 struts 的区别是什么？</p>
<p>71.如何避免 sql 注入？</p>
<p>72.什么是 XSS 攻击，如何避免？</p>
<p>73.什么是 CSRF 攻击，如何避免？</p>
<p>七、异常</p>
<p>74.throw 和 throws 的区别？</p>
<p>75.final、finally、finalize 有什么区别？</p>
<p>76.try-catch-finally 中哪个部分可以省略？</p>
<p>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</p>
<p>78.常见的异常类有哪些？</p>
<p>八、网络</p>
<p>79.http 响应码 301 和 302 代表的是什么？有什么区别？</p>
<p>80.forward 和 redirect 的区别？</p>
<p>81.简述 tcp 和 udp的区别？</p>
<p>82.tcp 为什么要三次握手，两次不行吗？为什么？</p>
<p>83.说一下 tcp 粘包是怎么产生的？</p>
<p>84.OSI 的七层模型都有哪些？</p>
<p>85.get 和 post 请求有哪些区别？</p>
<p>86.如何实现跨域？</p>
<p>87.说一下 JSONP 实现原理？</p>
<p>九、设计模式</p>
<p>88.说一下你熟悉的设计模式？</p>
<p>89.简单工厂和抽象工厂有什么区别？</p>
<p>十、Spring/Spring MVC</p>
<p>90.为什么要使用 spring？</p>
<p>91.解释一下什么是 aop？</p>
<p>92.解释一下什么是 ioc？</p>
<p>93.spring 有哪些主要模块？</p>
<p>94.spring 常用的注入方式有哪些？</p>
<p>95.spring 中的 bean 是线程安全的吗？</p>
<p>96.spring 支持几种 bean 的作用域？</p>
<p>97.spring 自动装配 bean 有哪些方式？</p>
<p>98.spring 事务实现方式有哪些？</p>
<p>99.说一下 spring 的事务隔离？</p>
<p>100.说一下 spring mvc 运行流程？</p>
<p>101.spring mvc 有哪些组件？</p>
<p>102.@RequestMapping 的作用是什么？</p>
<p>103.@Autowired 的作用是什么？</p>
<p>十一、Spring Boot/Spring Cloud</p>
<p>104.什么是 spring boot？</p>
<p>105.为什么要用 spring boot？</p>
<p>106.spring boot 核心配置文件是什么？</p>
<p>107.spring boot 配置文件有哪几种类型？它们有什么区别？</p>
<p>108.spring boot 有哪些方式可以实现热部署？</p>
<p>109.jpa 和 hibernate 有什么区别？</p>
<p>110.什么是 spring cloud？</p>
<p>111.spring cloud 断路器的作用是什么？</p>
<p>112.spring cloud 的核心组件有哪些？</p>
<p>十二、Hibernate</p>
<p>113.为什么要使用 hibernate？</p>
<p>114.什么是 ORM 框架？</p>
<p>115.hibernate 中如何在控制台查看打印的 sql 语句？</p>
<p>116.hibernate 有几种查询方式？</p>
<p>117.hibernate 实体类可以被定义为 final 吗？</p>
<p>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？</p>
<p>119.hibernate 是如何工作的？</p>
<p>120.get()和 load()的区别？</p>
<p>121.说一下 hibernate 的缓存机制？</p>
<p>122.hibernate 对象有哪些状态？</p>
<p>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</p>
<p>124.hibernate 实体类必须要有无参构造函数吗？为什么？</p>
<p>十三、Mybatis</p>
<p>125.mybatis 中 #{}和 ${}的区别是什么？</p>
<p>126.mybatis 有几种分页方式？</p>
<p>127.RowBounds 是一次性查询全部结果吗？为什么？</p>
<p>128.mybatis 逻辑分页和物理分页的区别是什么？</p>
<p>129.mybatis 是否支持延迟加载？延迟加载的原理是什么？</p>
<p>130.说一下 mybatis 的一级缓存和二级缓存？</p>
<p>131.mybatis 和 hibernate 的区别有哪些？</p>
<p>132.mybatis 有哪些执行器（Executor）？</p>
<p>133.mybatis 分页插件的实现原理是什么？</p>
<p>134.mybatis 如何编写一个自定义插件？</p>
<p>十四、RabbitMQ</p>
<p>135.rabbitmq 的使用场景有哪些？</p>
<p>136.rabbitmq 有哪些重要的角色？</p>
<p>137.rabbitmq 有哪些重要的组件？</p>
<p>138.rabbitmq 中 vhost 的作用是什么？</p>
<p>139.rabbitmq 的消息是怎么发送的？</p>
<p>140.rabbitmq 怎么保证消息的稳定性？</p>
<p>141.rabbitmq 怎么避免消息丢失？</p>
<p>142.要保证消息持久化成功的条件有哪些？</p>
<p>143.rabbitmq 持久化有什么缺点？</p>
<p>144.rabbitmq 有几种广播类型？</p>
<p>145.rabbitmq 怎么实现延迟消息队列？</p>
<p>146.rabbitmq 集群有什么用？</p>
<p>147.rabbitmq 节点的类型有哪些？</p>
<p>148.rabbitmq 集群搭建需要注意哪些问题？</p>
<p>149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</p>
<p>150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</p>
<p>151.rabbitmq 对集群节点停止顺序有要求吗？</p>
<p>十五、Kafka</p>
<p>152.kafka 可以脱离 zookeeper 单独使用吗？为什么？</p>
<p>153.kafka 有几种数据保留的策略？</p>
<p>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</p>
<p>155.什么情况会导致 kafka 运行变慢？</p>
<p>156.使用 kafka 集群需要注意什么？</p>
<p>十六、Zookeeper</p>
<p>157.zookeeper 是什么？</p>
<p>158.zookeeper 都有哪些功能？</p>
<p>159.zookeeper 有几种部署模式？</p>
<p>160.zookeeper 怎么保证主从节点的状态同步？</p>
<p>161.集群中为什么要有主节点？</p>
<p>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</p>
<p>163.说一下 zookeeper 的通知机制？</p>
<p>十七、MySql</p>
<p>164.数据库的三范式是什么？</p>
<p>165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</p>
<p>166.如何获取当前数据库版本？</p>
<p>167.说一下 ACID 是什么？</p>
<p>168.char 和 varchar 的区别是什么？</p>
<p>169.float 和 double 的区别是什么？</p>
<p>170.mysql 的内连接、左连接、右连接有什么区别？</p>
<p>171.mysql 索引是怎么实现的？</p>
<p>172.怎么验证 mysql 的索引是否满足需求？</p>
<p>173.说一下数据库的事务隔离？</p>
<p>174.说一下 mysql 常用的引擎？</p>
<p>175.说一下 mysql 的行锁和表锁？</p>
<p>176.说一下乐观锁和悲观锁？</p>
<p>177.mysql 问题排查都有哪些手段？</p>
<p>178.如何做 mysql 的性能优化？</p>
<p>十八、Redis</p>
<p>179.redis 是什么？都有哪些使用场景？</p>
<p>180.redis 有哪些功能？</p>
<p>181.redis 和 memecache 有什么区别？</p>
<p>182.redis 为什么是单线程的？</p>
<p>183.什么是缓存穿透？怎么解决？</p>
<p>184.redis 支持的数据类型有哪些？</p>
<p>185.redis 支持的 java 客户端都有哪些？</p>
<p>186.jedis 和 redisson 有哪些区别？</p>
<p>187.怎么保证缓存和数据库数据的一致性？</p>
<p>188.redis 持久化有几种方式？</p>
<p>189.redis 怎么实现分布式锁？</p>
<p>190.redis 分布式锁有什么缺陷？</p>
<p>191.redis 如何做内存优化？</p>
<p>192.redis 淘汰策略有哪些？</p>
<p>193.redis 常见的性能问题有哪些？该如何解决？</p>
<p>十九、JVM</p>
<p>194.说一下 jvm 的主要组成部分？及其作用？</p>
<p>195.说一下 jvm 运行时数据区？</p>
<p>196.说一下堆栈的区别？</p>
<p>197.队列和栈是什么？有什么区别？</p>
<p>198.什么是双亲委派模型？</p>
<p>199.说一下类加载的执行过程？</p>
<p>200.怎么判断对象是否可以被回收？</p>
<p>201.java 中都有哪些引用类型？</p>
<p>202.说一下 jvm 有哪些垃圾回收算法？</p>
<p>203.说一下 jvm 有哪些垃圾回收器？</p>
<p>204.详细介绍一下 CMS 垃圾回收器？</p>
<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</p>
<p>206.简述分代垃圾回收器是怎么工作的？</p>
<p>207.说一下 jvm 调优的工具？</p>
<p>208.常用的 jvm 调优的参数都有哪些？</p>
<!-- GFM-TOC -->
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html#%E4%B8%80%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">一、负载均衡</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">负载均衡算法</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html#%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0">转发实现</a></li>
</ul>
</li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html#%E4%BA%8C%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84-session-%E7%AE%A1%E7%90%86">二、集群下的 Session 管理</a>
<ul>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html#sticky-session">Sticky Session</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html#session-replication">Session Replication</a></li>
<li><a href="%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html#session-server">Session Server</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一负载均衡" id="一负载均衡">一、负载均衡</a></h1>
<p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。</p>
<p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p>
<p>负载均衡器可以用来实现高可用以及伸缩性：</p>
<ul>
<li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li>
<li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。</li>
</ul>
<p>负载均衡器运行过程包含两个部分：</p>
<ol>
<li>根据负载均衡算法得到转发的节点；</li>
<li>进行转发。</li>
</ol>
<h2><a class="header" href="#负载均衡算法" id="负载均衡算法">负载均衡算法</a></h2>
<h3><a class="header" href="#1-轮询round-robin" id="1-轮询round-robin">1. 轮询（Round Robin）</a></h3>
<p>轮询算法把每个请求轮流发送到每个服务器上。</p>
<p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9daa3616-00a4-48c4-9146-792dc8499be3.jpg" width="500px"/> </div><br>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bfea8772-d01b-4a51-8adc-edfd7d3dce84.jpg" width="500px"/> </div><br>
<h3><a class="header" href="#2-加权轮询weighted-round-robbin" id="2-加权轮询weighted-round-robbin">2. 加权轮询（Weighted Round Robbin）</a></h3>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</p>
<p>例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4ab87717-e264-4232-825d-8aaf08f14e8b.jpg" width="500px"/> </div><br>
<h3><a class="header" href="#3-最少连接least-connections" id="3-最少连接least-connections">3. 最少连接（least Connections）</a></h3>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</p>
<p>例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98deb5a-d5d4-4294-aa9b-9220d4483403.jpg" width="500px"/> </div><br>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。</p>
<p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/43d323ac-9f07-4e4a-a315-4eaf8c38766c.jpg" width="500px"/> </div><br>
<h3><a class="header" href="#4-加权最少连接weighted-least-connection" id="4-加权最少连接weighted-least-connection">4. 加权最少连接（Weighted Least Connection）</a></h3>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<h3><a class="header" href="#5-随机算法random" id="5-随机算法random">5. 随机算法（Random）</a></h3>
<p>把请求随机发送到服务器上。</p>
<p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a42ad3a7-3574-4c48-a783-ed3d08a0688a.jpg" width="500px"/> </div><br>
<h3><a class="header" href="#6-源地址哈希法-ip-hash" id="6-源地址哈希法-ip-hash">6. 源地址哈希法 (IP Hash)</a></h3>
<p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p>
<p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f399a9f-1351-4b2d-b8a4-2ebe82b1a703.jpg" width="500px"/> </div><br>
<h2><a class="header" href="#转发实现" id="转发实现">转发实现</a></h2>
<h3><a class="header" href="#1-http-重定向" id="1-http-重定向">1. HTTP 重定向</a></h3>
<p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。</p>
<p>缺点：</p>
<ul>
<li>需要两次请求，因此访问延迟比较高；</li>
<li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li>
</ul>
<p>该负载均衡转发的缺点比较明显，实际场景中很少使用它。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/02a1fbfd-7a9d-4114-95df-ca2445587a1f.jpg" width="500px"/> </div><br>
<h3><a class="header" href="#2-dns-域名解析" id="2-dns-域名解析">2. DNS 域名解析</a></h3>
<p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。</p>
<p>优点：</p>
<ul>
<li>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。</li>
</ul>
<p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2c072cc-8b17-480c-813e-18cdb3b4b51f.jpg" width="500px"/> </div><br>
<h3><a class="header" href="#3-反向代理服务器" id="3-反向代理服务器">3. 反向代理服务器</a></h3>
<p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。</p>
<p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。</p>
<p>优点：</p>
<ul>
<li>与其它功能集成在一起，部署简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li>
</ul>
<h3><a class="header" href="#4-网络层" id="4-网络层">4. 网络层</a></h3>
<p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p>
<p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。</p>
<p>优点：</p>
<ul>
<li>在内核进程中进行处理，性能比较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li>
</ul>
<h3><a class="header" href="#5-链路层" id="5-链路层">5. 链路层</a></h3>
<p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p>
<p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p>
<p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p>
<p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.jscape.com/blog/load-balancing-algorithms">Comparing Load Balancing Algorithms</a></li>
<li><a href="http://slideplayer.com/slide/6599069/#">Redirection and Load Balancing</a></li>
</ul>
<h1><a class="header" href="#二集群下的-session-管理" id="二集群下的-session-管理">二、集群下的 Session 管理</a></h1>
<p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。</p>
<h2><a class="header" href="#sticky-session" id="sticky-session">Sticky Session</a></h2>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。</p>
<p>缺点：</p>
<ul>
<li>当服务器宕机时，将丢失该服务器上的所有 Session。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1623f524-b011-40c8-b83f-eab38d538f76.png" width="400px"/> </div><br>
<h2><a class="header" href="#session-replication" id="session-replication">Session Replication</a></h2>
<p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。</p>
<p>缺点：</p>
<ul>
<li>占用过多内存；</li>
<li>同步过程占用网络带宽以及服务器处理器时间。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c6570d-c1d7-4c38-843e-ba991b2328c2.png" width="400px"/> </div><br>
<h2><a class="header" href="#session-server" id="session-server">Session Server</a></h2>
<p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。</p>
<p>优点：</p>
<ul>
<li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要去实现存取 Session 的代码。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fdc45a09-f838-4348-8959-d2c793727788.png" width="600px"/> </div><br>
<p>参考：</p>
<ul>
<li><a href="https://sivalabs.in/2018/02/session-management-using-spring-session-jdbc-datastore/">Session Management using Spring Session with JDBC DataStore</a></li>
</ul>
<h1><a class="header" href="#目录-11" id="目录-11">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#简单工厂simple-factory" id="简单工厂simple-factory">简单工厂（Simple Factory）</a></h2>
<h3><a class="header" href="#intent" id="intent">Intent</a></h3>
<p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<h3><a class="header" href="#class-diagram" id="class-diagram">Class Diagram</a></h3>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png"/> </div><br>
<h3><a class="header" href="#implementation" id="implementation">Implementation</a></h3>
<pre><code class="language-java">public interface Product {
}
</code></pre>
<pre><code class="language-java">public class ConcreteProduct implements Product {
}
</code></pre>
<pre><code class="language-java">public class ConcreteProduct1 implements Product {
}
</code></pre>
<pre><code class="language-java">public class ConcreteProduct2 implements Product {
}
</code></pre>
<p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        int type = 1;
        Product product;
        if (type == 1) {
            product = new ConcreteProduct1();
        } else if (type == 2) {
            product = new ConcreteProduct2();
        } else {
            product = new ConcreteProduct();
        }
        // do something with the product
    }
}
</code></pre>
<p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p>
<pre><code class="language-java">public class SimpleFactory {

    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        SimpleFactory simpleFactory = new SimpleFactory();
        Product product = simpleFactory.createProduct(1);
        // do something with the product
    }
}
</code></pre>
<h2><a class="header" href="#代理proxy" id="代理proxy">代理（Proxy）</a></h2>
<h3><a class="header" href="#intent-1" id="intent-1">Intent</a></h3>
<p>控制对其它对象的访问。</p>
<h3><a class="header" href="#class-diagram-1" id="class-diagram-1">Class Diagram</a></h3>
<p>代理有以下四类：</p>
<ul>
<li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png"/> </div><br>
<h3><a class="header" href="#implementation-1" id="implementation-1">Implementation</a></h3>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<pre><code class="language-java">public interface Image {
    void showImage();
}
</code></pre>
<pre><code class="language-java">public class HighResolutionImage implements Image {

    private URL imageURL;
    private long startTime;
    private int height;
    private int width;

    public int getHeight() {
        return height;
    }

    public int getWidth() {
        return width;
    }

    public HighResolutionImage(URL imageURL) {
        this.imageURL = imageURL;
        this.startTime = System.currentTimeMillis();
        this.width = 600;
        this.height = 600;
    }

    public boolean isLoad() {
        // 模拟图片加载，延迟 3s 加载完成
        long endTime = System.currentTimeMillis();
        return endTime - startTime &gt; 3000;
    }

    @Override
    public void showImage() {
        System.out.println(&quot;Real Image: &quot; + imageURL);
    }
}
</code></pre>
<pre><code class="language-java">public class ImageProxy implements Image {

    private HighResolutionImage highResolutionImage;

    public ImageProxy(HighResolutionImage highResolutionImage) {
        this.highResolutionImage = highResolutionImage;
    }

    @Override
    public void showImage() {
        while (!highResolutionImage.isLoad()) {
            try {
                System.out.println(&quot;Temp Image: &quot; + highResolutionImage.getWidth() + &quot; &quot; + highResolutionImage.getHeight());
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        highResolutionImage.showImage();
    }
}
</code></pre>
<pre><code class="language-java">public class ImageViewer {

    public static void main(String[] args) throws Exception {
        String image = &quot;http://image.jpg&quot;;
        URL url = new URL(image);
        HighResolutionImage highResolutionImage = new HighResolutionImage(url);
        ImageProxy imageProxy = new ImageProxy(highResolutionImage);
        imageProxy.showImage();
    }
}
</code></pre>
<h3><a class="header" href="#jdk" id="jdk">JDK</a></h3>
<ul>
<li>java.lang.reflect.Proxy</li>
<li>RMI</li>
</ul>
<h2><a class="header" href="#外观facade" id="外观facade">外观（Facade）</a></h2>
<h3><a class="header" href="#intent-2" id="intent-2">Intent</a></h3>
<p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3><a class="header" href="#class-diagram-2" id="class-diagram-2">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"/> </div><br>
<h3><a class="header" href="#implementation-2" id="implementation-2">Implementation</a></h3>
<p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p>
<pre><code class="language-java">public class SubSystem {
    public void turnOnTV() {
        System.out.println(&quot;turnOnTV()&quot;);
    }

    public void setCD(String cd) {
        System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);
    }

    public void startWatching(){
        System.out.println(&quot;startWatching()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Facade {
    private SubSystem subSystem = new SubSystem();

    public void watchMovie() {
        subSystem.turnOnTV();
        subSystem.setCD(&quot;a movie&quot;);
        subSystem.startWatching();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.watchMovie();
    }
}
</code></pre>
<h3><a class="header" href="#设计原则" id="设计原则">设计原则</a></h3>
<p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<!-- GFM-TOC -->
<ul>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#%E4%BA%8C%E5%88%9B%E5%BB%BA%E5%9E%8B">二、创建型</a>
<ul>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#1-%E5%8D%95%E4%BE%8Bsingleton">1. 单例（Singleton）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82simple-factory">2. 简单工厂（Simple Factory）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#3-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95factory-method">3. 工厂方法（Factory Method）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#4-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82abstract-factory">4. 抽象工厂（Abstract Factory）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#5-%E7%94%9F%E6%88%90%E5%99%A8builder">5. 生成器（Builder）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#6-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fprototype">6. 原型模式（Prototype）</a></li>
</ul>
</li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#%E4%B8%89%E8%A1%8C%E4%B8%BA%E5%9E%8B">三、行为型</a>
<ul>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#1-%E8%B4%A3%E4%BB%BB%E9%93%BEchain-of-responsibility">1. 责任链（Chain Of Responsibility）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#2-%E5%91%BD%E4%BB%A4command">2. 命令（Command）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#3-%E8%A7%A3%E9%87%8A%E5%99%A8interpreter">3. 解释器（Interpreter）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#4-%E8%BF%AD%E4%BB%A3%E5%99%A8iterator">4. 迭代器（Iterator）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#5-%E4%B8%AD%E4%BB%8B%E8%80%85mediator">5. 中介者（Mediator）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#6-%E5%A4%87%E5%BF%98%E5%BD%95memento">6. 备忘录（Memento）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#7-%E8%A7%82%E5%AF%9F%E8%80%85observer">7. 观察者（Observer）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#8-%E7%8A%B6%E6%80%81state">8. 状态（State）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#9-%E7%AD%96%E7%95%A5strategy">9. 策略（Strategy）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#10-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95template-method">10. 模板方法（Template Method）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#11-%E8%AE%BF%E9%97%AE%E8%80%85visitor">11. 访问者（Visitor）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#12-%E7%A9%BA%E5%AF%B9%E8%B1%A1null">12. 空对象（Null）</a></li>
</ul>
</li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#%E5%9B%9B%E7%BB%93%E6%9E%84%E5%9E%8B">四、结构型</a>
<ul>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#1-%E9%80%82%E9%85%8D%E5%99%A8adapter">1. 适配器（Adapter）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#2-%E6%A1%A5%E6%8E%A5bridge">2. 桥接（Bridge）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#3-%E7%BB%84%E5%90%88composite">3. 组合（Composite）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#4-%E8%A3%85%E9%A5%B0decorator">4. 装饰（Decorator）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#5-%E5%A4%96%E8%A7%82facade">5. 外观（Facade）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#6-%E4%BA%AB%E5%85%83flyweight">6. 享元（Flyweight）</a></li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#7-%E4%BB%A3%E7%90%86proxy">7. 代理（Proxy）</a></li>
</ul>
</li>
<li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1><a class="header" href="#一概述-2" id="一概述-2">一、概述</a></h1>
<p>设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。</p>
<p>拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。</p>
<h1><a class="header" href="#二创建型" id="二创建型">二、创建型</a></h1>
<h2><a class="header" href="#1-单例singleton" id="1-单例singleton">1. 单例（Singleton）</a></h2>
<h3><a class="header" href="#intent-3" id="intent-3">Intent</a></h3>
<p>确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<h3><a class="header" href="#class-diagram-3" id="class-diagram-3">Class Diagram</a></h3>
<p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png"/> </div><br>
<h3><a class="header" href="#implementation-3" id="implementation-3">Implementation</a></h3>
<h4><a class="header" href="#Ⅰ-懒汉式-线程不安全" id="Ⅰ-懒汉式-线程不安全">Ⅰ 懒汉式-线程不安全</a></h4>
<p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<pre><code class="language-java">public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
</code></pre>
<h4><a class="header" href="#Ⅱ-饿汉式-线程安全" id="Ⅱ-饿汉式-线程安全">Ⅱ 饿汉式-线程安全</a></h4>
<p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p>
<p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p>
<pre><code class="language-java">private static Singleton uniqueInstance = new Singleton();
</code></pre>
<h4><a class="header" href="#Ⅲ-懒汉式-线程安全" id="Ⅲ-懒汉式-线程安全">Ⅲ 懒汉式-线程安全</a></h4>
<p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p>
<p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p>
<pre><code class="language-java">public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
</code></pre>
<h4><a class="header" href="#Ⅳ-双重校验锁-线程安全" id="Ⅳ-双重校验锁-线程安全">Ⅳ 双重校验锁-线程安全</a></h4>
<p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p>
<p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p>
<pre><code class="language-java">public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
</code></pre>
<p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p>
<pre><code class="language-java">if (uniqueInstance == null) {
    synchronized (Singleton.class) {
        uniqueInstance = new Singleton();
    }
}
</code></pre>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h4><a class="header" href="#Ⅴ-静态内部类实现" id="Ⅴ-静态内部类实现">Ⅴ 静态内部类实现</a></h4>
<p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<pre><code class="language-java">public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
</code></pre>
<h4><a class="header" href="#Ⅵ-枚举实现" id="Ⅵ-枚举实现">Ⅵ 枚举实现</a></h4>
<pre><code class="language-java">public enum Singleton {

    INSTANCE;

    private String objName;


    public String getObjName() {
        return objName;
    }


    public void setObjName(String objName) {
        this.objName = objName;
    }


    public static void main(String[] args) {

        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName(&quot;firstName&quot;);
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName(&quot;secondName&quot;);
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());

        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code class="language-html">firstName
secondName
secondName
secondName
</code></pre>
<p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p>
<p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<ul>
<li>Logger Classes</li>
<li>Configuration Classes</li>
<li>Accesing resources in shared mode</li>
<li>Factories implemented as Singletons</li>
</ul>
<h3><a class="header" href="#jdk-1" id="jdk-1">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29">java.lang.Runtime#getRuntime()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--">java.awt.Desktop#getDesktop()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--">java.lang.System#getSecurityManager()</a></li>
</ul>
<h2><a class="header" href="#2-简单工厂simple-factory" id="2-简单工厂simple-factory">2. 简单工厂（Simple Factory）</a></h2>
<h3><a class="header" href="#intent-4" id="intent-4">Intent</a></h3>
<p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<h3><a class="header" href="#class-diagram-4" id="class-diagram-4">Class Diagram</a></h3>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png"/> </div><br>
<h3><a class="header" href="#implementation-4" id="implementation-4">Implementation</a></h3>
<pre><code class="language-java">public interface Product {
}
</code></pre>
<pre><code class="language-java">public class ConcreteProduct implements Product {
}
</code></pre>
<pre><code class="language-java">public class ConcreteProduct1 implements Product {
}
</code></pre>
<pre><code class="language-java">public class ConcreteProduct2 implements Product {
}
</code></pre>
<p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        int type = 1;
        Product product;
        if (type == 1) {
            product = new ConcreteProduct1();
        } else if (type == 2) {
            product = new ConcreteProduct2();
        } else {
            product = new ConcreteProduct();
        }
        // do something with the product
    }
}
</code></pre>
<p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p>
<pre><code class="language-java">public class SimpleFactory {

    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        SimpleFactory simpleFactory = new SimpleFactory();
        Product product = simpleFactory.createProduct(1);
        // do something with the product
    }
}
</code></pre>
<h2><a class="header" href="#3-工厂方法factory-method" id="3-工厂方法factory-method">3. 工厂方法（Factory Method）</a></h2>
<h3><a class="header" href="#intent-5" id="intent-5">Intent</a></h3>
<p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h3><a class="header" href="#class-diagram-5" id="class-diagram-5">Class Diagram</a></h3>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png"/> </div><br>
<h3><a class="header" href="#implementation-5" id="implementation-5">Implementation</a></h3>
<pre><code class="language-java">public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
        Product product = factoryMethod();
        // do something with the product
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct1();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory2 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct2();
    }
}
</code></pre>
<h3><a class="header" href="#jdk-2" id="jdk-2">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--">java.util.Calendar</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-">java.util.ResourceBundle</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--">java.text.NumberFormat</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-">java.nio.charset.Charset</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-">java.net.URLStreamHandlerFactory</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-">java.util.EnumSet</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--">javax.xml.bind.JAXBContext</a></li>
</ul>
<h2><a class="header" href="#4-抽象工厂abstract-factory" id="4-抽象工厂abstract-factory">4. 抽象工厂（Abstract Factory）</a></h2>
<h3><a class="header" href="#intent-6" id="intent-6">Intent</a></h3>
<p>提供一个接口，用于创建   <strong>相关的对象家族</strong>  。</p>
<h3><a class="header" href="#class-diagram-6" id="class-diagram-6">Class Diagram</a></h3>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png"/> </div><br>
<h3><a class="header" href="#implementation-6" id="implementation-6">Implementation</a></h3>
<pre><code class="language-java">public class AbstractProductA {
}
</code></pre>
<pre><code class="language-java">public class AbstractProductB {
}
</code></pre>
<pre><code class="language-java">public class ProductA1 extends AbstractProductA {
}
</code></pre>
<pre><code class="language-java">public class ProductA2 extends AbstractProductA {
}
</code></pre>
<pre><code class="language-java">public class ProductB1 extends AbstractProductB {
}
</code></pre>
<pre><code class="language-java">public class ProductB2 extends AbstractProductB {
}
</code></pre>
<pre><code class="language-java">public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }

    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }

    AbstractProductB createProductB() {
        return new ProductB2();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
</code></pre>
<h3><a class="header" href="#jdk-3" id="jdk-3">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html">javax.xml.parsers.DocumentBuilderFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--">javax.xml.transform.TransformerFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--">javax.xml.xpath.XPathFactory</a></li>
</ul>
<h2><a class="header" href="#5-生成器builder" id="5-生成器builder">5. 生成器（Builder）</a></h2>
<h3><a class="header" href="#intent-7" id="intent-7">Intent</a></h3>
<p>封装一个对象的构造过程，并允许按步骤构造。</p>
<h3><a class="header" href="#class-diagram-7" id="class-diagram-7">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5e376d-0b3e-490e-a43a-3231914b6668.png"/> </div><br>
<h3><a class="header" href="#implementation-7" id="implementation-7">Implementation</a></h3>
<p>以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。</p>
<pre><code class="language-java">public class AbstractStringBuilder {
    protected char[] value;

    protected int count;

    public AbstractStringBuilder(int capacity) {
        count = 0;
        value = new char[capacity];
    }

    public AbstractStringBuilder append(char c) {
        ensureCapacityInternal(count + 1);
        value[count++] = c;
        return this;
    }

    private void ensureCapacityInternal(int minimumCapacity) {
        // overflow-conscious code
        if (minimumCapacity - value.length &gt; 0)
            expandCapacity(minimumCapacity);
    }

    void expandCapacity(int minimumCapacity) {
        int newCapacity = value.length * 2 + 2;
        if (newCapacity - minimumCapacity &lt; 0)
            newCapacity = minimumCapacity;
        if (newCapacity &lt; 0) {
            if (minimumCapacity &lt; 0) // overflow
                throw new OutOfMemoryError();
            newCapacity = Integer.MAX_VALUE;
        }
        value = Arrays.copyOf(value, newCapacity);
    }
}
</code></pre>
<pre><code class="language-java">public class StringBuilder extends AbstractStringBuilder {
    public StringBuilder() {
        super(16);
    }

    @Override
    public String toString() {
        // Create a copy, don't share the array
        return new String(value, 0, count);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        final int count = 26;
        for (int i = 0; i &lt; count; i++) {
            sb.append((char) ('a' + i));
        }
        System.out.println(sb.toString());
    }
}
</code></pre>
<pre><code class="language-html">abcdefghijklmnopqrstuvwxyz
</code></pre>
<h3><a class="header" href="#jdk-4" id="jdk-4">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">java.lang.StringBuilder</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-">java.nio.ByteBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-">java.lang.StringBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html">java.lang.Appendable</a></li>
<li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder">Apache Camel builders</a></li>
</ul>
<h2><a class="header" href="#6-原型模式prototype" id="6-原型模式prototype">6. 原型模式（Prototype）</a></h2>
<h3><a class="header" href="#intent-8" id="intent-8">Intent</a></h3>
<p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<h3><a class="header" href="#class-diagram-8" id="class-diagram-8">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b8922f8c-95e6-4187-be85-572a509afb71.png"/> </div><br>
<h3><a class="header" href="#implementation-8" id="implementation-8">Implementation</a></h3>
<pre><code class="language-java">public abstract class Prototype {
    abstract Prototype myClone();
}
</code></pre>
<pre><code class="language-java">public class ConcretePrototype extends Prototype {

    private String filed;

    public ConcretePrototype(String filed) {
        this.filed = filed;
    }

    @Override
    Prototype myClone() {
        return new ConcretePrototype(filed);
    }

    @Override
    public String toString() {
        return filed;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype(&quot;abc&quot;);
        Prototype clone = prototype.myClone();
        System.out.println(clone.toString());
    }
}
</code></pre>
<pre><code class="language-html">abc
</code></pre>
<h3><a class="header" href="#jdk-5" id="jdk-5">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29">java.lang.Object#clone()</a></li>
</ul>
<h1><a class="header" href="#三行为型" id="三行为型">三、行为型</a></h1>
<h2><a class="header" href="#1-责任链chain-of-responsibility" id="1-责任链chain-of-responsibility">1. 责任链（Chain Of Responsibility）</a></h2>
<h3><a class="header" href="#intent-9" id="intent-9">Intent</a></h3>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<h3><a class="header" href="#class-diagram-9" id="class-diagram-9">Class Diagram</a></h3>
<ul>
<li>Handler：定义处理请求的接口，并且实现后继链（successor）</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ca9f23bf-55a4-47b2-9534-a28e35397988.png"/> </div><br>
<h3><a class="header" href="#implementation-9" id="implementation-9">Implementation</a></h3>
<pre><code class="language-java">public abstract class Handler {

    protected Handler successor;


    public Handler(Handler successor) {
        this.successor = successor;
    }


    protected abstract void handleRequest(Request request);
}
</code></pre>
<pre><code class="language-java">public class ConcreteHandler1 extends Handler {

    public ConcreteHandler1(Handler successor) {
        super(successor);
    }


    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE1) {
            System.out.println(request.getName() + &quot; is handle by ConcreteHandler1&quot;);
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteHandler2 extends Handler {

    public ConcreteHandler2(Handler successor) {
        super(successor);
    }


    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE2) {
            System.out.println(request.getName() + &quot; is handle by ConcreteHandler2&quot;);
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class Request {

    private RequestType type;
    private String name;


    public Request(RequestType type, String name) {
        this.type = type;
        this.name = name;
    }


    public RequestType getType() {
        return type;
    }


    public String getName() {
        return name;
    }
}

</code></pre>
<pre><code class="language-java">public enum RequestType {
    TYPE1, TYPE2
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {

        Handler handler1 = new ConcreteHandler1(null);
        Handler handler2 = new ConcreteHandler2(handler1);

        Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);
        handler2.handleRequest(request1);

        Request request2 = new Request(RequestType.TYPE2, &quot;request2&quot;);
        handler2.handleRequest(request2);
    }
}
</code></pre>
<pre><code class="language-html">request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2
</code></pre>
<h3><a class="header" href="#jdk-6" id="jdk-6">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29">java.util.logging.Logger#log()</a></li>
<li><a href="https://commons.apache.org/proper/commons-chain/index.html">Apache Commons Chain</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-">javax.servlet.Filter#doFilter()</a></li>
</ul>
<h2><a class="header" href="#2-命令command" id="2-命令command">2. 命令（Command）</a></h2>
<h3><a class="header" href="#intent-10" id="intent-10">Intent</a></h3>
<p>将命令封装成对象中，具有以下作用：</p>
<ul>
<li>使用命令来参数化其它对象</li>
<li>将命令放入队列中进行排队</li>
<li>将命令的操作记录到日志中</li>
<li>支持可撤销的操作</li>
</ul>
<h3><a class="header" href="#class-diagram-10" id="class-diagram-10">Class Diagram</a></h3>
<ul>
<li>Command：命令</li>
<li>Receiver：命令接收者，也就是命令真正的执行者</li>
<li>Invoker：通过它来调用命令</li>
<li>Client：可以设置命令与命令的接收者</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c44a0342-f405-4f17-b750-e27cf4aadde2.png"/> </div><br>
<h3><a class="header" href="#implementation-10" id="implementation-10">Implementation</a></h3>
<p>设计一个遥控器，可以控制电灯开关。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg"/> </div><br>
<pre><code class="language-java">public interface Command {
    void execute();
}
</code></pre>
<pre><code class="language-java">public class LightOnCommand implements Command {
    Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.on();
    }
}
</code></pre>
<pre><code class="language-java">public class LightOffCommand implements Command {
    Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.off();
    }
}
</code></pre>
<pre><code class="language-java">public class Light {

    public void on() {
        System.out.println(&quot;Light is on!&quot;);
    }

    public void off() {
        System.out.println(&quot;Light is off!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 遥控器
 */
public class Invoker {
    private Command[] onCommands;
    private Command[] offCommands;
    private final int slotNum = 7;

    public Invoker() {
        this.onCommands = new Command[slotNum];
        this.offCommands = new Command[slotNum];
    }

    public void setOnCommand(Command command, int slot) {
        onCommands[slot] = command;
    }

    public void setOffCommand(Command command, int slot) {
        offCommands[slot] = command;
    }

    public void onButtonWasPushed(int slot) {
        onCommands[slot].execute();
    }

    public void offButtonWasPushed(int slot) {
        offCommands[slot].execute();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Invoker invoker = new Invoker();
        Light light = new Light();
        Command lightOnCommand = new LightOnCommand(light);
        Command lightOffCommand = new LightOffCommand(light);
        invoker.setOnCommand(lightOnCommand, 0);
        invoker.setOffCommand(lightOffCommand, 0);
        invoker.onButtonWasPushed(0);
        invoker.offButtonWasPushed(0);
    }
}
</code></pre>
<h3><a class="header" href="#jdk-7" id="jdk-7">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki">Netflix Hystrix</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html">javax.swing.Action</a></li>
</ul>
<h2><a class="header" href="#3-解释器interpreter" id="3-解释器interpreter">3. 解释器（Interpreter）</a></h2>
<h3><a class="header" href="#intent-11" id="intent-11">Intent</a></h3>
<p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<h3><a class="header" href="#class-diagram-11" id="class-diagram-11">Class Diagram</a></h3>
<ul>
<li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。</li>
<li>Context：上下文，包含解释器之外的一些全局信息。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b125bcd-1b36-43be-9b78-d90b076be549.png"/> </div><br>
<h3><a class="header" href="#implementation-11" id="implementation-11">Implementation</a></h3>
<p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p>
<p>例如一颗解析树为 D And (A Or (B C))，文本 &quot;D A&quot; 满足该解析树定义的规则。</p>
<p>这里的 Context 指的是 String。</p>
<pre><code class="language-java">public abstract class Expression {
    public abstract boolean interpret(String str);
}
</code></pre>
<pre><code class="language-java">public class TerminalExpression extends Expression {

    private String literal = null;

    public TerminalExpression(String str) {
        literal = str;
    }

    public boolean interpret(String str) {
        StringTokenizer st = new StringTokenizer(str);
        while (st.hasMoreTokens()) {
            String test = st.nextToken();
            if (test.equals(literal)) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<pre><code class="language-java">public class AndExpression extends Expression {

    private Expression expression1 = null;
    private Expression expression2 = null;

    public AndExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }

    public boolean interpret(String str) {
        return expression1.interpret(str) &amp;&amp; expression2.interpret(str);
    }
}
</code></pre>
<pre><code class="language-java">public class OrExpression extends Expression {
    private Expression expression1 = null;
    private Expression expression2 = null;

    public OrExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }

    public boolean interpret(String str) {
        return expression1.interpret(str) || expression2.interpret(str);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    /**
     * 构建解析树
     */
    public static Expression buildInterpreterTree() {
        // Literal
        Expression terminal1 = new TerminalExpression(&quot;A&quot;);
        Expression terminal2 = new TerminalExpression(&quot;B&quot;);
        Expression terminal3 = new TerminalExpression(&quot;C&quot;);
        Expression terminal4 = new TerminalExpression(&quot;D&quot;);
        // B C
        Expression alternation1 = new OrExpression(terminal2, terminal3);
        // A Or (B C)
        Expression alternation2 = new OrExpression(terminal1, alternation1);
        // D And (A Or (B C))
        return new AndExpression(terminal4, alternation2);
    }

    public static void main(String[] args) {
        Expression define = buildInterpreterTree();
        String context1 = &quot;D A&quot;;
        String context2 = &quot;A B&quot;;
        System.out.println(define.interpret(context1));
        System.out.println(define.interpret(context2));
    }
}
</code></pre>
<pre><code class="language-html">true
false
</code></pre>
<h3><a class="header" href="#jdk-8" id="jdk-8">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.Pattern</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html">java.text.Normalizer</a></li>
<li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html">java.text.Format</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html">javax.el.ELResolver</a></li>
</ul>
<h2><a class="header" href="#4-迭代器iterator" id="4-迭代器iterator">4. 迭代器（Iterator）</a></h2>
<h3><a class="header" href="#intent-12" id="intent-12">Intent</a></h3>
<p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<h3><a class="header" href="#class-diagram-12" id="class-diagram-12">Class Diagram</a></h3>
<ul>
<li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li>
<li>Iterator 主要定义了 hasNext() 和 next() 方法。</li>
<li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/89292ae1-5f13-44dc-b508-3f035e80bf89.png"/> </div><br>
<h3><a class="header" href="#implementation-12" id="implementation-12">Implementation</a></h3>
<pre><code class="language-java">public interface Aggregate {
    Iterator createIterator();
}
</code></pre>
<pre><code class="language-java">public class ConcreteAggregate implements Aggregate {

    private Integer[] items;

    public ConcreteAggregate() {
        items = new Integer[10];
        for (int i = 0; i &lt; items.length; i++) {
            items[i] = i;
        }
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator&lt;Integer&gt;(items);
    }
}
</code></pre>
<pre><code class="language-java">public interface Iterator&lt;Item&gt; {

    Item next();

    boolean hasNext();
}
</code></pre>
<pre><code class="language-java">public class ConcreteIterator&lt;Item&gt; implements Iterator {

    private Item[] items;
    private int position = 0;

    public ConcreteIterator(Item[] items) {
        this.items = items;
    }

    @Override
    public Object next() {
        return items[position++];
    }

    @Override
    public boolean hasNext() {
        return position &lt; items.length;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        Aggregate aggregate = new ConcreteAggregate();
        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
</code></pre>
<h3><a class="header" href="#jdk-9" id="jdk-9">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">java.util.Iterator</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html">java.util.Enumeration</a></li>
</ul>
<h2><a class="header" href="#5-中介者mediator" id="5-中介者mediator">5. 中介者（Mediator）</a></h2>
<h3><a class="header" href="#intent-13" id="intent-13">Intent</a></h3>
<p>集中相关对象之间复杂的沟通和控制方式。</p>
<h3><a class="header" href="#class-diagram-13" id="class-diagram-13">Class Diagram</a></h3>
<ul>
<li>Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。</li>
<li>Colleague：同事，相关对象</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png"/> </div><br>
<h3><a class="header" href="#implementation-13" id="implementation-13">Implementation</a></h3>
<p>Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg"/> </div><br>
<p>使用中介者模式可以将复杂的依赖结构变成星形结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg"/> </div><br>
<pre><code class="language-java">public abstract class Colleague {
    public abstract void onEvent(Mediator mediator);
}
</code></pre>
<pre><code class="language-java">public class Alarm extends Colleague {

    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;alarm&quot;);
    }

    public void doAlarm() {
        System.out.println(&quot;doAlarm()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class CoffeePot extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;coffeePot&quot;);
    }

    public void doCoffeePot() {
        System.out.println(&quot;doCoffeePot()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Calender extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;calender&quot;);
    }

    public void doCalender() {
        System.out.println(&quot;doCalender()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Sprinkler extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;sprinkler&quot;);
    }

    public void doSprinkler() {
        System.out.println(&quot;doSprinkler()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public abstract class Mediator {
    public abstract void doEvent(String eventType);
}
</code></pre>
<pre><code class="language-java">public class ConcreteMediator extends Mediator {
    private Alarm alarm;
    private CoffeePot coffeePot;
    private Calender calender;
    private Sprinkler sprinkler;

    public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {
        this.alarm = alarm;
        this.coffeePot = coffeePot;
        this.calender = calender;
        this.sprinkler = sprinkler;
    }

    @Override
    public void doEvent(String eventType) {
        switch (eventType) {
            case &quot;alarm&quot;:
                doAlarmEvent();
                break;
            case &quot;coffeePot&quot;:
                doCoffeePotEvent();
                break;
            case &quot;calender&quot;:
                doCalenderEvent();
                break;
            default:
                doSprinklerEvent();
        }
    }

    public void doAlarmEvent() {
        alarm.doAlarm();
        coffeePot.doCoffeePot();
        calender.doCalender();
        sprinkler.doSprinkler();
    }

    public void doCoffeePotEvent() {
        // ...
    }

    public void doCalenderEvent() {
        // ...
    }

    public void doSprinklerEvent() {
        // ...
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Alarm alarm = new Alarm();
        CoffeePot coffeePot = new CoffeePot();
        Calender calender = new Calender();
        Sprinkler sprinkler = new Sprinkler();
        Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);
        // 闹钟事件到达，调用中介者就可以操作相关对象
        alarm.onEvent(mediator);
    }
}
</code></pre>
<pre><code class="language-java">doAlarm()
doCoffeePot()
doCalender()
doSprinkler()
</code></pre>
<h3><a class="header" href="#jdk-10" id="jdk-10">JDK</a></h3>
<ul>
<li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html">java.util.Timer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-">java.util.concurrent.Executor#execute()</a></li>
<li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">java.util.concurrent.ExecutorService</a></li>
<li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html">java.util.concurrent.ScheduledExecutorService</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">java.lang.reflect.Method#invoke()</a></li>
</ul>
<h2><a class="header" href="#6-备忘录memento" id="6-备忘录memento">6. 备忘录（Memento）</a></h2>
<h3><a class="header" href="#intent-14" id="intent-14">Intent</a></h3>
<p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<h3><a class="header" href="#class-diagram-14" id="class-diagram-14">Class Diagram</a></h3>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50678f34-694f-45a4-91c6-34d985c83fee.png"/> </div><br>
<h3><a class="header" href="#implementation-14" id="implementation-14">Implementation</a></h3>
<p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p>
<p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html">Memento Pattern - Calculator Example - Java Sourcecode</a></p>
<pre><code class="language-java">/**
 * Originator Interface
 */
public interface Calculator {

    // Create Memento
    PreviousCalculationToCareTaker backupLastCalculation();

    // setMemento
    void restorePreviousCalculation(PreviousCalculationToCareTaker memento);

    int getCalculationResult();

    void setFirstNumber(int firstNumber);

    void setSecondNumber(int secondNumber);
}
</code></pre>
<pre><code class="language-java">/**
 * Originator Implementation
 */
public class CalculatorImp implements Calculator {

    private int firstNumber;
    private int secondNumber;

    @Override
    public PreviousCalculationToCareTaker backupLastCalculation() {
        // create a memento object used for restoring two numbers
        return new PreviousCalculationImp(firstNumber, secondNumber);
    }

    @Override
    public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {
        this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();
        this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();
    }

    @Override
    public int getCalculationResult() {
        // result is adding two numbers
        return firstNumber + secondNumber;
    }

    @Override
    public void setFirstNumber(int firstNumber) {
        this.firstNumber = firstNumber;
    }

    @Override
    public void setSecondNumber(int secondNumber) {
        this.secondNumber = secondNumber;
    }
}
</code></pre>
<pre><code class="language-java">/**
 * Memento Interface to Originator
 *
 * This interface allows the originator to restore its state
 */
public interface PreviousCalculationToOriginator {
    int getFirstNumber();
    int getSecondNumber();
}
</code></pre>
<pre><code class="language-java">/**
 *  Memento interface to CalculatorOperator (Caretaker)
 */
public interface PreviousCalculationToCareTaker {
    // no operations permitted for the caretaker
}
</code></pre>
<pre><code class="language-java">/**
 * Memento Object Implementation
 * &lt;p&gt;
 * Note that this object implements both interfaces to Originator and CareTaker
 */
public class PreviousCalculationImp implements PreviousCalculationToCareTaker,
        PreviousCalculationToOriginator {

    private int firstNumber;
    private int secondNumber;

    public PreviousCalculationImp(int firstNumber, int secondNumber) {
        this.firstNumber = firstNumber;
        this.secondNumber = secondNumber;
    }

    @Override
    public int getFirstNumber() {
        return firstNumber;
    }

    @Override
    public int getSecondNumber() {
        return secondNumber;
    }
}
</code></pre>
<pre><code class="language-java">/**
 * CareTaker object
 */
public class Client {

    public static void main(String[] args) {
        // program starts
        Calculator calculator = new CalculatorImp();

        // assume user enters two numbers
        calculator.setFirstNumber(10);
        calculator.setSecondNumber(100);

        // find result
        System.out.println(calculator.getCalculationResult());

        // Store result of this calculation in case of error
        PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();

        // user enters a number
        calculator.setFirstNumber(17);

        // user enters a wrong second number and calculates result
        calculator.setSecondNumber(-290);

        // calculate result
        System.out.println(calculator.getCalculationResult());

        // user hits CTRL + Z to undo last operation and see last result
        calculator.restorePreviousCalculation(memento);

        // result restored
        System.out.println(calculator.getCalculationResult());
    }
}
</code></pre>
<pre><code class="language-html">110
-273
110
</code></pre>
<h3><a class="header" href="#jdk-11" id="jdk-11">JDK</a></h3>
<ul>
<li>java.io.Serializable</li>
</ul>
<h2><a class="header" href="#7-观察者observer" id="7-观察者observer">7. 观察者（Observer）</a></h2>
<h3><a class="header" href="#intent-15" id="intent-15">Intent</a></h3>
<p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" width="600"/> </div><br>
<h3><a class="header" href="#class-diagram-15" id="class-diagram-15">Class Diagram</a></h3>
<p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png"/> </div><br>
<h3><a class="header" href="#implementation-15" id="implementation-15">Implementation</a></h3>
<p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg"/> </div><br>
<pre><code class="language-java">public interface Subject {
    void registerObserver(Observer o);

    void removeObserver(Observer o);

    void notifyObserver();
}
</code></pre>
<pre><code class="language-java">public class WeatherData implements Subject {
    private List&lt;Observer&gt; observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList&lt;&gt;();
    }

    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObserver();
    }

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i &gt;= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }
}
</code></pre>
<pre><code class="language-java">public interface Observer {
    void update(float temp, float humidity, float pressure);
}
</code></pre>
<pre><code class="language-java">public class StatisticsDisplay implements Observer {

    public StatisticsDisplay(Subject weatherData) {
        weatherData.reisterObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }
}
</code></pre>
<pre><code class="language-java">public class CurrentConditionsDisplay implements Observer {

    public CurrentConditionsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }
}
</code></pre>
<pre><code class="language-java">public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);

        weatherData.setMeasurements(0, 0, 0);
        weatherData.setMeasurements(1, 1, 1);
    }
}
</code></pre>
<pre><code class="language-html">CurrentConditionsDisplay.update: 0.0 0.0 0.0
StatisticsDisplay.update: 0.0 0.0 0.0
CurrentConditionsDisplay.update: 1.0 1.0 1.0
StatisticsDisplay.update: 1.0 1.0 1.0
</code></pre>
<h3><a class="header" href="#jdk-12" id="jdk-12">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html">java.util.Observer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html">java.util.EventListener</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html">javax.servlet.http.HttpSessionBindingListener</a></li>
<li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
</ul>
<h2><a class="header" href="#8-状态state" id="8-状态state">8. 状态（State）</a></h2>
<h3><a class="header" href="#intent-16" id="intent-16">Intent</a></h3>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<h3><a class="header" href="#class-diagram-16" id="class-diagram-16">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79df886f-fdc3-4020-a07f-c991bb58e0d8.png"/> </div><br>
<h3><a class="header" href="#implementation-16" id="implementation-16">Implementation</a></h3>
<p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg" width="600"/> </div><br>
<pre><code class="language-java">public interface State {
    /**
     * 投入 25 分钱
     */
    void insertQuarter();

    /**
     * 退回 25 分钱
     */
    void ejectQuarter();

    /**
     * 转动曲柄
     */
    void turnCrank();

    /**
     * 发放糖果
     */
    void dispense();
}
</code></pre>
<pre><code class="language-java">public class HasQuarterState implements State {

    private GumballMachine gumballMachine;

    public HasQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You can't insert another quarter&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;Quarter returned&quot;);
        gumballMachine.setState(gumballMachine.getNoQuarterState());
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned...&quot;);
        gumballMachine.setState(gumballMachine.getSoldState());
    }

    @Override
    public void dispense() {
        System.out.println(&quot;No gumball dispensed&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class NoQuarterState implements State {

    GumballMachine gumballMachine;

    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You insert a quarter&quot;);
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;You haven't insert a quarter&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned, but there's no quarter&quot;);
    }

    @Override
    public void dispense() {
        System.out.println(&quot;You need to pay first&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class SoldOutState implements State {

    GumballMachine gumballMachine;

    public SoldOutState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You can't insert a quarter, the machine is sold out&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;You can't eject, you haven't inserted a quarter yet&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned, but there are no gumballs&quot;);
    }

    @Override
    public void dispense() {
        System.out.println(&quot;No gumball dispensed&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class SoldState implements State {

    GumballMachine gumballMachine;

    public SoldState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;Please wait, we're already giving you a gumball&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;Sorry, you already turned the crank&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;Turning twice doesn't get you another gumball!&quot;);
    }

    @Override
    public void dispense() {
        gumballMachine.releaseBall();
        if (gumballMachine.getCount() &gt; 0) {
            gumballMachine.setState(gumballMachine.getNoQuarterState());
        } else {
            System.out.println(&quot;Oops, out of gumballs&quot;);
            gumballMachine.setState(gumballMachine.getSoldOutState());
        }
    }
}
</code></pre>
<pre><code class="language-java">public class GumballMachine {

    private State soldOutState;
    private State noQuarterState;
    private State hasQuarterState;
    private State soldState;

    private State state;
    private int count = 0;

    public GumballMachine(int numberGumballs) {
        count = numberGumballs;
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);

        if (numberGumballs &gt; 0) {
            state = noQuarterState;
        } else {
            state = soldOutState;
        }
    }

    public void insertQuarter() {
        state.insertQuarter();
    }

    public void ejectQuarter() {
        state.ejectQuarter();
    }

    public void turnCrank() {
        state.turnCrank();
        state.dispense();
    }

    public void setState(State state) {
        this.state = state;
    }

    public void releaseBall() {
        System.out.println(&quot;A gumball comes rolling out the slot...&quot;);
        if (count != 0) {
            count -= 1;
        }
    }

    public State getSoldOutState() {
        return soldOutState;
    }

    public State getNoQuarterState() {
        return noQuarterState;
    }

    public State getHasQuarterState() {
        return hasQuarterState;
    }

    public State getSoldState() {
        return soldState;
    }

    public int getCount() {
        return count;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        GumballMachine gumballMachine = new GumballMachine(5);

        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();

        gumballMachine.insertQuarter();
        gumballMachine.ejectQuarter();
        gumballMachine.turnCrank();

        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.ejectQuarter();

        gumballMachine.insertQuarter();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
    }
}
</code></pre>
<pre><code class="language-html">You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
Quarter returned
You turned, but there's no quarter
You need to pay first
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You haven't insert a quarter
You insert a quarter
You can't insert another quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
Oops, out of gumballs
You can't insert a quarter, the machine is sold out
You turned, but there are no gumballs
No gumball dispensed
</code></pre>
<h2><a class="header" href="#9-策略strategy" id="9-策略strategy">9. 策略（Strategy）</a></h2>
<h3><a class="header" href="#intent-17" id="intent-17">Intent</a></h3>
<p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<h3><a class="header" href="#class-diagram-17" id="class-diagram-17">Class Diagram</a></h3>
<ul>
<li>Strategy 接口定义了一个算法族，它们都实现了  behavior() 方法。</li>
<li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png"/> </div><br>
<h3><a class="header" href="#与状态模式的比较" id="与状态模式的比较">与状态模式的比较</a></h3>
<p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h3><a class="header" href="#implementation-17" id="implementation-17">Implementation</a></h3>
<p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p>
<pre><code class="language-java">public interface QuackBehavior {
    void quack();
}
</code></pre>
<pre><code class="language-java">public class Quack implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println(&quot;quack!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Squeak implements QuackBehavior{
    @Override
    public void quack() {
        System.out.println(&quot;squeak!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Duck {

    private QuackBehavior quackBehavior;

    public void performQuack() {
        if (quackBehavior != null) {
            quackBehavior.quack();
        }
    }

    public void setQuackBehavior(QuackBehavior quackBehavior) {
        this.quackBehavior = quackBehavior;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.setQuackBehavior(new Squeak());
        duck.performQuack();
        duck.setQuackBehavior(new Quack());
        duck.performQuack();
    }
}
</code></pre>
<pre><code class="language-html">squeak!
quack!
</code></pre>
<h3><a class="header" href="#jdk-13" id="jdk-13">JDK</a></h3>
<ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h2><a class="header" href="#10-模板方法template-method" id="10-模板方法template-method">10. 模板方法（Template Method）</a></h2>
<h3><a class="header" href="#intent-18" id="intent-18">Intent</a></h3>
<p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<h3><a class="header" href="#class-diagram-18" id="class-diagram-18">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png"/> </div><br>
<h3><a class="header" href="#implementation-18" id="implementation-18">Implementation</a></h3>
<p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png"/> </div><br>
<pre><code class="language-java">public abstract class CaffeineBeverage {

    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    abstract void brew();

    abstract void addCondiments();

    void boilWater() {
        System.out.println(&quot;boilWater&quot;);
    }

    void pourInCup() {
        System.out.println(&quot;pourInCup&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Coffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println(&quot;Coffee.brew&quot;);
    }

    @Override
    void addCondiments() {
        System.out.println(&quot;Coffee.addCondiments&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println(&quot;Tea.brew&quot;);
    }

    @Override
    void addCondiments() {
        System.out.println(&quot;Tea.addCondiments&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        CaffeineBeverage caffeineBeverage = new Coffee();
        caffeineBeverage.prepareRecipe();
        System.out.println(&quot;-----------&quot;);
        caffeineBeverage = new Tea();
        caffeineBeverage.prepareRecipe();
    }
}
</code></pre>
<pre><code class="language-html">boilWater
Coffee.brew
pourInCup
Coffee.addCondiments
-----------
boilWater
Tea.brew
pourInCup
Tea.addCondiments
</code></pre>
<h3><a class="header" href="#jdk-14" id="jdk-14">JDK</a></h3>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
<h2><a class="header" href="#11-访问者visitor" id="11-访问者visitor">11. 访问者（Visitor）</a></h2>
<h3><a class="header" href="#intent-19" id="intent-19">Intent</a></h3>
<p>为一个对象结构（比如组合结构）增加新能力。</p>
<h3><a class="header" href="#class-diagram-19" id="class-diagram-19">Class Diagram</a></h3>
<ul>
<li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li>
<li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li>
<li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79c6f036-bde6-4393-85a3-ef36a0327bd2.png"/> </div><br>
<h3><a class="header" href="#implementation-19" id="implementation-19">Implementation</a></h3>
<pre><code class="language-java">public interface Element {
    void accept(Visitor visitor);
}
</code></pre>
<pre><code class="language-java">class CustomerGroup {

    private List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();

    void accept(Visitor visitor) {
        for (Customer customer : customers) {
            customer.accept(visitor);
        }
    }

    void addCustomer(Customer customer) {
        customers.add(customer);
    }
}
</code></pre>
<pre><code class="language-java">public class Customer implements Element {

    private String name;
    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();

    Customer(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }

    void addOrder(Order order) {
        orders.add(order);
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
        for (Order order : orders) {
            order.accept(visitor);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class Order implements Element {

    private String name;
    private List&lt;Item&gt; items = new ArrayList();

    Order(String name) {
        this.name = name;
    }

    Order(String name, String itemName) {
        this.name = name;
        this.addItem(new Item(itemName));
    }

    String getName() {
        return name;
    }

    void addItem(Item item) {
        items.add(item);
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);

        for (Item item : items) {
            item.accept(visitor);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class Item implements Element {

    private String name;

    Item(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
</code></pre>
<pre><code class="language-java">public interface Visitor {
    void visit(Customer customer);

    void visit(Order order);

    void visit(Item item);
}
</code></pre>
<pre><code class="language-java">public class GeneralReport implements Visitor {

    private int customersNo;
    private int ordersNo;
    private int itemsNo;

    public void visit(Customer customer) {
        System.out.println(customer.getName());
        customersNo++;
    }

    public void visit(Order order) {
        System.out.println(order.getName());
        ordersNo++;
    }

    public void visit(Item item) {
        System.out.println(item.getName());
        itemsNo++;
    }

    public void displayResults() {
        System.out.println(&quot;Number of customers: &quot; + customersNo);
        System.out.println(&quot;Number of orders:    &quot; + ordersNo);
        System.out.println(&quot;Number of items:     &quot; + itemsNo);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Customer customer1 = new Customer(&quot;customer1&quot;);
        customer1.addOrder(new Order(&quot;order1&quot;, &quot;item1&quot;));
        customer1.addOrder(new Order(&quot;order2&quot;, &quot;item1&quot;));
        customer1.addOrder(new Order(&quot;order3&quot;, &quot;item1&quot;));

        Order order = new Order(&quot;order_a&quot;);
        order.addItem(new Item(&quot;item_a1&quot;));
        order.addItem(new Item(&quot;item_a2&quot;));
        order.addItem(new Item(&quot;item_a3&quot;));
        Customer customer2 = new Customer(&quot;customer2&quot;);
        customer2.addOrder(order);

        CustomerGroup customers = new CustomerGroup();
        customers.addCustomer(customer1);
        customers.addCustomer(customer2);

        GeneralReport visitor = new GeneralReport();
        customers.accept(visitor);
        visitor.displayResults();
    }
}
</code></pre>
<pre><code class="language-html">customer1
order1
item1
order2
item1
order3
item1
customer2
order_a
item_a1
item_a2
item_a3
Number of customers: 2
Number of orders:    4
Number of items:     6
</code></pre>
<h3><a class="header" href="#jdk-15" id="jdk-15">JDK</a></h3>
<ul>
<li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li>
<li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li>
</ul>
<h2><a class="header" href="#12-空对象null" id="12-空对象null">12. 空对象（Null）</a></h2>
<h3><a class="header" href="#intent-20" id="intent-20">Intent</a></h3>
<p>使用什么都不做的空对象来代替 NULL。</p>
<p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p>
<h3><a class="header" href="#class-diagram-20" id="class-diagram-20">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22870bbe-898f-4c17-a31a-d7c5ee5d1c10.png"/> </div><br>
<h3><a class="header" href="#implementation-20" id="implementation-20">Implementation</a></h3>
<pre><code class="language-java">public abstract class AbstractOperation {
    abstract void request();
}
</code></pre>
<pre><code class="language-java">public class RealOperation extends AbstractOperation {
    @Override
    void request() {
        System.out.println(&quot;do something&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class NullOperation extends AbstractOperation{
    @Override
    void request() {
        // do nothing
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        AbstractOperation abstractOperation = func(-1);
        abstractOperation.request();
    }

    public static AbstractOperation func(int para) {
        if (para &lt; 0) {
            return new NullOperation();
        }
        return new RealOperation();
    }
}
</code></pre>
<h1><a class="header" href="#四结构型" id="四结构型">四、结构型</a></h1>
<h2><a class="header" href="#1-适配器adapter" id="1-适配器adapter">1. 适配器（Adapter）</a></h2>
<h3><a class="header" href="#intent-21" id="intent-21">Intent</a></h3>
<p>把一个类接口转换成另一个用户需要的接口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"/> </div><br>
<h3><a class="header" href="#class-diagram-21" id="class-diagram-21">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png"/> </div><br>
<h3><a class="header" href="#implementation-21" id="implementation-21">Implementation</a></h3>
<p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<pre><code class="language-java">public interface Duck {
    void quack();
}
</code></pre>
<pre><code class="language-java">public interface Turkey {
    void gobble();
}
</code></pre>
<pre><code class="language-java">public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println(&quot;gobble!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class TurkeyAdapter implements Duck {
    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    @Override
    public void quack() {
        turkey.gobble();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
</code></pre>
<h3><a class="header" href="#jdk-16" id="jdk-16">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29">java.util.Arrays#asList()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-">java.util.Collections#list()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-">java.util.Collections#enumeration()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-">javax.xml.bind.annotation.adapters.XMLAdapter</a></li>
</ul>
<h2><a class="header" href="#2-桥接bridge" id="2-桥接bridge">2. 桥接（Bridge）</a></h2>
<h3><a class="header" href="#intent-22" id="intent-22">Intent</a></h3>
<p>将抽象与实现分离开来，使它们可以独立变化。</p>
<h3><a class="header" href="#class-diagram-22" id="class-diagram-22">Class Diagram</a></h3>
<ul>
<li>Abstraction：定义抽象类的接口</li>
<li>Implementor：定义实现类接口</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png"/> </div><br>
<h3><a class="header" href="#implementation-22" id="implementation-22">Implementation</a></h3>
<p>RemoteControl 表示遥控器，指代 Abstraction。</p>
<p>TV 表示电视，指代 Implementor。</p>
<p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p>
<pre><code class="language-java">public abstract class TV {
    public abstract void on();

    public abstract void off();

    public abstract void tuneChannel();
}
</code></pre>
<pre><code class="language-java">public class Sony extends TV {
    @Override
    public void on() {
        System.out.println(&quot;Sony.on()&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;Sony.off()&quot;);
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;Sony.tuneChannel()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class RCA extends TV {
    @Override
    public void on() {
        System.out.println(&quot;RCA.on()&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;RCA.off()&quot;);
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;RCA.tuneChannel()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public abstract class RemoteControl {
    protected TV tv;

    public RemoteControl(TV tv) {
        this.tv = tv;
    }

    public abstract void on();

    public abstract void off();

    public abstract void tuneChannel();
}
</code></pre>
<pre><code class="language-java">public class ConcreteRemoteControl1 extends RemoteControl {
    public ConcreteRemoteControl1(TV tv) {
        super(tv);
    }

    @Override
    public void on() {
        System.out.println(&quot;ConcreteRemoteControl1.on()&quot;);
        tv.on();
    }

    @Override
    public void off() {
        System.out.println(&quot;ConcreteRemoteControl1.off()&quot;);
        tv.off();
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;ConcreteRemoteControl1.tuneChannel()&quot;);
        tv.tuneChannel();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteRemoteControl2 extends RemoteControl {
    public ConcreteRemoteControl2(TV tv) {
        super(tv);
    }

    @Override
    public void on() {
        System.out.println(&quot;ConcreteRemoteControl2.on()&quot;);
        tv.on();
    }

    @Override
    public void off() {
        System.out.println(&quot;ConcreteRemoteControl2.off()&quot;);
        tv.off();
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;ConcreteRemoteControl2.tuneChannel()&quot;);
        tv.tuneChannel();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());
        remoteControl1.on();
        remoteControl1.off();
        remoteControl1.tuneChannel();
        RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());
         remoteControl2.on();
         remoteControl2.off();
         remoteControl2.tuneChannel();
    }
}
</code></pre>
<h3><a class="header" href="#jdk-17" id="jdk-17">JDK</a></h3>
<ul>
<li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li>
<li>JDBC</li>
</ul>
<h2><a class="header" href="#3-组合composite" id="3-组合composite">3. 组合（Composite）</a></h2>
<h3><a class="header" href="#intent-23" id="intent-23">Intent</a></h3>
<p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<h3><a class="header" href="#class-diagram-23" id="class-diagram-23">Class Diagram</a></h3>
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png"/> </div><br>
<h3><a class="header" href="#implementation-23" id="implementation-23">Implementation</a></h3>
<pre><code class="language-java">public abstract class Component {
    protected String name;

    public Component(String name) {
        this.name = name;
    }

    public void print() {
        print(0);
    }

    abstract void print(int level);

    abstract public void add(Component component);

    abstract public void remove(Component component);
}
</code></pre>
<pre><code class="language-java">public class Composite extends Component {

    private List&lt;Component&gt; child;

    public Composite(String name) {
        super(name);
        child = new ArrayList&lt;&gt;();
    }

    @Override
    void print(int level) {
        for (int i = 0; i &lt; level; i++) {
            System.out.print(&quot;--&quot;);
        }
        System.out.println(&quot;Composite:&quot; + name);
        for (Component component : child) {
            component.print(level + 1);
        }
    }

    @Override
    public void add(Component component) {
        child.add(component);
    }

    @Override
    public void remove(Component component) {
        child.remove(component);
    }
}
</code></pre>
<pre><code class="language-java">public class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }

    @Override
    void print(int level) {
        for (int i = 0; i &lt; level; i++) {
            System.out.print(&quot;--&quot;);
        }
        System.out.println(&quot;left:&quot; + name);
    }

    @Override
    public void add(Component component) {
        throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点
    }

    @Override
    public void remove(Component component) {
        throw new UnsupportedOperationException();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Composite root = new Composite(&quot;root&quot;);
        Component node1 = new Leaf(&quot;1&quot;);
        Component node2 = new Composite(&quot;2&quot;);
        Component node3 = new Leaf(&quot;3&quot;);
        root.add(node1);
        root.add(node2);
        root.add(node3);
        Component node21 = new Leaf(&quot;21&quot;);
        Component node22 = new Composite(&quot;22&quot;);
        node2.add(node21);
        node2.add(node22);
        Component node221 = new Leaf(&quot;221&quot;);
        node22.add(node221);
        root.print();
    }
}
</code></pre>
<pre><code class="language-html">Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3
</code></pre>
<h3><a class="header" href="#jdk-18" id="jdk-18">JDK</a></h3>
<ul>
<li>javax.swing.JComponent#add(Component)</li>
<li>java.awt.Container#add(Component)</li>
<li>java.util.Map#putAll(Map)</li>
<li>java.util.List#addAll(Collection)</li>
<li>java.util.Set#addAll(Collection)</li>
</ul>
<h2><a class="header" href="#4-装饰decorator" id="4-装饰decorator">4. 装饰（Decorator）</a></h2>
<h3><a class="header" href="#intent-24" id="intent-24">Intent</a></h3>
<p>为对象动态添加功能。</p>
<h3><a class="header" href="#class-diagram-24" id="class-diagram-24">Class Diagram</a></h3>
<p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png"/> </div><br>
<h3><a class="header" href="#implementation-24" id="implementation-24">Implementation</a></h3>
<p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" width="600"/> </div><br>
<pre><code class="language-java">public interface Beverage {
    double cost();
}
</code></pre>
<pre><code class="language-java">public class DarkRoast implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}
</code></pre>
<pre><code class="language-java">public class HouseBlend implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}
</code></pre>
<pre><code class="language-java">public abstract class CondimentDecorator implements Beverage {
    protected Beverage beverage;
}
</code></pre>
<pre><code class="language-java">public class Milk extends CondimentDecorator {

    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}
</code></pre>
<pre><code class="language-java">public class Mocha extends CondimentDecorator {

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        Beverage beverage = new HouseBlend();
        beverage = new Mocha(beverage);
        beverage = new Milk(beverage);
        System.out.println(beverage.cost());
    }
}
</code></pre>
<pre><code class="language-html">3.0
</code></pre>
<h3><a class="header" href="#设计原则-1" id="设计原则-1">设计原则</a></h3>
<p>类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p>
<p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p>
<h3><a class="header" href="#jdk-19" id="jdk-19">JDK</a></h3>
<ul>
<li>java.io.BufferedInputStream(InputStream)</li>
<li>java.io.DataInputStream(InputStream)</li>
<li>java.io.BufferedOutputStream(OutputStream)</li>
<li>java.util.zip.ZipOutputStream(OutputStream)</li>
<li>java.util.Collections#checked<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">List|Map|Set|SortedSet|SortedMap</a></li>
</ul>
<h2><a class="header" href="#5-外观facade" id="5-外观facade">5. 外观（Facade）</a></h2>
<h3><a class="header" href="#intent-25" id="intent-25">Intent</a></h3>
<p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3><a class="header" href="#class-diagram-25" id="class-diagram-25">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"/> </div><br>
<h3><a class="header" href="#implementation-25" id="implementation-25">Implementation</a></h3>
<p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p>
<pre><code class="language-java">public class SubSystem {
    public void turnOnTV() {
        System.out.println(&quot;turnOnTV()&quot;);
    }

    public void setCD(String cd) {
        System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);
    }

    public void startWatching(){
        System.out.println(&quot;startWatching()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Facade {
    private SubSystem subSystem = new SubSystem();

    public void watchMovie() {
        subSystem.turnOnTV();
        subSystem.setCD(&quot;a movie&quot;);
        subSystem.startWatching();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.watchMovie();
    }
}
</code></pre>
<h3><a class="header" href="#设计原则-2" id="设计原则-2">设计原则</a></h3>
<p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<h2><a class="header" href="#6-享元flyweight" id="6-享元flyweight">6. 享元（Flyweight）</a></h2>
<h3><a class="header" href="#intent-26" id="intent-26">Intent</a></h3>
<p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p>
<h3><a class="header" href="#class-diagram-26" id="class-diagram-26">Class Diagram</a></h3>
<ul>
<li>Flyweight：享元对象</li>
<li>IntrinsicState：内部状态，享元对象共享内部状态</li>
<li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5c22d5-9c0e-49e1-b5b0-6cc7032724d4.png"/> </div><br>
<h3><a class="header" href="#implementation-26" id="implementation-26">Implementation</a></h3>
<pre><code class="language-java">public interface Flyweight {
    void doOperation(String extrinsicState);
}
</code></pre>
<pre><code class="language-java">public class ConcreteFlyweight implements Flyweight {

    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void doOperation(String extrinsicState) {
        System.out.println(&quot;Object address: &quot; + System.identityHashCode(this));
        System.out.println(&quot;IntrinsicState: &quot; + intrinsicState);
        System.out.println(&quot;ExtrinsicState: &quot; + extrinsicState);
    }
}
</code></pre>
<pre><code class="language-java">public class FlyweightFactory {

    private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();

    Flyweight getFlyweight(String intrinsicState) {
        if (!flyweights.containsKey(intrinsicState)) {
            Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
            flyweights.put(intrinsicState, flyweight);
        }
        return flyweights.get(intrinsicState);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight flyweight1 = factory.getFlyweight(&quot;aa&quot;);
        Flyweight flyweight2 = factory.getFlyweight(&quot;aa&quot;);
        flyweight1.doOperation(&quot;x&quot;);
        flyweight2.doOperation(&quot;y&quot;);
    }
}
</code></pre>
<pre><code class="language-html">Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
</code></pre>
<h3><a class="header" href="#jdk-20" id="jdk-20">JDK</a></h3>
<p>Java 利用缓存来加速大量小对象的访问时间。</p>
<ul>
<li>java.lang.Integer#valueOf(int)</li>
<li>java.lang.Boolean#valueOf(boolean)</li>
<li>java.lang.Byte#valueOf(byte)</li>
<li>java.lang.Character#valueOf(char)</li>
</ul>
<h2><a class="header" href="#7-代理proxy" id="7-代理proxy">7. 代理（Proxy）</a></h2>
<h3><a class="header" href="#intent-27" id="intent-27">Intent</a></h3>
<p>控制对其它对象的访问。</p>
<h3><a class="header" href="#class-diagram-27" id="class-diagram-27">Class Diagram</a></h3>
<p>代理有以下四类：</p>
<ul>
<li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png"/> </div><br>
<h3><a class="header" href="#implementation-27" id="implementation-27">Implementation</a></h3>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<pre><code class="language-java">public interface Image {
    void showImage();
}
</code></pre>
<pre><code class="language-java">public class HighResolutionImage implements Image {

    private URL imageURL;
    private long startTime;
    private int height;
    private int width;

    public int getHeight() {
        return height;
    }

    public int getWidth() {
        return width;
    }

    public HighResolutionImage(URL imageURL) {
        this.imageURL = imageURL;
        this.startTime = System.currentTimeMillis();
        this.width = 600;
        this.height = 600;
    }

    public boolean isLoad() {
        // 模拟图片加载，延迟 3s 加载完成
        long endTime = System.currentTimeMillis();
        return endTime - startTime &gt; 3000;
    }

    @Override
    public void showImage() {
        System.out.println(&quot;Real Image: &quot; + imageURL);
    }
}
</code></pre>
<pre><code class="language-java">public class ImageProxy implements Image {

    private HighResolutionImage highResolutionImage;

    public ImageProxy(HighResolutionImage highResolutionImage) {
        this.highResolutionImage = highResolutionImage;
    }

    @Override
    public void showImage() {
        while (!highResolutionImage.isLoad()) {
            try {
                System.out.println(&quot;Temp Image: &quot; + highResolutionImage.getWidth() + &quot; &quot; + highResolutionImage.getHeight());
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        highResolutionImage.showImage();
    }
}
</code></pre>
<pre><code class="language-java">public class ImageViewer {

    public static void main(String[] args) throws Exception {
        String image = &quot;http://image.jpg&quot;;
        URL url = new URL(image);
        HighResolutionImage highResolutionImage = new HighResolutionImage(url);
        ImageProxy imageProxy = new ImageProxy(highResolutionImage);
        imageProxy.showImage();
    }
}
</code></pre>
<h3><a class="header" href="#jdk-21" id="jdk-21">JDK</a></h3>
<ul>
<li>java.lang.reflect.Proxy</li>
<li>RMI</li>
</ul>
<h1><a class="header" href="#参考资料-15" id="参考资料-15">参考资料</a></h1>
<ul>
<li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li>
<li>Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
<li><a href="http://www.oodesign.com/">Design Patterns</a></li>
<li><a href="http://java-design-patterns.com/">Design patterns implemented in Java</a></li>
<li><a href="http://www.programering.com/a/MTNxAzMwATY.html">The breakdown of design patterns in JDK</a></li>
</ul>
<h2><a class="header" href="#7-观察者observer-1" id="7-观察者observer-1">7. 观察者（Observer）</a></h2>
<h3><a class="header" href="#intent-28" id="intent-28">Intent</a></h3>
<p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" width="600"/> </div><br>
<h3><a class="header" href="#class-diagram-28" id="class-diagram-28">Class Diagram</a></h3>
<p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png"/> </div><br>
<h3><a class="header" href="#implementation-28" id="implementation-28">Implementation</a></h3>
<p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg"/> </div><br>
<pre><code class="language-java">public interface Subject {
    void registerObserver(Observer o);

    void removeObserver(Observer o);

    void notifyObserver();
}
</code></pre>
<pre><code class="language-java">public class WeatherData implements Subject {
    private List&lt;Observer&gt; observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList&lt;&gt;();
    }

    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObserver();
    }

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i &gt;= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }
}
</code></pre>
<pre><code class="language-java">public interface Observer {
    void update(float temp, float humidity, float pressure);
}
</code></pre>
<pre><code class="language-java">public class StatisticsDisplay implements Observer {

    public StatisticsDisplay(Subject weatherData) {
        weatherData.reisterObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }
}
</code></pre>
<pre><code class="language-java">public class CurrentConditionsDisplay implements Observer {

    public CurrentConditionsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }
}
</code></pre>
<pre><code class="language-java">public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);

        weatherData.setMeasurements(0, 0, 0);
        weatherData.setMeasurements(1, 1, 1);
    }
}
</code></pre>
<pre><code class="language-html">CurrentConditionsDisplay.update: 0.0 0.0 0.0
StatisticsDisplay.update: 0.0 0.0 0.0
CurrentConditionsDisplay.update: 1.0 1.0 1.0
StatisticsDisplay.update: 1.0 1.0 1.0
</code></pre>
<h3><a class="header" href="#jdk-22" id="jdk-22">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html">java.util.Observer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html">java.util.EventListener</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html">javax.servlet.http.HttpSessionBindingListener</a></li>
<li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
</ul>
<h2><a class="header" href="#装饰decorator" id="装饰decorator">装饰（Decorator）</a></h2>
<h3><a class="header" href="#intent-29" id="intent-29">Intent</a></h3>
<p>为对象动态添加功能。</p>
<h3><a class="header" href="#class-diagram-29" id="class-diagram-29">Class Diagram</a></h3>
<p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png"/> </div><br>
<h3><a class="header" href="#implementation-29" id="implementation-29">Implementation</a></h3>
<p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" width="600"/> </div><br>
<pre><code class="language-java">public interface Beverage {
    double cost();
}
</code></pre>
<pre><code class="language-java">public class DarkRoast implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}
</code></pre>
<pre><code class="language-java">public class HouseBlend implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}
</code></pre>
<pre><code class="language-java">public abstract class CondimentDecorator implements Beverage {
    protected Beverage beverage;
}
</code></pre>
<pre><code class="language-java">public class Milk extends CondimentDecorator {

    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}
</code></pre>
<pre><code class="language-java">public class Mocha extends CondimentDecorator {

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        Beverage beverage = new HouseBlend();
        beverage = new Mocha(beverage);
        beverage = new Milk(beverage);
        System.out.println(beverage.cost());
    }
}
</code></pre>
<pre><code class="language-html">3.0
</code></pre>
<h3><a class="header" href="#设计原则-3" id="设计原则-3">设计原则</a></h3>
<p>类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p>
<p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p>
<h3><a class="header" href="#jdk-23" id="jdk-23">JDK</a></h3>
<ul>
<li>java.io.BufferedInputStream(InputStream)</li>
<li>java.io.DataInputStream(InputStream)</li>
<li>java.io.BufferedOutputStream(OutputStream)</li>
<li>java.util.zip.ZipOutputStream(OutputStream)</li>
<li>java.util.Collections#checked<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">List|Map|Set|SortedSet|SortedMap</a></li>
</ul>
<h2><a class="header" href="#迭代器iterator" id="迭代器iterator">迭代器（Iterator）</a></h2>
<h3><a class="header" href="#intent-30" id="intent-30">Intent</a></h3>
<p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<h3><a class="header" href="#class-diagram-30" id="class-diagram-30">Class Diagram</a></h3>
<ul>
<li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li>
<li>Iterator 主要定义了 hasNext() 和 next() 方法；</li>
<li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191130164425351.png" alt="image-20191130164425351" style="zoom: 67%;" /> </div><br>
<h3><a class="header" href="#implementation-30" id="implementation-30">Implementation</a></h3>
<pre><code class="language-java">public interface Aggregate {
    Iterator createIterator();
}
</code></pre>
<pre><code class="language-java">public class ConcreteAggregate implements Aggregate {

    private Integer[] items;

    public ConcreteAggregate() {
        items = new Integer[10];
        for (int i = 0; i &lt; items.length; i++) {
            items[i] = i;
        }
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator&lt;Integer&gt;(items);
    }
}
</code></pre>
<pre><code class="language-java">public interface Iterator&lt;Item&gt; {

    Item next();

    boolean hasNext();
}
</code></pre>
<pre><code class="language-java">public class ConcreteIterator&lt;Item&gt; implements Iterator {

    private Item[] items;
    private int position = 0;

    public ConcreteIterator(Item[] items) {
        this.items = items;
    }

    @Override
    public Object next() {
        return items[position++];
    }

    @Override
    public boolean hasNext() {
        return position &lt; items.length;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        Aggregate aggregate = new ConcreteAggregate();
        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
</code></pre>
<h3><a class="header" href="#jdk-24" id="jdk-24">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">java.util.Iterator</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html">java.util.Enumeration</a></li>
</ul>
<h2><a class="header" href="#组合composite" id="组合composite">组合（Composite）</a></h2>
<h3><a class="header" href="#intent-31" id="intent-31">Intent</a></h3>
<p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<h3><a class="header" href="#class-diagram-31" id="class-diagram-31">Class Diagram</a></h3>
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png"/> </div><br>
<h3><a class="header" href="#implementation-31" id="implementation-31">Implementation</a></h3>
<pre><code class="language-java">public abstract class Component {
    protected String name;

    public Component(String name) {
        this.name = name;
    }

    public void print() {
        print(0);
    }

    abstract void print(int level);

    abstract public void add(Component component);

    abstract public void remove(Component component);
}
</code></pre>
<pre><code class="language-java">public class Composite extends Component {

    private List&lt;Component&gt; child;

    public Composite(String name) {
        super(name);
        child = new ArrayList&lt;&gt;();
    }

    @Override
    void print(int level) {
        for (int i = 0; i &lt; level; i++) {
            System.out.print(&quot;--&quot;);
        }
        System.out.println(&quot;Composite:&quot; + name);
        for (Component component : child) {
            component.print(level + 1);
        }
    }

    @Override
    public void add(Component component) {
        child.add(component);
    }

    @Override
    public void remove(Component component) {
        child.remove(component);
    }
}
</code></pre>
<pre><code class="language-java">public class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }

    @Override
    void print(int level) {
        for (int i = 0; i &lt; level; i++) {
            System.out.print(&quot;--&quot;);
        }
        System.out.println(&quot;left:&quot; + name);
    }

    @Override
    public void add(Component component) {
        throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点
    }

    @Override
    public void remove(Component component) {
        throw new UnsupportedOperationException();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Composite root = new Composite(&quot;root&quot;);
        Component node1 = new Leaf(&quot;1&quot;);
        Component node2 = new Composite(&quot;2&quot;);
        Component node3 = new Leaf(&quot;3&quot;);
        root.add(node1);
        root.add(node2);
        root.add(node3);
        Component node21 = new Leaf(&quot;21&quot;);
        Component node22 = new Composite(&quot;22&quot;);
        node2.add(node21);
        node2.add(node22);
        Component node221 = new Leaf(&quot;221&quot;);
        node22.add(node221);
        root.print();
    }
}
</code></pre>
<pre><code class="language-html">Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3
</code></pre>
<h3><a class="header" href="#jdk-25" id="jdk-25">JDK</a></h3>
<ul>
<li>javax.swing.JComponent#add(Component)</li>
<li>java.awt.Container#add(Component)</li>
<li>java.util.Map#putAll(Map)</li>
<li>java.util.List#addAll(Collection)</li>
<li>java.util.Set#addAll(Collection)</li>
</ul>
<h2><a class="header" href="#8-状态state-1" id="8-状态state-1">8. 状态（State）</a></h2>
<h3><a class="header" href="#intent-32" id="intent-32">Intent</a></h3>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<h3><a class="header" href="#class-diagram-32" id="class-diagram-32">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79df886f-fdc3-4020-a07f-c991bb58e0d8.png"/> </div><br>
<h3><a class="header" href="#implementation-32" id="implementation-32">Implementation</a></h3>
<p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg" width="600"/> </div><br>
<pre><code class="language-java">public interface State {
    /**
     * 投入 25 分钱
     */
    void insertQuarter();

    /**
     * 退回 25 分钱
     */
    void ejectQuarter();

    /**
     * 转动曲柄
     */
    void turnCrank();

    /**
     * 发放糖果
     */
    void dispense();
}
</code></pre>
<pre><code class="language-java">public class HasQuarterState implements State {

    private GumballMachine gumballMachine;

    public HasQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You can't insert another quarter&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;Quarter returned&quot;);
        gumballMachine.setState(gumballMachine.getNoQuarterState());
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned...&quot;);
        gumballMachine.setState(gumballMachine.getSoldState());
    }

    @Override
    public void dispense() {
        System.out.println(&quot;No gumball dispensed&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class NoQuarterState implements State {

    GumballMachine gumballMachine;

    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You insert a quarter&quot;);
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;You haven't insert a quarter&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned, but there's no quarter&quot;);
    }

    @Override
    public void dispense() {
        System.out.println(&quot;You need to pay first&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class SoldOutState implements State {

    GumballMachine gumballMachine;

    public SoldOutState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You can't insert a quarter, the machine is sold out&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;You can't eject, you haven't inserted a quarter yet&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned, but there are no gumballs&quot;);
    }

    @Override
    public void dispense() {
        System.out.println(&quot;No gumball dispensed&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class SoldState implements State {

    GumballMachine gumballMachine;

    public SoldState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;Please wait, we're already giving you a gumball&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;Sorry, you already turned the crank&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;Turning twice doesn't get you another gumball!&quot;);
    }

    @Override
    public void dispense() {
        gumballMachine.releaseBall();
        if (gumballMachine.getCount() &gt; 0) {
            gumballMachine.setState(gumballMachine.getNoQuarterState());
        } else {
            System.out.println(&quot;Oops, out of gumballs&quot;);
            gumballMachine.setState(gumballMachine.getSoldOutState());
        }
    }
}
</code></pre>
<pre><code class="language-java">public class GumballMachine {

    private State soldOutState;
    private State noQuarterState;
    private State hasQuarterState;
    private State soldState;

    private State state;
    private int count = 0;

    public GumballMachine(int numberGumballs) {
        count = numberGumballs;
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);

        if (numberGumballs &gt; 0) {
            state = noQuarterState;
        } else {
            state = soldOutState;
        }
    }

    public void insertQuarter() {
        state.insertQuarter();
    }

    public void ejectQuarter() {
        state.ejectQuarter();
    }

    public void turnCrank() {
        state.turnCrank();
        state.dispense();
    }

    public void setState(State state) {
        this.state = state;
    }

    public void releaseBall() {
        System.out.println(&quot;A gumball comes rolling out the slot...&quot;);
        if (count != 0) {
            count -= 1;
        }
    }

    public State getSoldOutState() {
        return soldOutState;
    }

    public State getNoQuarterState() {
        return noQuarterState;
    }

    public State getHasQuarterState() {
        return hasQuarterState;
    }

    public State getSoldState() {
        return soldState;
    }

    public int getCount() {
        return count;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        GumballMachine gumballMachine = new GumballMachine(5);

        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();

        gumballMachine.insertQuarter();
        gumballMachine.ejectQuarter();
        gumballMachine.turnCrank();

        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.ejectQuarter();

        gumballMachine.insertQuarter();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
    }
}
</code></pre>
<pre><code class="language-html">You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
Quarter returned
You turned, but there's no quarter
You need to pay first
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You haven't insert a quarter
You insert a quarter
You can't insert another quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
Oops, out of gumballs
You can't insert a quarter, the machine is sold out
You turned, but there are no gumballs
No gumball dispensed
</code></pre>
<h2><a class="header" href="#单例singleton" id="单例singleton">单例（Singleton）</a></h2>
<h3><a class="header" href="#intent-33" id="intent-33">Intent</a></h3>
<p>确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<h3><a class="header" href="#class-diagram-33" id="class-diagram-33">Class Diagram</a></h3>
<p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png"/> </div><br>
<h3><a class="header" href="#implementation-33" id="implementation-33">Implementation</a></h3>
<h4><a class="header" href="#Ⅰ-懒汉式-线程不安全-1" id="Ⅰ-懒汉式-线程不安全-1">Ⅰ 懒汉式-线程不安全</a></h4>
<p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<pre><code class="language-java">public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
</code></pre>
<h4><a class="header" href="#Ⅱ-饿汉式-线程安全-1" id="Ⅱ-饿汉式-线程安全-1">Ⅱ 饿汉式-线程安全</a></h4>
<p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p>
<p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p>
<pre><code class="language-java">private static Singleton uniqueInstance = new Singleton();
</code></pre>
<h4><a class="header" href="#Ⅲ-懒汉式-线程安全-1" id="Ⅲ-懒汉式-线程安全-1">Ⅲ 懒汉式-线程安全</a></h4>
<p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p>
<p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p>
<pre><code class="language-java">public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
</code></pre>
<h4><a class="header" href="#Ⅳ-双重校验锁-线程安全-1" id="Ⅳ-双重校验锁-线程安全-1">Ⅳ 双重校验锁-线程安全</a></h4>
<p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p>
<p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p>
<pre><code class="language-java">public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
</code></pre>
<p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p>
<pre><code class="language-java">if (uniqueInstance == null) {
    synchronized (Singleton.class) {
        uniqueInstance = new Singleton();
    }
}
</code></pre>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h4><a class="header" href="#Ⅴ-静态内部类实现-1" id="Ⅴ-静态内部类实现-1">Ⅴ 静态内部类实现</a></h4>
<p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<pre><code class="language-java">public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
</code></pre>
<h4><a class="header" href="#Ⅵ-枚举实现-1" id="Ⅵ-枚举实现-1">Ⅵ 枚举实现</a></h4>
<pre><code class="language-java">public enum Singleton {

    INSTANCE;

    private String objName;


    public String getObjName() {
        return objName;
    }


    public void setObjName(String objName) {
        this.objName = objName;
    }


    public static void main(String[] args) {

        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName(&quot;firstName&quot;);
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName(&quot;secondName&quot;);
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());

        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code class="language-html">firstName
secondName
secondName
secondName
</code></pre>
<p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p>
<p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<ul>
<li>Logger Classes</li>
<li>Configuration Classes</li>
<li>Accesing resources in shared mode</li>
<li>Factories implemented as Singletons</li>
</ul>
<h3><a class="header" href="#jdk-26" id="jdk-26">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29">java.lang.Runtime#getRuntime()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--">java.awt.Desktop#getDesktop()</a></li>
<li>[java.lang.System#getSecurityManager()](</li>
</ul>
<h2><a class="header" href="#4-抽象工厂abstract-factory-1" id="4-抽象工厂abstract-factory-1">4. 抽象工厂（Abstract Factory）</a></h2>
<h3><a class="header" href="#intent-34" id="intent-34">Intent</a></h3>
<p>提供一个接口，用于创建   <strong>相关的对象家族</strong>  。</p>
<h3><a class="header" href="#class-diagram-34" id="class-diagram-34">Class Diagram</a></h3>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png"/> </div><br>
<h3><a class="header" href="#implementation-34" id="implementation-34">Implementation</a></h3>
<pre><code class="language-java">public class AbstractProductA {
}
</code></pre>
<pre><code class="language-java">public class AbstractProductB {
}
</code></pre>
<pre><code class="language-java">public class ProductA1 extends AbstractProductA {
}
</code></pre>
<pre><code class="language-java">public class ProductA2 extends AbstractProductA {
}
</code></pre>
<pre><code class="language-java">public class ProductB1 extends AbstractProductB {
}
</code></pre>
<pre><code class="language-java">public class ProductB2 extends AbstractProductB {
}
</code></pre>
<pre><code class="language-java">public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }

    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }

    AbstractProductB createProductB() {
        return new ProductB2();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
</code></pre>
<h3><a class="header" href="#jdk-27" id="jdk-27">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html">javax.xml.parsers.DocumentBuilderFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--">javax.xml.transform.TransformerFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--">javax.xml.xpath.XPathFactory</a></li>
</ul>
<h2><a class="header" href="#5-生成器builder-1" id="5-生成器builder-1">5. 生成器（Builder）</a></h2>
<h3><a class="header" href="#intent-35" id="intent-35">Intent</a></h3>
<p>封装一个对象的构造过程，并允许按步骤构造。</p>
<h3><a class="header" href="#class-diagram-35" id="class-diagram-35">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5e376d-0b3e-490e-a43a-3231914b6668.png"/> </div><br>
<h3><a class="header" href="#implementation-35" id="implementation-35">Implementation</a></h3>
<p>以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。</p>
<pre><code class="language-java">public class AbstractStringBuilder {
    protected char[] value;

    protected int count;

    public AbstractStringBuilder(int capacity) {
        count = 0;
        value = new char[capacity];
    }

    public AbstractStringBuilder append(char c) {
        ensureCapacityInternal(count + 1);
        value[count++] = c;
        return this;
    }

    private void ensureCapacityInternal(int minimumCapacity) {
        // overflow-conscious code
        if (minimumCapacity - value.length &gt; 0)
            expandCapacity(minimumCapacity);
    }

    void expandCapacity(int minimumCapacity) {
        int newCapacity = value.length * 2 + 2;
        if (newCapacity - minimumCapacity &lt; 0)
            newCapacity = minimumCapacity;
        if (newCapacity &lt; 0) {
            if (minimumCapacity &lt; 0) // overflow
                throw new OutOfMemoryError();
            newCapacity = Integer.MAX_VALUE;
        }
        value = Arrays.copyOf(value, newCapacity);
    }
}
</code></pre>
<pre><code class="language-java">public class StringBuilder extends AbstractStringBuilder {
    public StringBuilder() {
        super(16);
    }

    @Override
    public String toString() {
        // Create a copy, don't share the array
        return new String(value, 0, count);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        final int count = 26;
        for (int i = 0; i &lt; count; i++) {
            sb.append((char) ('a' + i));
        }
        System.out.println(sb.toString());
    }
}
</code></pre>
<pre><code class="language-html">abcdefghijklmnopqrstuvwxyz
</code></pre>
<h3><a class="header" href="#jdk-28" id="jdk-28">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">java.lang.StringBuilder</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-">java.nio.ByteBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-">java.lang.StringBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html">java.lang.Appendable</a></li>
<li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder">Apache Camel builders</a></li>
</ul>
<h2><a class="header" href="#9-策略strategy-1" id="9-策略strategy-1">9. 策略（Strategy）</a></h2>
<h3><a class="header" href="#intent-36" id="intent-36">Intent</a></h3>
<p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<h3><a class="header" href="#class-diagram-36" id="class-diagram-36">Class Diagram</a></h3>
<ul>
<li>Strategy 接口定义了一个算法族，它们都实现了  behavior() 方法。</li>
<li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png"/> </div><br>
<h3><a class="header" href="#与状态模式的比较-1" id="与状态模式的比较-1">与状态模式的比较</a></h3>
<p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h3><a class="header" href="#implementation-36" id="implementation-36">Implementation</a></h3>
<p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p>
<pre><code class="language-java">public interface QuackBehavior {
    void quack();
}
</code></pre>
<pre><code class="language-java">public class Quack implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println(&quot;quack!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Squeak implements QuackBehavior{
    @Override
    public void quack() {
        System.out.println(&quot;squeak!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Duck {

    private QuackBehavior quackBehavior;

    public void performQuack() {
        if (quackBehavior != null) {
            quackBehavior.quack();
        }
    }

    public void setQuackBehavior(QuackBehavior quackBehavior) {
        this.quackBehavior = quackBehavior;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.setQuackBehavior(new Squeak());
        duck.performQuack();
        duck.setQuackBehavior(new Quack());
        duck.performQuack();
    }
}
</code></pre>
<pre><code class="language-html">squeak!
quack!
</code></pre>
<h3><a class="header" href="#jdk-29" id="jdk-29">JDK</a></h3>
<ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h2><a class="header" href="#2-命令command-1" id="2-命令command-1">2. 命令（Command）</a></h2>
<h3><a class="header" href="#intent-37" id="intent-37">Intent</a></h3>
<p>将命令封装成对象中，具有以下作用：</p>
<ul>
<li>使用命令来参数化其它对象</li>
<li>将命令放入队列中进行排队</li>
<li>将命令的操作记录到日志中</li>
<li>支持可撤销的操作</li>
</ul>
<h3><a class="header" href="#class-diagram-37" id="class-diagram-37">Class Diagram</a></h3>
<ul>
<li>Command：命令</li>
<li>Receiver：命令接收者，也就是命令真正的执行者</li>
<li>Invoker：通过它来调用命令</li>
<li>Client：可以设置命令与命令的接收者</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c44a0342-f405-4f17-b750-e27cf4aadde2.png"/> </div><br>
<h3><a class="header" href="#implementation-37" id="implementation-37">Implementation</a></h3>
<p>设计一个遥控器，可以控制电灯开关。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg"/> </div><br>
<pre><code class="language-java">public interface Command {
    void execute();
}
</code></pre>
<pre><code class="language-java">public class LightOnCommand implements Command {
    Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.on();
    }
}
</code></pre>
<pre><code class="language-java">public class LightOffCommand implements Command {
    Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.off();
    }
}
</code></pre>
<pre><code class="language-java">public class Light {

    public void on() {
        System.out.println(&quot;Light is on!&quot;);
    }

    public void off() {
        System.out.println(&quot;Light is off!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 遥控器
 */
public class Invoker {
    private Command[] onCommands;
    private Command[] offCommands;
    private final int slotNum = 7;

    public Invoker() {
        this.onCommands = new Command[slotNum];
        this.offCommands = new Command[slotNum];
    }

    public void setOnCommand(Command command, int slot) {
        onCommands[slot] = command;
    }

    public void setOffCommand(Command command, int slot) {
        offCommands[slot] = command;
    }

    public void onButtonWasPushed(int slot) {
        onCommands[slot].execute();
    }

    public void offButtonWasPushed(int slot) {
        offCommands[slot].execute();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Invoker invoker = new Invoker();
        Light light = new Light();
        Command lightOnCommand = new LightOnCommand(light);
        Command lightOffCommand = new LightOffCommand(light);
        invoker.setOnCommand(lightOnCommand, 0);
        invoker.setOffCommand(lightOffCommand, 0);
        invoker.onButtonWasPushed(0);
        invoker.offButtonWasPushed(0);
    }
}
</code></pre>
<h3><a class="header" href="#jdk-30" id="jdk-30">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki">Netflix Hystrix</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html">javax.swing.Action</a></li>
</ul>
<h2><a class="header" href="#桥接bridge" id="桥接bridge">桥接（Bridge）</a></h2>
<h3><a class="header" href="#intent-38" id="intent-38">Intent</a></h3>
<p>将抽象与实现分离开来，使它们可以独立变化。</p>
<h3><a class="header" href="#class-diagram-38" id="class-diagram-38">Class Diagram</a></h3>
<ul>
<li>Abstraction：定义抽象类的接口</li>
<li>Implementor：定义实现类接口</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png"/> </div><br>
<h3><a class="header" href="#implementation-38" id="implementation-38">Implementation</a></h3>
<p>RemoteControl 表示遥控器，指代 Abstraction。</p>
<p>TV 表示电视，指代 Implementor。</p>
<p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p>
<pre><code class="language-java">public abstract class TV {
    public abstract void on();

    public abstract void off();

    public abstract void tuneChannel();
}
</code></pre>
<pre><code class="language-java">public class Sony extends TV {
    @Override
    public void on() {
        System.out.println(&quot;Sony.on()&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;Sony.off()&quot;);
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;Sony.tuneChannel()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class RCA extends TV {
    @Override
    public void on() {
        System.out.println(&quot;RCA.on()&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;RCA.off()&quot;);
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;RCA.tuneChannel()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public abstract class RemoteControl {
    protected TV tv;

    public RemoteControl(TV tv) {
        this.tv = tv;
    }

    public abstract void on();

    public abstract void off();

    public abstract void tuneChannel();
}
</code></pre>
<pre><code class="language-java">public class ConcreteRemoteControl1 extends RemoteControl {
    public ConcreteRemoteControl1(TV tv) {
        super(tv);
    }

    @Override
    public void on() {
        System.out.println(&quot;ConcreteRemoteControl1.on()&quot;);
        tv.on();
    }

    @Override
    public void off() {
        System.out.println(&quot;ConcreteRemoteControl1.off()&quot;);
        tv.off();
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;ConcreteRemoteControl1.tuneChannel()&quot;);
        tv.tuneChannel();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteRemoteControl2 extends RemoteControl {
    public ConcreteRemoteControl2(TV tv) {
        super(tv);
    }

    @Override
    public void on() {
        System.out.println(&quot;ConcreteRemoteControl2.on()&quot;);
        tv.on();
    }

    @Override
    public void off() {
        System.out.println(&quot;ConcreteRemoteControl2.off()&quot;);
        tv.off();
    }

    @Override
    public void tuneChannel() {
        System.out.println(&quot;ConcreteRemoteControl2.tuneChannel()&quot;);
        tv.tuneChannel();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());
        remoteControl1.on();
        remoteControl1.off();
        remoteControl1.tuneChannel();
        RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());
         remoteControl2.on();
         remoteControl2.off();
         remoteControl2.tuneChannel();
    }
}
</code></pre>
<h3><a class="header" href="#jdk-31" id="jdk-31">JDK</a></h3>
<ul>
<li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li>
<li>JDBC</li>
</ul>
<h2><a class="header" href="#工厂方法factory-method" id="工厂方法factory-method">工厂方法（Factory Method）</a></h2>
<h3><a class="header" href="#intent-39" id="intent-39">Intent</a></h3>
<p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h3><a class="header" href="#class-diagram-39" id="class-diagram-39">Class Diagram</a></h3>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png"/> </div><br>
<h3><a class="header" href="#implementation-39" id="implementation-39">Implementation</a></h3>
<pre><code class="language-java">public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
        Product product = factoryMethod();
        // do something with the product
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct1();
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteFactory2 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct2();
    }
}
</code></pre>
<h3><a class="header" href="#jdk-32" id="jdk-32">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--">java.util.Calendar</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-">java.util.ResourceBundle</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--">java.text.NumberFormat</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-">java.nio.charset.Charset</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-">java.net.URLStreamHandlerFactory</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-">java.util.EnumSet</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--">javax.xml.bind.JAXBContext</a></li>
</ul>
<h2><a class="header" href="#5-中介者mediator-1" id="5-中介者mediator-1">5. 中介者（Mediator）</a></h2>
<h3><a class="header" href="#intent-40" id="intent-40">Intent</a></h3>
<p>集中相关对象之间复杂的沟通和控制方式。</p>
<h3><a class="header" href="#class-diagram-40" id="class-diagram-40">Class Diagram</a></h3>
<ul>
<li>Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。</li>
<li>Colleague：同事，相关对象</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png"/> </div><br>
<h3><a class="header" href="#implementation-40" id="implementation-40">Implementation</a></h3>
<p>Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg"/> </div><br>
<p>使用中介者模式可以将复杂的依赖结构变成星形结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg"/> </div><br>
<pre><code class="language-java">public abstract class Colleague {
    public abstract void onEvent(Mediator mediator);
}
</code></pre>
<pre><code class="language-java">public class Alarm extends Colleague {

    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;alarm&quot;);
    }

    public void doAlarm() {
        System.out.println(&quot;doAlarm()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class CoffeePot extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;coffeePot&quot;);
    }

    public void doCoffeePot() {
        System.out.println(&quot;doCoffeePot()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Calender extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;calender&quot;);
    }

    public void doCalender() {
        System.out.println(&quot;doCalender()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Sprinkler extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(&quot;sprinkler&quot;);
    }

    public void doSprinkler() {
        System.out.println(&quot;doSprinkler()&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public abstract class Mediator {
    public abstract void doEvent(String eventType);
}
</code></pre>
<pre><code class="language-java">public class ConcreteMediator extends Mediator {
    private Alarm alarm;
    private CoffeePot coffeePot;
    private Calender calender;
    private Sprinkler sprinkler;

    public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {
        this.alarm = alarm;
        this.coffeePot = coffeePot;
        this.calender = calender;
        this.sprinkler = sprinkler;
    }

    @Override
    public void doEvent(String eventType) {
        switch (eventType) {
            case &quot;alarm&quot;:
                doAlarmEvent();
                break;
            case &quot;coffeePot&quot;:
                doCoffeePotEvent();
                break;
            case &quot;calender&quot;:
                doCalenderEvent();
                break;
            default:
                doSprinklerEvent();
        }
    }

    public void doAlarmEvent() {
        alarm.doAlarm();
        coffeePot.doCoffeePot();
        calender.doCalender();
        sprinkler.doSprinkler();
    }

    public void doCoffeePotEvent() {
        // ...
    }

    public void doCalenderEvent() {
        // ...
    }

    public void doSprinklerEvent() {
        // ...
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Alarm alarm = new Alarm();
        CoffeePot coffeePot = new CoffeePot();
        Calender calender = new Calender();
        Sprinkler sprinkler = new Sprinkler();
        Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);
        // 闹钟事件到达，调用中介者就可以操作相关对象
        alarm.onEvent(mediator);
    }
}
</code></pre>
<pre><code class="language-java">doAlarm()
doCoffeePot()
doCalender()
doSprinkler()
</code></pre>
<h3><a class="header" href="#jdk-33" id="jdk-33">JDK</a></h3>
<ul>
<li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html">java.util.Timer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-">java.util.concurrent.Executor#execute()</a></li>
<li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">java.util.concurrent.ExecutorService</a></li>
<li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html">java.util.concurrent.ScheduledExecutorService</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">java.lang.reflect.Method#invoke()</a></li>
</ul>
<h2><a class="header" href="#访问者visitor" id="访问者visitor">访问者（Visitor）</a></h2>
<h3><a class="header" href="#intent-41" id="intent-41">Intent</a></h3>
<p>为一个对象结构（比如组合结构）增加新能力。</p>
<h3><a class="header" href="#class-diagram-41" id="class-diagram-41">Class Diagram</a></h3>
<ul>
<li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li>
<li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li>
<li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79c6f036-bde6-4393-85a3-ef36a0327bd2.png"/> </div><br>
<h3><a class="header" href="#implementation-41" id="implementation-41">Implementation</a></h3>
<pre><code class="language-java">public interface Element {
    void accept(Visitor visitor);
}
</code></pre>
<pre><code class="language-java">class CustomerGroup {

    private List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();

    void accept(Visitor visitor) {
        for (Customer customer : customers) {
            customer.accept(visitor);
        }
    }

    void addCustomer(Customer customer) {
        customers.add(customer);
    }
}
</code></pre>
<pre><code class="language-java">public class Customer implements Element {

    private String name;
    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();

    Customer(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }

    void addOrder(Order order) {
        orders.add(order);
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
        for (Order order : orders) {
            order.accept(visitor);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class Order implements Element {

    private String name;
    private List&lt;Item&gt; items = new ArrayList();

    Order(String name) {
        this.name = name;
    }

    Order(String name, String itemName) {
        this.name = name;
        this.addItem(new Item(itemName));
    }

    String getName() {
        return name;
    }

    void addItem(Item item) {
        items.add(item);
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);

        for (Item item : items) {
            item.accept(visitor);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class Item implements Element {

    private String name;

    Item(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
</code></pre>
<pre><code class="language-java">public interface Visitor {
    void visit(Customer customer);

    void visit(Order order);

    void visit(Item item);
}
</code></pre>
<pre><code class="language-java">public class GeneralReport implements Visitor {

    private int customersNo;
    private int ordersNo;
    private int itemsNo;

    public void visit(Customer customer) {
        System.out.println(customer.getName());
        customersNo++;
    }

    public void visit(Order order) {
        System.out.println(order.getName());
        ordersNo++;
    }

    public void visit(Item item) {
        System.out.println(item.getName());
        itemsNo++;
    }

    public void displayResults() {
        System.out.println(&quot;Number of customers: &quot; + customersNo);
        System.out.println(&quot;Number of orders:    &quot; + ordersNo);
        System.out.println(&quot;Number of items:     &quot; + itemsNo);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Customer customer1 = new Customer(&quot;customer1&quot;);
        customer1.addOrder(new Order(&quot;order1&quot;, &quot;item1&quot;));
        customer1.addOrder(new Order(&quot;order2&quot;, &quot;item1&quot;));
        customer1.addOrder(new Order(&quot;order3&quot;, &quot;item1&quot;));

        Order order = new Order(&quot;order_a&quot;);
        order.addItem(new Item(&quot;item_a1&quot;));
        order.addItem(new Item(&quot;item_a2&quot;));
        order.addItem(new Item(&quot;item_a3&quot;));
        Customer customer2 = new Customer(&quot;customer2&quot;);
        customer2.addOrder(order);

        CustomerGroup customers = new CustomerGroup();
        customers.addCustomer(customer1);
        customers.addCustomer(customer2);

        GeneralReport visitor = new GeneralReport();
        customers.accept(visitor);
        visitor.displayResults();
    }
}
</code></pre>
<pre><code class="language-html">customer1
order1
item1
order2
item1
order3
item1
customer2
order_a
item_a1
item_a2
item_a3
Number of customers: 2
Number of orders:    4
Number of items:     6
</code></pre>
<h3><a class="header" href="#jdk-34" id="jdk-34">JDK</a></h3>
<ul>
<li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li>
<li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li>
</ul>
<h2><a class="header" href="#空对象null" id="空对象null">空对象（Null）</a></h2>
<h3><a class="header" href="#intent-42" id="intent-42">Intent</a></h3>
<p>使用什么都不做</p>
<p>的空对象来代替 NULL。</p>
<p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p>
<h3><a class="header" href="#class-diagram-42" id="class-diagram-42">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22870bbe-898f-4c17-a31a-d7c5ee5d1c10.png"/> </div><br>
<h3><a class="header" href="#implementation-42" id="implementation-42">Implementation</a></h3>
<pre><code class="language-java">public abstract class AbstractOperation {
    abstract void request();
}
</code></pre>
<pre><code class="language-java">public class RealOperation extends AbstractOperation {
    @Override
    void request() {
        System.out.println(&quot;do something&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class NullOperation extends AbstractOperation{
    @Override
    void request() {
        // do nothing
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        AbstractOperation abstractOperation = func(-1);
        abstractOperation.request();
    }

    public static AbstractOperation func(int para) {
        if (para &lt; 0) {
            return new NullOperation();
        }
        return new RealOperation();
    }
}
</code></pre>
<h2><a class="header" href="#备忘录memento" id="备忘录memento">备忘录（Memento）</a></h2>
<h3><a class="header" href="#intent-43" id="intent-43">Intent</a></h3>
<p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<h3><a class="header" href="#class-diagram-43" id="class-diagram-43">Class Diagram</a></h3>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Memento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50678f34-694f-45a4-91c6-34d985c83fee.png"/> </div><br>
<h3><a class="header" href="#implementation-43" id="implementation-43">Implementation</a></h3>
<p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p>
<p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html">Memento Pattern - Calculator Example - Java Sourcecode</a></p>
<pre><code class="language-java">/**
 * Originator Interface
 */
public interface Calculator {

    // Create Memento
    PreviousCalculationToCareTaker backupLastCalculation();

    // setMemento
    void restorePreviousCalculation(PreviousCalculationToCareTaker memento);

    int getCalculationResult();

    void setFirstNumber(int firstNumber);

    void setSecondNumber(int secondNumber);
}
</code></pre>
<pre><code class="language-java">/**
 * Originator Implementation
 */
public class CalculatorImp implements Calculator {

    private int firstNumber;
    private int secondNumber;

    @Override
    public PreviousCalculationToCareTaker backupLastCalculation() {
        // create a memento object used for restoring two numbers
        return new PreviousCalculationImp(firstNumber, secondNumber);
    }

    @Override
    public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {
        this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();
        this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();
    }

    @Override
    public int getCalculationResult() {
        // result is adding two numbers
        return firstNumber + secondNumber;
    }

    @Override
    public void setFirstNumber(int firstNumber) {
        this.firstNumber = firstNumber;
    }

    @Override
    public void setSecondNumber(int secondNumber) {
        this.secondNumber = secondNumber;
    }
}
</code></pre>
<pre><code class="language-java">/**
 * Memento Interface to Originator
 *
 * This interface allows the originator to restore its state
 */
public interface PreviousCalculationToOriginator {
    int getFirstNumber();
    int getSecondNumber();
}
</code></pre>
<pre><code class="language-java">/**
 *  Memento interface to CalculatorOperator (Caretaker)
 */
public interface PreviousCalculationToCareTaker {
    // no operations permitted for the caretaker
}
</code></pre>
<pre><code class="language-java">/**
 * Memento Object Implementation
 * &lt;p&gt;
 * Note that this object implements both interfaces to Originator and CareTaker
 */
public class PreviousCalculationImp implements PreviousCalculationToCareTaker,
        PreviousCalculationToOriginator {

    private int firstNumber;
    private int secondNumber;

    public PreviousCalculationImp(int firstNumber, int secondNumber) {
        this.firstNumber = firstNumber;
        this.secondNumber = secondNumber;
    }

    @Override
    public int getFirstNumber() {
        return firstNumber;
    }

    @Override
    public int getSecondNumber() {
        return secondNumber;
    }
}
</code></pre>
<pre><code class="language-java">/**
 * CareTaker object
 */
public class Client {

    public static void main(String[] args) {
        // program starts
        Calculator calculator = new CalculatorImp();

        // assume user enters two numbers
        calculator.setFirstNumber(10);
        calculator.setSecondNumber(100);

        // find result
        System.out.println(calculator.getCalculationResult());

        // Store result of this calculation in case of error
        PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();

        // user enters a number
        calculator.setFirstNumber(17);

        // user enters a wrong second number and calculates result
        calculator.setSecondNumber(-290);

        // calculate result
        System.out.println(calculator.getCalculationResult());

        // user hits CTRL + Z to undo last operation and see last result
        calculator.restorePreviousCalculation(memento);

        // result restored
        System.out.println(calculator.getCalculationResult());
    }
}
</code></pre>
<pre><code class="language-html">110
-273
110
</code></pre>
<h3><a class="header" href="#jdk-35" id="jdk-35">JDK</a></h3>
<ul>
<li>java.io.Serializable</li>
</ul>
<h2><a class="header" href="#模板方法template-method" id="模板方法template-method">模板方法（Template Method）</a></h2>
<h3><a class="header" href="#intent-44" id="intent-44">Intent</a></h3>
<p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<h3><a class="header" href="#class-diagram-44" id="class-diagram-44">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png"/> </div><br>
<h3><a class="header" href="#implementation-44" id="implementation-44">Implementation</a></h3>
<p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png"/> </div><br>
<pre><code class="language-java">public abstract class CaffeineBeverage {

    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    abstract void brew();

    abstract void addCondiments();

    void boilWater() {
        System.out.println(&quot;boilWater&quot;);
    }

    void pourInCup() {
        System.out.println(&quot;pourInCup&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Coffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println(&quot;Coffee.brew&quot;);
    }

    @Override
    void addCondiments() {
        System.out.println(&quot;Coffee.addCondiments&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println(&quot;Tea.brew&quot;);
    }

    @Override
    void addCondiments() {
        System.out.println(&quot;Tea.addCondiments&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        CaffeineBeverage caffeineBeverage = new Coffee();
        caffeineBeverage.prepareRecipe();
        System.out.println(&quot;-----------&quot;);
        caffeineBeverage = new Tea();
        caffeineBeverage.prepareRecipe();
    }
}
</code></pre>
<pre><code class="language-html">boilWater
Coffee.brew
pourInCup
Coffee.addCondiments
-----------
boilWater
Tea.brew
pourInCup
Tea.addCondiments
</code></pre>
<h3><a class="header" href="#jdk-36" id="jdk-36">JDK</a></h3>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
<h2><a class="header" href="#1-适配器adapter-1" id="1-适配器adapter-1">1. 适配器（Adapter）</a></h2>
<h3><a class="header" href="#intent-45" id="intent-45">Intent</a></h3>
<p>把一个类接口转换成另一个用户需要的接口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"/> </div><br>
<h3><a class="header" href="#class-diagram-45" id="class-diagram-45">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png"/> </div><br>
<h3><a class="header" href="#implementation-45" id="implementation-45">Implementation</a></h3>
<p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<pre><code class="language-java">public interface Duck {
    void quack();
}
</code></pre>
<pre><code class="language-java">public interface Turkey {
    void gobble();
}
</code></pre>
<pre><code class="language-java">public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println(&quot;gobble!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class TurkeyAdapter implements Duck {
    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    @Override
    public void quack() {
        turkey.gobble();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
</code></pre>
<h3><a class="header" href="#jdk-37" id="jdk-37">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29">java.util.Arrays#asList()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-">java.util.Collections#list()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-">java.util.Collections#enumeration()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-">javax.xml.bind.annotation.adapters.XMLAdapter</a></li>
</ul>
<h2><a class="header" href="#责任链chain-of-responsibility" id="责任链chain-of-responsibility">责任链（Chain Of Responsibility）</a></h2>
<h3><a class="header" href="#intent-46" id="intent-46">Intent</a></h3>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<h3><a class="header" href="#class-diagram-46" id="class-diagram-46">Class Diagram</a></h3>
<ul>
<li>Handler：定义处理请求的接口，并且实现后继链（successor）</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ca9f23bf-55a4-47b2-9534-a28e35397988.png"/> </div><br>
<h3><a class="header" href="#implementation-46" id="implementation-46">Implementation</a></h3>
<pre><code class="language-java">public abstract class Handler {

    protected Handler successor;


    public Handler(Handler successor) {
        this.successor = successor;
    }


    protected abstract void handleRequest(Request request);
}
</code></pre>
<pre><code class="language-java">public class ConcreteHandler1 extends Handler {

    public ConcreteHandler1(Handler successor) {
        super(successor);
    }


    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE1) {
            System.out.println(request.getName() + &quot; is handle by ConcreteHandler1&quot;);
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class ConcreteHandler2 extends Handler {

    public ConcreteHandler2(Handler successor) {
        super(successor);
    }


    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE2) {
            System.out.println(request.getName() + &quot; is handle by ConcreteHandler2&quot;);
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class Request {

    private RequestType type;
    private String name;


    public Request(RequestType type, String name) {
        this.type = type;
        this.name = name;
    }


    public RequestType getType() {
        return type;
    }


    public String getName() {
        return name;
    }
}

</code></pre>
<pre><code class="language-java">public enum RequestType {
    TYPE1, TYPE2
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {

        Handler handler1 = new ConcreteHandler1(null);
        Handler handler2 = new ConcreteHandler2(handler1);

        Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);
        handler2.handleRequest(request1);

        Request request2 = new Request(RequestType.TYPE2, &quot;request2&quot;);
        handler2.handleRequest(request2);
    }
}
</code></pre>
<pre><code class="language-html">request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2
</code></pre>
<h3><a class="header" href="#jdk-38" id="jdk-38">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29">java.util.logging.Logger#log()</a></li>
<li><a href="https://commons.apache.org/proper/commons-chain/index.html">Apache Commons Chain</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-">javax.servlet.Filter#doFilter()</a></li>
</ul>
<h2><a class="header" href="#享元flyweight" id="享元flyweight">享元（Flyweight）</a></h2>
<h3><a class="header" href="#intent-47" id="intent-47">Intent</a></h3>
<p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p>
<h3><a class="header" href="#class-diagram-47" id="class-diagram-47">Class Diagram</a></h3>
<ul>
<li>Flyweight：享元对象</li>
<li>IntrinsicState：内部状态，享元对象共享内部状态</li>
<li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5c22d5-9c0e-49e1-b5b0-6cc7032724d4.png"/> </div><br>
<h3><a class="header" href="#implementation-47" id="implementation-47">Implementation</a></h3>
<pre><code class="language-java">public interface Flyweight {
    void doOperation(String extrinsicState);
}
</code></pre>
<pre><code class="language-java">public class ConcreteFlyweight implements Flyweight {

    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void doOperation(String extrinsicState) {
        System.out.println(&quot;Object address: &quot; + System.identityHashCode(this));
        System.out.println(&quot;IntrinsicState: &quot; + intrinsicState);
        System.out.println(&quot;ExtrinsicState: &quot; + extrinsicState);
    }
}
</code></pre>
<pre><code class="language-java">public class FlyweightFactory {

    private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();

    Flyweight getFlyweight(String intrinsicState) {
        if (!flyweights.containsKey(intrinsicState)) {
            Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
            flyweights.put(intrinsicState, flyweight);
        }
        return flyweights.get(intrinsicState);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight flyweight1 = factory.getFlyweight(&quot;aa&quot;);
        Flyweight flyweight2 = factory.getFlyweight(&quot;aa&quot;);
        flyweight1.doOperation(&quot;x&quot;);
        flyweight2.doOperation(&quot;y&quot;);
    }
}
</code></pre>
<pre><code class="language-html">Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
</code></pre>
<h3><a class="header" href="#jdk-39" id="jdk-39">JDK</a></h3>
<p>Java 利用缓存来加速大量小对象的访问时间。</p>
<ul>
<li>java.lang.Integer#valueOf(int)</li>
<li>java.lang.Boolean#valueOf(boolean)</li>
<li>java.lang.Byte#valueOf(byte)</li>
<li>java.lang.Character#valueOf(char)</li>
</ul>
<h2><a class="header" href="#6-原型模式prototype-1" id="6-原型模式prototype-1">6. 原型模式（Prototype）</a></h2>
<h3><a class="header" href="#intent-48" id="intent-48">Intent</a></h3>
<p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<h3><a class="header" href="#class-diagram-48" id="class-diagram-48">Class Diagram</a></h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b8922f8c-95e6-4187-be85-572a509afb71.png"/> </div><br>
<h3><a class="header" href="#implementation-48" id="implementation-48">Implementation</a></h3>
<pre><code class="language-java">public abstract class Prototype {
    abstract Prototype myClone();
}
</code></pre>
<pre><code class="language-java">public class ConcretePrototype extends Prototype {

    private String filed;

    public ConcretePrototype(String filed) {
        this.filed = filed;
    }

    @Override
    Prototype myClone() {
        return new ConcretePrototype(filed);
    }

    @Override
    public String toString() {
        return filed;
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype(&quot;abc&quot;);
        Prototype clone = prototype.myClone();
        System.out.println(clone.toString());
    }
}
</code></pre>
<pre><code class="language-html">abc
</code></pre>
<h3><a class="header" href="#jdk-40" id="jdk-40">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29">java.lang.Object#clone()</a></li>
</ul>
<h2><a class="header" href="#解释器interpreter" id="解释器interpreter">解释器（Interpreter）</a></h2>
<h3><a class="header" href="#intent-49" id="intent-49">Intent</a></h3>
<p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<h3><a class="header" href="#class-diagram-49" id="class-diagram-49">Class Diagram</a></h3>
<ul>
<li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。</li>
<li>Context：上下文，包含解释器之外的一些全局信息。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b125bcd-1b36-43be-9b78-d90b076be549.png"/> </div><br>
<h3><a class="header" href="#implementation-49" id="implementation-49">Implementation</a></h3>
<p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p>
<p>例如一颗解析树为 D And (A Or (B C))，文本 &quot;D A&quot; 满足该解析树定义的规则。</p>
<p>这里的 Context 指的是 String。</p>
<pre><code class="language-java">public abstract class Expression {
    public abstract boolean interpret(String str);
}
</code></pre>
<pre><code class="language-java">public class TerminalExpression extends Expression {

    private String literal = null;

    public TerminalExpression(String str) {
        literal = str;
    }

    public boolean interpret(String str) {
        StringTokenizer st = new StringTokenizer(str);
        while (st.hasMoreTokens()) {
            String test = st.nextToken();
            if (test.equals(literal)) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<pre><code class="language-java">public class AndExpression extends Expression {

    private Expression expression1 = null;
    private Expression expression2 = null;

    public AndExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }

    public boolean interpret(String str) {
        return expression1.interpret(str) &amp;&amp; expression2.interpret(str);
    }
}
</code></pre>
<pre><code class="language-java">public class OrExpression extends Expression {
    private Expression expression1 = null;
    private Expression expression2 = null;

    public OrExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }

    public boolean interpret(String str) {
        return expression1.interpret(str) || expression2.interpret(str);
    }
}
</code></pre>
<pre><code class="language-java">public class Client {

    /**
     * 构建解析树
     */
    public static Expression buildInterpreterTree() {
        // Literal
        Expression terminal1 = new TerminalExpression(&quot;A&quot;);
        Expression terminal2 = new TerminalExpression(&quot;B&quot;);
        Expression terminal3 = new TerminalExpression(&quot;C&quot;);
        Expression terminal4 = new TerminalExpression(&quot;D&quot;);
        // B C
        Expression alternation1 = new OrExpression(terminal2, terminal3);
        // A Or (B C)
        Expression alternation2 = new OrExpression(terminal1, alternation1);
        // D And (A Or (B C))
        return new AndExpression(terminal4, alternation2);
    }

    public static void main(String[] args) {
        Expression define = buildInterpreterTree();
        String context1 = &quot;D A&quot;;
        String context2 = &quot;A B&quot;;
        System.out.println(define.interpret(context1));
        System.out.println(define.interpret(context2));
    }
}
</code></pre>
<pre><code class="language-html">true
false
</code></pre>
<h3><a class="header" href="#jdk-41" id="jdk-41">JDK</a></h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.Pattern</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html">java.text.Normalizer</a></li>
<li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html">java.text.Format</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html">javax.el.ELResolver</a></li>
</ul>
<h1><a class="header" href="#目录-12" id="目录-12">目录</a></h1>
<ul>
<li><a href="./SUMMARY.html">C++</a>
<ul>
<li><a href="./C++/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html">C++面试题.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">系统设计</a>
<ul>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1.html">短链接服务.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1.html">工程设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6URL%E5%8E%BB%E9%87%8D.html">两个文件URL去重.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E6%B3%A8%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1.html">关注关系设计.md</a></li>
<li><a href="./%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html">秒杀系统.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">操作系统</a>
<ul>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">计算机操作系统-死锁.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">计算机操作系统-概述.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">计算机操作系统-内存管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">进程与线程通信方式.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">计算机操作系统-链接.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">计算机操作系统-设备管理.md</a></li>
<li><a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">计算机操作系统-进程管理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">算法</a></li>
<li><a href="./SUMMARY.html">redis</a>
<ul>
<li><a href="./redis/Redis.html">Redis.md</a></li>
<li><a href="./redis/Redis21%E9%97%AE.html">Redis21问.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">网络安全</a>
<ul>
<li><a href="./%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">数据库</a>
<ul>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html">分库分表.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.html">缓存.md</a></li>
<li><a href="./%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">java</a>
<ul>
<li><a href="./java/JavaIO.html">JavaIO.md</a></li>
<li><a href="./java/Java%E5%B9%B6%E5%8F%91.html">Java并发.md</a></li>
<li><a href="./java/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html">Java面试题.md</a></li>
<li><a href="./java/Java%E5%9F%BA%E7%A1%80.html">Java基础.md</a></li>
<li><a href="./java/Java%E5%AE%B9%E5%99%A8.html">Java容器.md</a></li>
<li><a href="./java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java虚拟机.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">计算机网络</a>
<ul>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html">HTTP.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">计算机网络-网络层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">计算机网络-应用层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">计算机网络-概述.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket.html">Socket.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html">TCP和UDP的区别.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">计算机网络-物理层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">计算机网络-链路层.md</a></li>
<li><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">计算机网络-传输层.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">常识</a>
<ul>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Python.html">Python.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%BB%93%E9%9B%86.html">结集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E7%AE%80%E5%8E%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html">简历的重要性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86.html">腾讯面试合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">常用组件.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">数据结构与算法.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html">计算机基础.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Git.html">Git.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">代码可读性.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/Docker.html">Docker.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html">阿里面试题合集.md</a></li>
<li><a href="./%E5%B8%B8%E8%AF%86/%E9%9B%86%E7%BE%A4.html">集群.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">设计模式</a>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html">设计模式-简单工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">设计模式-代理.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">设计模式-外观.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">设计模式-观察者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">设计模式-装饰.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">设计模式-迭代器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">设计模式-组合.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">设计模式-状态.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">设计模式-单例.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html">设计模式-抽象工厂.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html">设计模式-生成器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">设计模式-策略.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">设计模式-命令.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">设计模式-桥接.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html">设计模式-工厂方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">设计模式-中介者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">设计模式-访问者.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">设计模式-空对象.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">设计模式-备忘录.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">设计模式-模板方法.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">设计模式-适配器.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">设计模式-责任链.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">设计模式-享元.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">设计模式-原型模式.md</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">设计模式-解释器.md</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">前端</a>
<ul>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF.html">前端.md</a></li>
<li><a href="./%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88210%E9%97%AE.html">前端工程师210问.md</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#四种居中的方式" id="四种居中的方式">四种居中的方式</a></h1>
<h2><a class="header" href="#水平居中" id="水平居中">水平居中</a></h2>
<ul>
<li>行内元素: text-align: center</li>
<li>块级元素: margin: 0 auto</li>
<li>position:absolute +left:50%+ transform:translateX(-50%)</li>
<li>display:flex + justify-content: center</li>
</ul>
<h2><a class="header" href="#垂直居中" id="垂直居中">垂直居中</a></h2>
<ul>
<li>设置line-height 等于height</li>
<li>position：absolute +top:50%+ transform:translateY(-50%)</li>
<li>display:flex + align-items: center</li>
<li>display:table+display:table-cell + vertical-align: middle;</li>
</ul>
<h1><a class="header" href="#尺寸单位" id="尺寸单位">尺寸单位</a></h1>
<h2><a class="header" href="#rem" id="rem">rem</a></h2>
<p>rem是全部的长度都相对于根元素<html>元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。</p>
<h2><a class="header" href="#em" id="em">em</a></h2>
<p>子元素字体大小的em是相对于父元素字体大小
元素的width/height/padding/margin用em的话是相对于该元素的font-size
vw/vh
全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。</p>
<h2><a class="header" href="#px" id="px">px</a></h2>
<p>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</p>
<p>一般电脑的分辨率有{1920*1024}等不同的分辨率</p>
<p>1920*1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素</p>
<h1><a class="header" href="#如何画一条高度为05px的直线" id="如何画一条高度为05px的直线">如何画一条高度为0.5px的直线</a></h1>
<p>使用transform</p>
<pre><code class="language-plain">height: 1px;
transform: scale(0.5);
</code></pre>
<h1><a class="header" href="#cors" id="cors">CORS</a></h1>
<p>CORS是一种新的w3c标准，相当于ajax的补充，用于执行跨域ajax请求。是jsonp的替代者。</p>
<h1><a class="header" href="#event对象中target和currenttarget的区别" id="event对象中target和currenttarget的区别">event对象中target和currentTarget的区别</a></h1>
<ul>
<li>currentTarget当前所绑定事件的元素</li>
<li>target当前被点击的元素</li>
</ul>
<h1><a class="header" href="#宏任务和微任务" id="宏任务和微任务">宏任务和微任务？</a></h1>
<p>宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。<br />
微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick等等）。<br />
宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</p>
<h1><a class="header" href="#get请求和post请求的区别" id="get请求和post请求的区别">get请求和post请求的区别</a></h1>
<p>1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内</p>
<p>2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</p>
<p>3.get后退不会有影响，post后退会重新进行提交</p>
<p>4.get请求可以被缓存，post不可以被缓存</p>
<p>5.get请求只URL编码，post支持多种编码方式</p>
<p>6.get请求的记录会留在历史记录中，post请求不会留在历史记录</p>
<p>7.get只支持ASCII字符，post没有字符类型限制</p>
<h1><a class="header" href="#http状态码" id="http状态码">HTTP状态码</a></h1>
<p>1xx(临时响应)
100: 请求者应当继续提出请求。
101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。
2xx(成功)
200：正确的请求返回正确的结果
201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。
202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。
3xx(已重定向)
300：请求成功，但结果有多种选择。
301：请求成功，但是资源被永久转移。
303：使用 GET 来访问新的地址来获取资源。
304：请求的资源并没有被修改过
4xx(请求错误)
400：请求出现错误，比如请求头不对等。
401：没有提供认证信息。请求的时候没有带上 Token 等。
402：为以后需要所保留的状态码。
403：请求的资源不允许访问。就是说没有权限。
404：请求的内容不存在。
5xx(服务器错误)
500：服务器错误。
501：请求还没有被实现。</p>
<h1><a class="header" href="#清除浮动的方法" id="清除浮动的方法">清除浮动的方法</a></h1>
<ol>
<li>在浮动元素后面添加一个空的清除浮动的div</li>
</ol>
<pre><code class="language-plain">&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
</code></pre>
<ol start="2">
<li>使用css :after伪类
这种方法是最好的，它不需要更改HTML，只更改样式即可。</li>
</ol>
<pre><code class="language-plain">.content:after{
     content:&quot;.&quot;;
     display:block;
     height:0;
     visibility:hidden;
     clear:both;
 }
</code></pre>
<p>1、手写jsonp的实现</p>
<p>2、手写链表倒数第K个查找</p>
<p>3、http请求头，请求体，cookie在哪个里面？url在哪里面？</p>
<p>4、原型链的解释</p>
<p>5、对闭包的理解，实现一个暴露内部变量，而且外部可以访问修改的函数</p>
<p>6、基本的数据类型</p>
<p>7、基本的两列自适应布局</p>
<p>8、unix中常用的命令行</p>
<p>9、OSI模型，HTTP,TCP,UDP分别在哪些层</p>
<p>10、解释平衡二叉树，以及在数据结构中的应用（红黑树）</p>
<p>11、快排的时间复杂度和空间复杂度</p>
<p>12、手写一个jQuery插件</p>
<p>13、在jquery方法和原型上面添加方法的区别和实现，以及jquery对象的实现</p>
<p>14、手写一个递归函数</p>
<p>15、对前端路由的理解？前后端路由的区别？</p>
<p>16、介绍一下webpack和gulp，以及项目中具体的使用</p>
<p>17、你对es6的了解</p>
<p>18、解释一下vue和react，以及异同点</p>
<p>19、关于平衡二叉树</p>
<p>20、前后端分离的意义以及对前端工程化的理解</p>
<p>21、使用css实现一个三角形</p>
<p>22、用promise手写ajax</p>
<p>23、手写一个类的继承，并解释一下</p>
<p>24、解释一下call函数和apply函数的作用，以及用法</p>
<p>25、你说自己抗压能力强，具体表现在哪里？</p>
<p>26、对前端前景的展望，以后前端会怎么发展</p>
<p>27、手写第一次面试没有写出来的链表问题，要求用es6写</p>
<p>28、平时是怎么学技术的？</p>
<p>29、平时大学里面时间是怎么规划的？</p>
<p>30、接下来有什么计划？这个学期和下个学期的计划是？</p>
<p>31、项目中遇到的难点，或者你学习路上的难点</p>
<p>32、你是通过什么方法和途径来学习前端的</p>
<p>33、手写一个简单遍历算法</p>
<p>34、解释一下react和vue，以及区别</p>
<p>35、你在团队中更倾向于什么角色？</p>
<p>36、对java的理解</p>
<p>37、介绍node.js，并且介绍你用它做的项目</p>
<p>38、手写一个js的深克隆</p>
<p>39、for函数里面setTimeout异步问题</p>
<p>40、手写归并排序</p>
<p>41、介绍自己的项目</p>
<p>42、实现两个数组的排序合并</p>
<p>43、手写一个原生ajax</p>
<p>44、手写一个promise版的ajax</p>
<p>45、手写实现一个promise</p>
<p>46、手写实现requireJS模块实现</p>
<p>47、手写实现jquery里面的insertAfter</p>
<p>48、react和vue的介绍以及异同</p>
<p>49、AMD和CMD，commonJS的区别</p>
<p>50、介绍一下backbone</p>
<p>51、了解过SEO吗？</p>
<p>52、低版本浏览器不支持HTML5标签怎么解决？</p>
<p>53、用js使低版本浏览器支持HTML5标签 底层是怎么实现的？</p>
<p>54、实现一个布局：左边固定宽度为200，右边自适应，而且滚动条要自动选择只出现最高的那个</p>
<p>55、画出盒子模型，要使谷歌浏览器的盒子模型显示得跟IE浏览器一致（让谷歌跟ie一致，不是ie跟谷歌一致），该怎么做？</p>
<p>56、手写JS实现类继承，讲原型链原理，并解释new一个对象的过程都发生了什么</p>
<p>57、Array对象自带的方法，一一列举</p>
<p>58、若干个数字，怎么选出最大的五个</p>
<p>59、Array对象自带的排序函数底层是怎么实现的？</p>
<p>60、常用的排序算法有哪些，介绍一下选择排序</p>
<p>61、了解navigator对象吗？</p>
<p>62、手写一个正则表达式，验证邮箱</p>
<p>63、link和@import引入CSS的区别？</p>
<p>64、刚才说有些浏览器不兼容@import，具体指哪些浏览器？</p>
<p>65、介绍一下cookie,localstorage,sessionstorage,session</p>
<p>66、jquery绑定click的方法有几种</p>
<p>67、你的优点/竞争力</p>
<p>68、移动端适配问题</p>
<p>69、react的难点在哪里</p>
<p>70、做过css动画吗</p>
<p>71、如何优化网站</p>
<p>72、以后的规划</p>
<p>73、你做过最困难的事情是啥？</p>
<p>74、css3 html5新特性</p>
<p>75、闭包，ES6，跨域</p>
<p>76、问做过啥项目，用到什么技术，遇到什么困难</p>
<p>77、兼容性</p>
<p>78、盒子模型</p>
<p>79、Array的unshift() method的作用是什么？如何连接两个Array？如何在Array里移除一个元素？</p>
<p>80、用纸笔写一个Closure，任意形式和内容</p>
<p>81、知不知道Array-like Object？</p>
<p>82、如何用Native JavaScript来读写Cookie？</p>
<p>83、知不知道CSS Box-model？</p>
<p>84、如何做一个AJAX Request？</p>
<p>85、Cross-domain access有没有了解？</p>
<p>86、前端安全方面有没有了解？XSS和CSRF如何攻防？</p>
<p>87、HTTP Response的Header里面都有些啥？</p>
<p>88、知不知道HTTP2？</p>
<p>89、输入URL后发生了什么？</p>
<p>90、new operator实际上做了什么？</p>
<p>91、面向对象的属性有哪些？</p>
<p>92、做一个两栏布局，左边fixed width，右边responsive，用纸笔手写</p>
<p>93、讲一下AJAX Request</p>
<p>94、讲一下Cross-domain access</p>
<p>95、介绍一下做过的项目</p>
<p>96、问到了多个服务器怎么弄，架构之类的</p>
<p>97、angular的渲染流程</p>
<p>98、脏检查</p>
<p>99、nodejs的架构、优缺点、回调</p>
<p>100、css 盒模型</p>
<p>101、css 布局，左边定宽右边自适应</p>
<p>102、冒泡和捕获，事件流哪三个阶段？</p>
<p>103、实现事件代理</p>
<p>104、原型链</p>
<p>105、继承的两种方法</p>
<p>106、ajax，原生ajax的四个过程</p>
<p>107、闭包，简单说一个闭包的应用，然后闭包的主要作用是什么</p>
<p>108、css:两个块状元素上下的margin-top和margin-bottom会重叠。啥原因？怎么解决？</p>
<p>109、js：写一个递归。就是每隔5秒调用一个自身，一共100次</p>
<p>110、cookie和session有什么区别</p>
<p>111、网络分层结构</p>
<p>112、你的不足是什么？</p>
<p>113、做了那么多项目，有没有自己的归纳总结</p>
<p>114、工程怎么进行文件管理</p>
<p>115、less和sass掌握程度</p>
<p>116、Cookie 是否会被覆盖，localStorage是否会被覆盖</p>
<p>117、事件代理js实现</p>
<p>118、Css实现动画效果</p>
<p>119、Animation还有哪些其他属性</p>
<p>120、Css实现三列布局</p>
<p>121、Css实现保持长宽比1:1</p>
<p>122、Css实现两个自适应等宽元素中间空10个像素</p>
<p>123、requireJS的原理是什么</p>
<p>124、如何保持登录状态</p>
<p>125、浮动的原理以及如何清除浮动</p>
<p>126、Html的语义化</p>
<p>127、原生js添加class怎么添加，如果本身已经有class了，会不会覆盖，怎么保留？</p>
<p>128、Jsonp的原理。怎么去读取一个script里面的数据？</p>
<p>129、如果页面初始载入的时候把ajax请求返回的数据存在localStorage里面，然后每次调用的时候去localStorage里面取数，是否可行。</p>
<p>130、304是什么意思？有没有方法不请求不经过服务器直接使用缓存</p>
<p>131、http请求头有哪些字段</p>
<p>132、数组去除一个函数。用arr.splice。又问splice返回了什么？应该返回的是去除的元素。</p>
<p>133、js异步的方法（promise，generator，async）</p>
<p>134、Cookie跨域请求能不能带上</p>
<p>135、最近看什么开源项目？</p>
<p>136、commonJS和AMD</p>
<p>137、平时是怎么学习的？</p>
<p>138、为什么要用translate3d？</p>
<p>139、对象中key-value的value怎么再放一个对象？</p>
<p>140、Get和post的区别？</p>
<p>145、Post一个file的时候file放在哪的？</p>
<p>146、说说你对组件的理解</p>
<p>147、组件的html怎么进行管理</p>
<p>148、js的异步加载，promise的三种状态，ES7中的async用过么</p>
<p>149、静态属性怎么继承</p>
<p>150、js原型链的继承</p>
<p>151、jquery和zepto有什么区别</p>
<p>152、angular的双向绑定原理</p>
<p>153、angular和react的认识</p>
<p>154、MVVM是什么</p>
<p>155、移动端是指手机浏览器，还是native，还是hybrid</p>
<p>156、你用了移动端的什么库类和框架？</p>
<p>157、移动端要注意哪些？</p>
<p>158、适配有去考虑么，retina屏幕啊？</p>
<p>159、rem是什么？em是什么？如果上一层就是根root了，em和rem等价么？</p>
<p>160、怎么测试的？会自动化测试么？</p>
<p>161、你觉得你什么技术最擅长？</p>
<p>162、你平时有没有什么技术的沉淀？</p>
<p>163、单向链表怎么查找有没有环？</p>
<p>164、怎么得到一个页面的a标签？</p>
<p>165、怎么在页面里放置一个很简单的图标，不能用img和background-img？</p>
<p>166、正则表达式判断url</p>
<p>167、怎么去除字符串前后的空格</p>
<p>168、实现页面的局部刷新</p>
<p>169、绝对定位与相对定位的区别</p>
<p>170、js轮播实现思路</p>
<p>171、使用js画一个抛物线，抛物线上有个小球随着抛物线运动，有两个按钮能使小球继续运动停止运动</p>
<p>172、java五子棋，说下实现思路</p>
<p>173、如何让各种情况下的div居中(绝对定位的div,垂直居中,水平居中)？</p>
<p>174、display有哪些值？说明他们的作用</p>
<p>175、css定义的权重</p>
<p>176、requirejs实现原理</p>
<p>177、requirejs怎么防止重复加载</p>
<p>178、ES6里头的箭头函数的this对象与其他的有啥区别</p>
<p>179、tcp/udp区别</p>
<p>180、tcp三次握手过程</p>
<p>181、xss与csrf的原理与怎么防范</p>
<p>182、mysql与 MongoDB的区别</p>
<p>183、w3c事件与IE事件的区别</p>
<p>184、有没有上传过些什么npm模块</p>
<p>185、IE与W3C怎么阻止事件的冒泡</p>
<p>186、gulp底层实现原理</p>
<p>187、webpack底层实现原理</p>
<p>188、gulp与webpack区别</p>
<p>189、vuejs与angularjs的区别</p>
<p>190、vuex是用来做什么的</p>
<p>191、说下你知道的响应状态码</p>
<p>192、ajax的过程以及 readyState几个状态的含义</p>
<p>193、你除了前端之外还会些什么？</p>
<p>194、cookie与session的区别</p>
<p>195、一些关于php与java的问题</p>
<p>196、你觉得你哪个项目是你做的最好的</p>
<p>197、说说你在项目中遇到了哪些困难,是怎么解决的</p>
<p>198、前端优化你知道哪些</p>
<p>199、webpack是用来干嘛的</p>
<p>200、webpack与gulp的区别</p>
<p>201、es6与es7了解多少</p>
<p>202、说下你知道的响应状态码</p>
<p>203、看过哪些框架的源码</p>
<p>204、遇到过哪些浏览器兼容性问题</p>
<p>205、清除浮动有哪几种方式,分别说说</p>
<p>206、你知道有哪些跨域方式,分别说说</p>
<p>207、JavaScript有哪几种类型的值</p>
<p>208、使用 new操作符时具体是干了些什么</p>
<p>209、学习前端的方法以及途径</p>
<p>210、怎么实现两个大整数的相乘，说下思路</p>
<p>211、你学过数据结构没,说说你都了解些什么</p>
<p>212、你学过计算机操作系统没,说说你都了解些什么</p>
<p>213、你学过计算机组成原理没,说说你都了解些什么</p>
<p>214、你学过算法没,说说你都了解些什么</p>
<p>215、说下选择排序,冒泡排序的实现思路</p>
<p>216、用过哪些框架</p>
<p>217、让你设计一个前端css框架你怎么做</p>
<p>218、了解哪些设计模式说说看</p>
<p>219、说下你所了解的设计模式的优点</p>
<p>220、vue源码结构</p>
<p>221、状态码</p>
<p>222、浏览器缓存的区别</p>
<p>223、304与200读取缓存的区别</p>
<p>224、http请求头有哪些,说说看你了解哪些</p>
<p>225、js中this的作用</p>
<p>226、js中上下文是什么</p>
<p>227、js有哪些函数能改变上下文</p>
<p>228、你所了解的跨域的方法都说说看你了解的？</p>
<p>229、要是让你自己写一个js框架你会用到哪些设计模式</p>
<p>230、平常在项目中用到过哪些设计模式,说说看</p>
<p>231、一来给了张纸要求写js自定义事件</p>
<p>232、前端跨域的方法</p>
<p>233、call与apply的区别</p>
<p>234、h5有个api能定位你知道是哪个吗？</p>
<p>235、vue与angularjs中双向数据绑定是怎样实现的？</p>
<p>236、webpack怎样配置？</p>
<p>237、nodejs中的文件怎么读写？</p>
<p>238、link和@import有什么区别？</p>
<p>239、cookies，sessionStorage 和 localStorage 的区别</p>
<p>240、看过哪些前端的书？平时是怎么学习的</p>
<p>241、说下你所理解的mvc与mvvc</p>
<p>242、position有哪些值,说下各自的作用</p>
<p>243、写个从几个li中取下标的闭包代码</p>
<p>244、你的职业规划是怎么样的？</p>
<p>245、移动端性能优化</p>
<p>246、lazyload如何实现</p>
<p>247、点透问题</p>
<p>248、前端安全</p>
<p>249、原生js模板引擎</p>
<p>250、repaint和reflow区别</p>
<p>251、requirejs如何避免循环依赖？</p>
<p>252、实现布局：左边一张图片，右边一段文字（不是环绕）</p>
<p>253、window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？</p>
<p>254、form表单当前页面无刷新提交 target iframe</p>
<p>255、setTimeout和setInterval区别，如何互相实现？</p>
<p>256、如何避免多重回调—promise，promise简单描述一下，如何在外部进行resolve()</p>
<p>257、margin坍塌？水平方向会不会坍塌？</p>
<p>258、伪类和伪元素区别</p>
<p>259、vue如何实现父子组件通信，以及非父子组件通信</p>
<p>260、数组去重</p>
<p>261、使用flex布局实现三等分，左右两个元素分别贴到左边和右边，垂直居中</p>
<p>262、平时如何学前端的，看了哪些书，关注了哪些公众号</p>
<p>263、实现bind函数</p>
<p>264、数组和链表区别，分别适合什么数据结构</p>
<p>265、对mvc的理解</p>
<p>266、描述一个印象最深的项目，在其中担任的角色，解决什么问题</p>
<p>267、http状态码。。。401和403区别？</p>
<p>268、描述下二分查找</p>
<p>269、为什么选择前端，如何学习的，看了哪些书，《js高级程序设计》和《你不知道的js》有什么区别，看书，看博客，看公众号三者的时间是如何分配的？</p>
<p>270、如何评价BAT？</p>
<p>271、描述下在实习中做过的一个项目，解决了什么问题，在其中担任了什么角色？这个过程存在什么问题，有什么值得改进的地方？</p>
<p>272、如何看待加班，如果有个项目需要连续一个月加班，你怎么看？</p>
<p>273、遇到的压力最大的一件事是什么？如何解决的？</p>
<p>274、平时有什么爱好</p>
<p>275、自身有待改进的地方</p>
<p>276、n长的数组放入n+1个数，不能重复，找出那个缺失的数</p>
<p>277、手里有什么offer</p>
<p>278、你对于第一份工作最看重的三个方面是什么？</p>
<p>279、如何评价现在的前端？</p>
<p>280、用原生js实现复选框选择以及全选非全选功能</p>
<p>281、用4个颜色给一个六面体上色有多少种情况</p>
<p>282、amd和cmd区别</p>
<p>283、为什么选择前端，移动端性能优化</p>
<p>284、vue的特点？双向数据绑定是如何实现的</p>
<p>285、Object.defineProperty</p>
<p>286、算法题：数组去重，去除重复两次以上的元素，代码题：嵌套的ul-li结构，根据input中输入的内容，去除相应的li节点，且如果某个嵌套的ul下面的li都被移除，则该ul的父li节点也要被移除</p>
<p>287、页面加载过程</p>
<p>288、浏览器如何实现图片缓存</p>
<ol>
<li>express和koa的对比，两者中间件的原理，koa捕获异常多种情况说一下</li>
<li>你项目里用到第三方登录涉及的oAuth(JWT)协议的实现原理，以及你本地的实现原理，第三方登录怎么样保证安全性</li>
<li>说下快排完整性</li>
<li>react和vue的区别，你开发如何选择技术栈</li>
<li>express里面登录的session服务怎么样实现分布式服务</li>
<li>vue的理解</li>
<li>vue的双向数据绑定的原理</li>
<li>vue怎么样实现数组绑定</li>
<li>js的继承</li>
<li>call和apply的区别</li>
<li>ajax是同步还是异步，怎么样实现同步</li>
<li>ajax实现过程</li>
<li>闭包的作用理解，以及那些地方用过闭包，以及闭包的缺点，如何实现闭包</li>
<li>跨域方法以及怎么样实现的与原理</li>
<li>工作中做的项目有什么亮点</li>
<li>webpack工程构建工具怎么样用</li>
<li>数组去重</li>
<li>快排和冒泡原理</li>
<li>http状态码</li>
<li>nodejs了解多少</li>
<li>为什么css样式初始化，目的是为了什么</li>
<li>为什么浏览器会产生同源策略</li>
<li>axios有什么特点</li>
<li>cookie和webstrage的区别以及cookie怎么样使用？原生cookie怎么样封装</li>
<li>三次握手</li>
<li>对跨域了解吗。jsonp的限制</li>
<li>浏览器那些地方用到了异步</li>
<li>css弹性布局，那些地方用到过</li>
<li>position属性有哪些值，分别有什么含义</li>
<li>ES6用过吗，新增了那些东西，你用到过什么</li>
<li>const和let的区别，可以改变const定义对象某个属性吗</li>
<li>箭头函数，箭头函数的特点</li>
<li>js的this理解， 如何改变this的指向</li>
<li>cookie有什么限制</li>
<li>js的事件机制</li>
<li>settimeout的机制</li>
<li>遇到过兼容性的问题吗，要如何处理</li>
<li>项目中使用过构建工具吗</li>
<li>平时如何学习前端的，最近在看的一本书</li>
<li>内存泄露的排除定位和解决方法</li>
<li>垃圾回收机制</li>
<li>websocket实现原理</li>
<li>http状态码301 302的区别，304是啥</li>
<li>缓存机制，协商协议</li>
<li>定时器setTimeout的运行机制</li>
<li>事件循环机制 eventloop</li>
<li>异步es5 es6 es7分别怎么样解决</li>
<li>js的继承的实现方法</li>
<li>清除浮动的方法</li>
<li>常见布局的方法</li>
<li>从输入一个url到浏览器页面展示都经历了哪些过程</li>
<li>new生成了一个对象的过程（核心return this）</li>
<li>请简单说明什么是事件冒泡和事件捕获以及事件委托</li>
<li>实现一个两边宽度固定中间自适应的三列布局，圣杯布局，双飞燕</li>
<li>flex布局有没有了解</li>
<li>请简述一下js原型链</li>
<li>es6有了解吗，请简单说一下promise机制，异步的承诺机制，顺势说一下解决回调地狱的问题</li>
<li>手写一下深拷贝，答案提示：JSON.parse(JSON.stringify(obj)) 用JSON实现深拷贝</li>
<li>== 和 === 的却别，，typeof null的结果是什么</li>
<li>同步和异步的执行顺序</li>
<li>get和post的请求区别</li>
<li>什么情况算是跨域，如何解决跨域问题</li>
<li>一个有序的数组如何进行查找操作</li>
<li>手写一个快速排序</li>
<li>事件委托理解，原理，好处，应用场景</li>
<li>前端框架用过什么？</li>
<li>vue和react的区别</li>
<li>vue的原理</li>
<li>闭包</li>
<li>let和var的区别，let的产生背景？</li>
<li>定宽定高，如何垂直居中，那不定宽定高呢？</li>
<li>https的请求过程</li>
<li>代码规范</li>
<li>项目中遇到过什么难点，如何解决的</li>
<li>尾递归问题</li>
<li>电脑里有很多大小不一样的照片，我现在要复制到U盘上，但是U盘容量固定，让你写一个程序，挑选一组照片，让U盘的剩余空间最小。</li>
<li>后端会哪些语言</li>
<li>讲下如何负载均衡</li>
<li>cookie和session的区别和联系</li>
<li>nodejs是单线程还是多线程的，为什么能去开很多异步请求去访问其他接口</li>
<li>一般你是如何操作数据库的？会哪些数据库</li>
<li>mysql的底层引擎，发布</li>
<li>mysql语言写的如何，怎么样判断sql语句的性能？如何优化？</li>
<li>如何去除数组中的重复的项？</li>
<li>遍历数组处理用for循环还有什么方法吗</li>
<li>浏览器出于安全考虑有？（同源策略）</li>
<li>登录原理</li>
<li>让我设计一个页面，选择男或女，搜索出相对性</li>
<li>发送请求有哪些？</li>
<li>web的安全问题？</li>
<li>自我介绍</li>
<li>JS如何计算浏览器的渲染时间的</li>
<li>浏览器的缓存</li>
<li>var的变量提升底层原理是什么？</li>
<li>event loop讲讲</li>
<li>JS的回收机制说一下</li>
<li>数组常用的方法有哪些</li>
<li>websock的底层原理讲讲</li>
<li>你的聊天室项目，如果数据传输出错了怎么办？</li>
<li>现在有一大段文字，如何在页面中设置一个窗口滚动播出这段文件（轮播），轮播图如何解决卡顿问题，有手写过轮播图你，原理是什么</li>
<li>垂直水平居中的方式</li>
<li>实现三栏布局，中间自适应有几种方法</li>
<li>算法：给你一个无序数字数组，里面是随机的书，并给出一个目标值，求这个数组的两个数，这个数的和等于目标值，要求这两个数并给出下标，你能想到最优的办法是什么吗（提示：快排，双指针）</li>
<li>算法：给一个无序的数组，让我分割成m组，这个m组里和最大的一组是所有可能的分割情况最小的（二分答案法）</li>
<li>webpack的原理</li>
<li><em>proto</em> 和prototype分别是什么</li>
<li>原型链原理</li>
<li>在原型链上Object再往上是什么</li>
<li>new和Object.create的区别</li>
<li>哪种情况下__proto__和prototype的指向是同一个？</li>
<li>typeof array null undefined NaN分别是什么</li>
<li>把undefined和null转成Number分别是什么</li>
<li>如何判断是否为数组？（instanceOf和constructor可以，但是有原型链断裂的风险，Object.toString.call()最稳定）</li>
<li>instanceOf和constructor的区别</li>
<li>原型链断裂了以后的结果是什么</li>
<li>如果让你实现一个promise怎么样实现</li>
<li>如何学前端的，看了哪些书</li>
<li>博客写了多少篇</li>
<li>你的技术亮点在哪里</li>
<li>写一下实现合理化</li>
<li>你对三大框架的理解是什么</li>
<li>前端性能理解，优化有哪些</li>
<li>nodejs了解多少</li>
<li>你遇到的最有难度的技术问题是什么</li>
<li>redux原理讲讲</li>
<li>了解web移动开发吗，移动端适配方案有哪些</li>
<li>你有Native开发经验吗，讲下Android如何调用页面的资源</li>
<li>行内元素和块级元素有哪些，img属于什么元素</li>
<li>margin坍塌</li>
<li>BFC原理</li>
<li>写一下清除浮动</li>
<li>写一下不知道宽高元素垂直水平居中方法</li>
<li>写一下节点的增删改</li>
<li>如何获取元素的父节点和兄弟节点</li>
<li>JS如何获得用户来源（navigator.userAgent）</li>
<li>跨域方法说一下</li>
<li>jsonp的原理是什么，处理script标签还可以通过什么实现？（静态资源标签）</li>
<li>原型链说一下</li>
<li>谈谈对原型链继承</li>
<li>前端缓存</li>
<li>给你一个乱序数组，你怎么样排序</li>
<li>你的项目有什么亮点</li>
<li>你的文件上传方案是什么</li>
<li>写一个方法提取一下search里面的参数</li>
<li>写一个API实现insertAfter</li>
<li>CSS3哪些用的比较多</li>
<li>CSS动画会吗，怎么样用CSS实现一个loading效果</li>
<li>如何处理CSS兼容问题</li>
<li>webpack有个插件可以解决css兼容性问题你知道吗（postcss-loader）</li>
<li>ES6新特性说说</li>
<li>ES6的代理是什么</li>
<li>let和var的区别讲讲</li>
<li>箭头函数和ES5和this的指向区别讲讲</li>
<li>前端安全这块了解多少</li>
<li>写一个API，实现jQuery的$(selector)选择器，要求兼容IE6</li>
<li>浏览器是如何实现通过你的代码去找到指定的元素的</li>
<li>用JS模拟一个双向链表</li>
<li>前端工程化思想</li>
<li>模块化思想</li>
<li>你为什么选择前端</li>
<li>cookie，session，localStorage和sessionStorage的区别</li>
<li>Nodejs的线程管理</li>
<li>JS设计模式有哪些</li>
<li>跨域的方法有哪些</li>
<li>说说bind，apply，call的区别以及bind的实现</li>
<li>算法：反转二叉树以及时间复杂度</li>
<li>链表找环</li>
<li>react的virtual DOM和Diff算法</li>
<li>React的生命周期</li>
<li>Vue的生命周期</li>
<li>boostrap的底层原理</li>
<li>图片压缩的原理</li>
<li>如何处理高并发的情况下，用户顺序问题</li>
<li>说一下web安全，xss，csrf防范</li>
<li>csrf流程，举例子</li>
<li>session+cookie的登录机制</li>
<li>token香港，浏览器缓存</li>
<li>vue双向绑定原理，vue-loader做了什么</li>
<li>webpack的插件大致流程</li>
<li>编程题：给出一个字符串(“obj.a”)，返回对象属性obj.a，类似eval的效果</li>
<li>前端路由会不会发请求</li>
<li>画布濡染有了解吗</li>
<li>前端监控，pm2，如果我服务器挂了，如何快速发现并且定位错误</li>
<li>pm2除了监控还能干什么，如何实现</li>
<li>express中间件如何实现</li>
<li>了解TCP吗，数据结构简单介绍一下以及你的想法</li>
<li>webpack项目太大了怎么办</li>
<li>深拷贝</li>
<li>如果弹出的菜单位置过于贴近边框，如何调整这个元素的位置</li>
<li>计算50个人至少有2个生日相同的概率</li>
<li>一个升序数组，求两个元素的和为一个指定数</li>
<li>vue的生命周期</li>
<li>vuex的状态管理的原理是什么</li>
<li>如何在浏览器端和原生端的代码复用，讲到weex又简单讲了它的原理</li>
<li>跨域如何解决</li>
<li>前端性能优化问题</li>
<li>csrf攻击原理以及防御手段</li>
<li>平衡二叉树</li>
<li>如何在上亿规模的数据中找到最大的一个数</li>
<li>最近看过的技术文章和一遍非技术文章（考察表达能力，和主动学习新知识的习惯）</li>
<li>算法题：二叉树层序遍历</li>
<li>JS的全排列</li>
<li>get和post的区别</li>
<li>301和302的区别</li>
<li>如何避免301跳转https</li>
<li>tcp建立连接三次握手的区别</li>
<li>操作系统进程和线程的区别</li>
<li>线程的哪些资源共享，哪些资源不共享</li>
<li>设计模式有哪些</li>
<li>Linux命令用的多吗，怎么样进行进程间通信</li>
<li>kill指令了解过吗</li>
<li>如何画一个三角形</li>
<li>CSS中对溢出的处理</li>
<li>CSS选择器有哪些，优先级呢？</li>
<li>ES6中用过什么</li>
<li>promise的状态有哪些</li>
<li>讲讲JS的闭包</li>
<li>你有用到express吗</li>
<li>express和koa2的区别</li>
<li>讲讲JS的语言特性吗</li>
<li>最近在学啥</li>
<li>项目用到JAVA，反射来讲</li>
<li>你用过什么数据库</li>
<li>MySQL里面的索引用过吗</li>
<li>B+树了解过吗</li>
<li>mongoDB有哪些特点</li>
<li>实现一个两列等高布局，思路</li>
<li>清除浮动的方法</li>
<li>如何让一个元素消失</li>
<li>重排和重绘</li>
<li>HTTP状态码</li>
<li>讲讲304</li>
<li>浏览器缓存机制</li>
<li>强缓存，协商缓存什么时候用哪个</li>
<li>如何判断一个数组</li>
<li>你说到typeof，能不能加一个限制条件typeof只能判断是object，可以判断一下是否拥有数组的方法</li>
<li>JS的如何实现倒计时，为什么不准，校正方式</li>
<li>JS实现跨域</li>
<li>React的特性</li>
<li>nodejs的时间方法讲讲看</li>
<li>nodejs的特性，适合处理什么场景</li>
<li>IO多路复用</li>
<li>前端优化</li>
<li>实现一个ajax，兼容</li>
<li>如何有一个很多的列表，像头条的新闻列表，用户看得多了，列表越来越大，怎么样处理，思考一下</li>
<li>如果有这样的场景：一个模块A作为输出，BCD等扩展模块可以在A做更改后展示A的原来内容或者驾驶CSS后的内容，想想思路</li>
<li>同一个网站，在上海打开慢，在北京打开快，怎么样分析原因，（DNS解析和CDN）</li>
<li>vue react jquery比较，有测试过性能吗</li>
<li>对大前端的理解，前端会发展怎么样</li>
<li>算法：两个排序好的数组，怎么样找他的中位数</li>
<li>React虚拟DOM，生命周期</li>
<li>react父子通信</li>
<li>nodejs如何require一个包</li>
<li>es6和es5的区别</li>
<li>Nodejs加载原生的包与自己定义的包路径如何查找</li>
<li>HTTP2.0的优势</li>
<li>flex弹性布局裂解，移动端适配方案有哪些</li>
<li>页面缓存</li>
<li>页面性能优化</li>
<li>css性能优化，就动画效果，如何从js，cs角度减少回流？</li>
<li>webpack的plugin和loader的区别</li>
<li>es5如何转为es5-babel</li>
<li>了解webpack如何打败</li>
<li>原型基础</li>
<li>BFC</li>
<li>原型链与作用域链</li>
<li>jQuery的源码看过没</li>
<li>移动端开发经验</li>
<li>css会吗</li>
<li>怎么样学前端</li>
<li>遇到问题如何解决</li>
<li>正则如何将一个数千分化表示</li>
<li>js设计模式知道哪些，单例详细说</li>
<li>函数式编程-柯里化</li>
<li>es6的变量定义和es5的区别</li>
<li>JS事件流</li>
<li>七层网络协议，每层干嘛的</li>
<li>tcp三次握手，四次挥手</li>
<li>排序算法有哪些，时间复杂度，选择排序怎么样搞</li>
<li>数据结构有哪些，红黑树和二叉树的区别，二叉搜索树与二叉平衡树</li>
<li>项目经验</li>
<li>树数据多少非常多怎么样办（懒加载）</li>
<li>页面优化方法</li>
<li>设计模式</li>
<li>cookie和session的却别</li>
<li>如果现在重新做这个项目，有什么想优化的</li>
<li>多长时间开始独立做前端，这段时间是如何学习的</li>
<li>学习生涯最失败的事情是什么，怎么样走出来的</li>
<li>如何看待竞争</li>
<li>项目里最难的事情，如何克服</li>
<li>职业规范是怎么样的</li>
<li>是独生子女吗</li>
<li>别人对你的项目认可度，项目做的怎么样</li>
<li>block元素和inline元素的区别</li>
<li>position有哪些，特性</li>
<li>css选择器有哪些</li>
<li>es5和es6：let，const打包后如何变-块级作用域</li>
<li>JS基本数据类型</li>
<li>作用域链</li>
<li>递归</li>
<li>react生命周期</li>
<li>react通信机制</li>
<li>js事件流</li>
<li>redux</li>
<li>flex弹性布局</li>
<li>this</li>
<li>promise如何从then转为catch的</li>
<li>介绍你做过的项目</li>
<li>promise函数</li>
<li>es6模块新特性</li>
<li>浏览器内存泄露，闭包内存泄露如何解决</li>
<li>怎么样让页面加载更快</li>
<li>兼容过IE的方法</li>
<li>缓存</li>
<li>会pc换还是移动端</li>
<li>观察者模式如何实现</li>
<li>行元素，块级元素的却别</li>
<li>css选择器的优先级</li>
<li>水平垂直居中布局</li>
<li>前端性能优化</li>
<li>闭包的概念，平时如何实现</li>
<li>es6的特性以及这些特性如何实现的</li>
<li>事件冒泡，事件捕获，事件委托的原理，如何实现委托，事件，委托的有点是什么，事件监听</li>
<li>输入URL浏览器是如何工作的</li>
<li>requirejs组件化</li>
<li>jQuery和vue的区别</li>
<li>vue的特点</li>
<li>vue的双向绑定原理</li>
<li>谈谈js设计模式</li>
<li>如何实现订阅者发者模式</li>
<li>MVVM实现原理</li>
<li>vue生命周期</li>
<li>vue跨组件通信实现</li>
<li>vue的props和slot的使用，区别</li>
<li>vuex的原理</li>
<li>详细说明解决跨域的方式</li>
<li>前端安全（资源枚举，XSS共计，DOS攻击，CSRF攻击）</li>
<li>HTTP状态码</li>
<li>重排重绘</li>
<li>谈谈JS的异步机制</li>
<li>项目中是是如何优化页面的</li>
<li>如何实现移动端布局，适配方案</li>
<li>call apply bind的区别</li>
<li>深拷贝的实现</li>
<li>jQuery原理，平时用jQuery都做过什么</li>
<li>用过webpack吗，谈一下webpack打包</li>
<li>给了一个settimeout代码输出的顺序</li>
<li>git命令</li>
<li>Linux命令</li>
<li>JS基础有几种</li>
<li>流式布局</li>
<li>对前端的了解和个人规划</li>
<li>html5的新特性</li>
<li>float和position的区别</li>
<li>如何获取当前日期</li>
<li>html语义化，好处</li>
<li>计算器</li>
<li>清除浮动</li>
<li>盒子模型</li>
<li>border-box和content-box</li>
<li>css伪元素有哪些</li>
<li>打开连接到网页呈现的流程</li>
<li>HTTP请求头，响应头里面有哪些</li>
<li>异步加载JS</li>
<li>JS原型</li>
<li>看哪些技术网站</li>
<li>觉得自己的不足</li>
<li>cookie实现</li>
<li>cookie长度限制</li>
<li>http状态码</li>
<li>301 302</li>
<li>性能优化</li>
<li>一个网页很多很多页面，怎么样让用户体验好一点</li>
<li>一个项目可能要延期，怎么样处理</li>
<li>URL长度限制</li>
<li>缓存</li>
<li>什么时候用local，什么时候用session和 storage</li>
<li>长连接</li>
<li>有没有抓过包</li>
<li>有没有用过代理</li>
<li>DNS</li>
<li>图片压缩</li>
<li>gzip</li>
<li>浏览器兼容</li>
<li>webpack css兼容</li>
<li>css性能</li>
<li>垂直居中，水平居中</li>
<li>盒子米线</li>
<li>last-modifined，etg怎么样判断</li>
<li>css动画优化</li>
<li>401状态码</li>
<li>reflow和repaint</li>
<li>应用层协议有哪些</li>
<li>TCP和UDP</li>
<li>有哪些状态码</li>
<li>Ajax如何实现的</li>
<li>Ajax返回204算是成功吗</li>
<li>settimeout异步</li>
<li>tcp ip分成</li>
<li>vue diff算法</li>
<li>vue的生命周期</li>
<li>pwa</li>
<li>vue-router不能解决情况和边界情况</li>
<li>transition生命周期</li>
<li>线程和进程的区别</li>
<li>什么是异步</li>
<li>promise是如何解析异步操作的</li>
<li>如果给a,b,c,d四个时间，执行时间分别为1，2，3，4，怎么样做才能在abc都在执行完后再执行d，除了使用promise还能使用什么方法</li>
<li>数组去重方法</li>
<li>函数节流和函数防抖知道吗，区别是什么</li>
<li>TCP和UDP的区别</li>
<li>HTTP1.0和HTTP1.1相关我让你听</li>
<li>强缓存和协商缓存知道吗</li>
<li>为什么HTTP1.1中使用Cache-Control代替Expires</li>
<li>HTTP1.1中Etg和f-None-Match哪个权重比较大</li>
<li>排序的几种方法知道吗，是如何实现的</li>
<li>栈和队列有什么区别，具体的应用场景</li>
<li>hashmap原理</li>
<li>react中props和state的区别</li>
<li>组件怎么样拿到redux的数据</li>
<li>给你一个DOM元素，用CSS的方式让他呈现两个的想过，只有一个DOM元素</li>
<li>一个数组只有1和2，排序，1在前面，2在后面</li>
<li>js事件模型，捕获和冒泡，阻止冒泡</li>
<li>preventDefault和stopPropagation的区别</li>
<li>HTTP缓存</li>
<li>https</li>
<li>react的事件绑定和原生有什么区别吗</li>
<li>一个数组，有很多数字存在2次，只有一个数字寸一次，怎么样找出这个数字</li>
<li>关于iframe内部和外部变量的读取是如何的</li>
<li>前端防连击throttle和debounce</li>
<li>ES6 generator async/await了解吗</li>
<li>HTTP/2有什么新特性</li>
<li>哈希的原理</li>
<li>如何反转链表</li>
<li>二叉搜索树的原理</li>
<li>给定两个文本文件，找出他们中相同的行都有哪些</li>
<li>对JS单线程的理解</li>
<li>页面共享数据的方法有哪些</li>
<li>amd，cmd规范</li>
<li>用户页面打开很慢，有哪些优化方式</li>
<li>react的虚拟DOM了解什么，这些类型的框架和传统的jd操作dom的优势</li>
<li>koa generator能讲一下吗</li>
<li>如何做单侧，单侧和开发占比应该是多少</li>
<li>hybrid</li>
<li>v-model参数</li>
<li>mvvm，mvc，mvp区别</li>
<li>cdn</li>
<li>网络安全xss，csfr是什么，怎么样解决安全</li>
<li>https怎么样校验证书有效性</li>
<li>websocket协议，nodejs中有哪些实现了这个协议</li>
<li>TCP/IP体系结构以及每层的主要协议</li>
<li>TCP的三次握手</li>
<li>HTTP各版本比较</li>
<li>数据结构学过什么</li>
<li>js如何实现一个栈</li>
<li>哈希表是怎么样的结构</li>
<li>说说操作系统的内存管理</li>
<li>怎么样实现一个服务器</li>
<li>如何删除一个dom节点</li>
<li>浏览器如何渲染页面的</li>
<li>GitHub的项目问</li>
<li>看过什么书</li>
<li>你是如何理解HTML语义化的</li>
<li>HTML的黑钻模型有哪些构成的，盒子模型有哪些，默认是哪些</li>
<li>盒子模型有没有办法把宽度设置为包含padding</li>
<li>浮动元素有没有什么特性</li>
<li>清除浮动的所有方法</li>
<li>ji基本数据类型</li>
<li>typeof去判断数据类型返回值有哪些</li>
<li>说说事件代理利用的是什么原理</li>
<li>阻止冒泡的函数是什么</li>
<li>cookie有什么特征</li>
<li>加入访问http://A.com存进了一个cookie，在另外一个页面用ajax向A的域名发请求会携带cookie吗</li>
<li>cookie的其他解决方案</li>
<li>localStorage存储数据格式是什么</li>
<li>怎么样把一个数组存进localSorage</li>
<li>storage有哪些存储方法</li>
<li>html5有哪些新的特性</li>
<li>假设两台电脑之间同步画板如何实现</li>
<li>promise的两个方法，具体实现</li>
<li>es6用的多的有哪些</li>
<li>箭头函数</li>
<li>如果一个页面做辛夷花，从哪些方面考察，从哪些地方优化</li>
<li>vue开发模式和jQuery模式有哪些不同，有哪些优缺点</li>
<li>假设一个object A里面的值n为1，怎么样知道n改变了，有事件绑定吗</li>
<li>react是如何实现数据绑定的</li>
<li>给数字加千位分隔符</li>
<li>HTTP1 SPDY HTTP2的对比</li>
<li>webkit内核渲染页面过程</li>
<li>简单介绍一下backbone</li>
<li>react首次渲染过程</li>
<li>redux和vuex的区别</li>
<li>了解过weex吗</li>
<li>typescript和es6的区别</li>
<li>知道xss吗，介绍一下，如何避免</li>
<li>跨域方式</li>
<li>如何理解html语义化</li>
<li>浏览器如何处理未知的的tab</li>
<li>html5有什么新的tag，canvas…</li>
<li>nodejs的优势，用过nodejs的哪些模块</li>
<li>预约系统如何解决高并发的问题</li>
<li>kut如何优化react的diff，有去提pr吗，为什么</li>
<li>简单说一下ICP UDP</li>
<li>Socks5代理是如何实现的，读过协议吗</li>
<li>http状态码，307是什么，401和403的区别</li>
<li>酸酸是如何实现穿墙的</li>
<li>如何实现文件上传的功能</li>
<li>垂直居中的实现</li>
<li>react和vue的区别</li>
<li>介绍一下盒子模型</li>
<li>实现css动画有哪些</li>
<li>jsonp如何实现，过程</li>
<li>知道哪些http状态码</li>
<li>200和304实现缓存的区别</li>
<li>localstorage和cookie的区别，如何设置cookie</li>
<li>表单提交和ajax的区别</li>
<li>calc属性</li>
<li>symbol</li>
<li>事件监听</li>
<li>常见的请求方式</li>
<li>tcp和http的区别</li>
<li>css的定位属性，怎么样定位的</li>
<li>情景题：给你一个ul列表，找到点击的li对象，把点击到的对象的字符串翻转，讲出思路并且写出代码</li>
<li>只能用获取到对象的属性</li>
<li>小程序的生命周期</li>
<li>小程序的Onlaunch周期不支持同步获取信息之后再执行到下一个生命周期</li>
<li>你怎么样维持用户登录状态的</li>
<li>给你一颗树，如何找到其公共的父节点</li>
<li>你最荣耀的事情</li>
<li>你怎么样知道我们公司的，为什么来我们公司</li>
<li>rem，px，em的区别</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
